<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AGC020C Median Sum</title>
    <url>/2020/01/08/AGC020C-Median-Sum/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定<script type="math/tex">n</script>个数<script type="math/tex">a_i</script>，求这<script type="math/tex">n</script>个数构成的<script type="math/tex">2^n-1</script>个子集的和的中位数。</p>
<p>其中<script type="math/tex">n\le 2000,a_i\le 2000</script></p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p><script type="math/tex">Atcoder</script>的题面永远那么简单，思维难度依然那么高。。。</p>
<p>看到这个中位数就感到很头疼，这么大的范围，感觉可能就是一个结论题。</p>
<p>确实是结论题，只是想不到。。。</p>
<p>设<script type="math/tex">sum</script>表示这些数的和。</p>
<p>考虑任何一个<script type="math/tex">\sum q_i< \frac{1}{2}sum</script>的非空也非全集的子集<script type="math/tex">{q}</script>，那么它的补集，记为<script type="math/tex">q</script>，因为<script type="math/tex">\sum p_i + \sum q_i = sum</script>，必然有<script type="math/tex">\sum q_i > \frac{1}{2}sum</script>，所以，如果把所有和不等于<script type="math/tex">\frac{1}{2}sum</script>的子集分为<script type="math/tex"><\frac{1}{2}sum</script>及<script type="math/tex">>\frac{1}{2}sum</script>两组，<strong>两组之间的元素是一一对应的</strong>。也就是说，<strong>两组中的元素个数是相等的！</strong></p>
<p><strong>一一对应推到出个数相等，这是数学中的常用技巧，也适用于信息竞赛中。</strong></p>
<p>然后，等于<script type="math/tex">\frac{1}{2}sum</script>的子集个数显然也是偶数个，因此，这个集合的中位数就相当于在<script type="math/tex">\frac{1}{2}sum</script>的中间位置划了一条线，前面和后面的元素个数相等。</p>
<p>最后，因为最终的集合个数又加了一个总的和（加在最后），所以中位数就是所有出现的和中第一个<script type="math/tex">\ge \frac{1}{2}sum</script>的数。注意，因为<script type="math/tex">sum</script>可能是奇数，所以应该是<script type="math/tex">\ge (sum+1)/2</script>。</p>
<p>那么，考虑怎么维护最终所有可能出现的和的集合？</p>
<p>动态规划？超时。而<script type="math/tex">BUG</script>般的存在<script type="math/tex">bitset</script>就能完美地在<script type="math/tex">O(\frac{n^2\times max(a_i) }{w})</script>的时间解决这道题了。</p>
<p>哎，思维还是不太行呢。。。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, sum, x;</span><br><span class="line"></span><br><span class="line">bitset&lt;N * N&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), s = s | (s &lt;&lt; x), sum += x;</span><br><span class="line">    sum = (sum + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N * N; i++)</span><br><span class="line">        <span class="keyword">if</span>(s[i] &amp;&amp; i &gt;= sum) &#123; <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC011F Train Service Planning</title>
    <url>/2020/04/03/AGC011F-Train-Service-Planning/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有一个<script type="math/tex">n+1</script>个车站的铁路，分别为<script type="math/tex">0,1,...,n</script>号，显然铁路被分为<script type="math/tex">n</script>段，设<script type="math/tex">a_i</script>为火车从第<script type="math/tex">i-1</script>个车站到第<script type="math/tex">i</script>个车站所需时间（也是第<script type="math/tex">i</script>个车站到第<script type="math/tex">i-1</script>个车站的所需时间），每段铁路还有一个参数<script type="math/tex">b_i=1/2</script>表示这段路是单向道还是双向道，如果是单向道，同一时间不能被两辆不同方向的火车经过，如果是双向道就没有限制。</p>
<p>现在有两种车，一种从<script type="math/tex">0</script>开到<script type="math/tex">n</script>，另外一种从<script type="math/tex">n</script>开到<script type="math/tex">0</script>，且每隔<script type="math/tex">k</script>单位时间就会发一辆车（两种都发），我们的任务是调整两种车在每个站台的停留时间，使得不存在某个时刻两种车在同一个单向道上相遇，求满足这个条件的情况下，<script type="math/tex">0->n</script>的时间与<script type="math/tex">n->0</script>的时间之和的最小值。若无法完成，则输出<script type="math/tex">-1</script>。</p>
<p>其中<script type="math/tex">n\le 1e5,k,a_i\le 1e9,b_i\le 2</script>。</p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>非常巧妙的一道题。</p>
<p>首先，我们注意到因为每隔<script type="math/tex">k</script>发一次车，所以整个问题我们可以看成在<script type="math/tex">mod\quad k</script>意义下进行的。</p>
<p>然后，我们发现整个问题可以转化为区间问题，即有一些长度固定的区间，然后我们的限制是在模意义下，一些区间不能相交。</p>
<p>具体地，我们设<script type="math/tex">p_i</script>为第一种车在第<script type="math/tex">i</script>个车站的停留时间（<script type="math/tex">0\le i \le n</script>），设<script type="math/tex">q_i</script>为第二种车在第<script type="math/tex">i</script>个车站的停留时间，然后设<script type="math/tex">P_i</script>表示<script type="math/tex">p_0,...p_i</script>的和，<script type="math/tex">Q_i</script>同理，<script type="math/tex">A_i</script>即<script type="math/tex">a</script>的前缀和。</p>
<p>我们发现第一种车的区间是<script type="math/tex">p</script>和<script type="math/tex">a</script>的前缀和的形式，第二种车的每个区间却是<script type="math/tex">q</script>和<script type="math/tex">a</script>的后缀和的形式，非常不好处理。</p>
<p>但是我们发现一个好处是整个问题是在取模的意义下进行的。</p>
<p>在时间轴上取模，就相当于拿一个长度为<script type="math/tex">k</script>的窗口在时间轴上滑动，不管窗口在什么位置，截到的时间及其上面发生的事件都是等价的。</p>
<p>我们设窗口截到的最右边是整个事件结束，那么<script type="math/tex">q_0</script>的意义相当于第二种车到达<script type="math/tex">0</script>号站后再等待<script type="math/tex">q_0</script>时间才得以结束。</p>
<p>为了与第一种车的区间形式相似，我们考虑对第二种车进行时光倒流，把第二种车也看成从<script type="math/tex">0->n</script>，然后看成它在<script type="math/tex">0</script>号车站等待了<script type="math/tex">-q_0</script>单位时间，然后到达<script type="math/tex">1</script>号车站的时间为<script type="math/tex">-q_0-a_1</script>，以此类推。</p>
<p>通过这样的操作，我们将第一种车和第二种车的区间形式都统一为前缀和的形式。</p>
<p>更具体地，第一种车在第<script type="math/tex">i-1</script>到第<script type="math/tex">i</script>个车站的时间区间和第二种车从第<script type="math/tex">i</script>个车站到第<script type="math/tex">i - 1</script>个的时间区间分别为为</p>
<script type="math/tex; mode=display">
(P_{i-1}+A_{i-1},P_{i-1}+A_i)\\
(-Q_{i-1}-A_i,-Q_{i-1}-A_{i-1})</script><p>这样看起来形式非常统一，我们后面也会很好处理。</p>
<p>现在，我们就是要求在取模意义下，这两个区间不相交。因为区间相交比较好算（好理解），我们先转化为区间相交，再取补集。</p>
<p>区间相交，即其中一个区间的端点在另一个区间内。</p>
<p>我们列出以下不等式</p>
<script type="math/tex; mode=display">
-Q_{i-1}-A_i<P_{i-1}+A_{i-1}<-Q_{i-1}-A_{i-1}\\
-Q_{i-1}-A_i<P_{i-1}+A_i<-Q_{i-1}-A_{i-1}</script><p>两个不等式是或的关系，即只要一个成立即可。</p>
<p>这两个不等式肯定是在模的意义下成立，但是在模的意义下理解不等式又比较困难，我们这么来思考模意义下不等式的含义。</p>
<p>实际上，在模意义下，<script type="math/tex">a<b<c</script>的意义为在<script type="math/tex">(a,c)</script>中存在一个数，与<script type="math/tex">b</script>同余。这样理解起来就要好多了！</p>
<p>那么显然<script type="math/tex">a<b<c</script>等价于<script type="math/tex">a+d<b+d<c+d</script>（考虑上面所说的意义即可），即这个不等式可以按照解普通不等式的方法来解。</p>
<p>那么解得</p>
<script type="math/tex; mode=display">
-2A_i<P_{i-1}+Q_{i-1}<-2A_{i-1}</script><p>那么其补集就是在模意义下，</p>
<script type="math/tex; mode=display">
P_{i-1}+Q_{i-1}\in [-2A_{i-1},-2A_i]</script><p>这样一来，因为<script type="math/tex">A</script>是已知的，所以我们就能确定<script type="math/tex">P_i+Q_i</script>的范围。</p>
<p>因为我们最终要求最小化的是</p>
<script type="math/tex; mode=display">
P_{n-1}+Q_{n-1}-p_0-q_0</script><p>所以问题就转化成十分可做的形式了！</p>
<p>这样，问题转化为：</p>
<p>有一个数列<script type="math/tex">t</script>，满足<script type="math/tex">t[i]\ge t[i-1]</script>，然后对于某些特定的<script type="math/tex">i</script>（<script type="math/tex">b_i=1</script>），要满足<script type="math/tex">t[i]\quad mod\quad k\in [L[i],R[i]]</script>。求<script type="math/tex">t_n-t_1</script>的最小值。</p>
<p>我们考虑用<script type="math/tex">dp</script>来解决，设<script type="math/tex">f[i][j]</script>表示处理了前<script type="math/tex">i</script>个，当前<script type="math/tex">t[i]\quad mod\quad k=j</script>时最小的<script type="math/tex">t[i]</script>。（对于<script type="math/tex">-t_1</script>的限制可以直接把<script type="math/tex">f[1]</script>中满足条件的变成<script type="math/tex">0</script>，别的变成<script type="math/tex">inf</script>），那么转移的时候，首先如果本来就在<script type="math/tex">[L[i],R[i]]</script>中的自然不会改变，其他的因为只能往一个方向走，必然是走到<script type="math/tex">L[i]</script>处，那么用不在区间中的步数最小值来更新<script type="math/tex">L[i]</script>的值，并把不在区间中的全部赋值为<script type="math/tex">inf</script>即可。</p>
<p>这样复杂度显然飞了，我们发现几个显然的性质：</p>
<p>因为每次必然会走到<script type="math/tex">L[i]</script>处或者不动，所以<script type="math/tex">j</script>的取值只有<script type="math/tex">2n</script>种。</p>
<p>然后我们发现这个东西显然可以用一棵线段树方便地维护，所以直接线段树优化一下即可，记得线段树种记得是当前最小的步数减去当前位置的值，用来更新后面的答案。</p>
<p>最后输出线段树中最小值加上<script type="math/tex">2A[n]</script>即可。</p>
<p>时间复杂度<script type="math/tex">O(nlog_2n)</script>，记得特判如果<script type="math/tex">b[i]==1</script>且<script type="math/tex">2a[i]>k</script>，输出<script type="math/tex">-1</script>，这个根据前面区间的分析很容易得到。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> LL inf = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LL mn;</span><br><span class="line">    <span class="keyword">bool</span> lazy;</span><br><span class="line">&#125;tree[maxN * <span class="number">4</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K, cnt;</span><br><span class="line"><span class="keyword">int</span> a[maxN + <span class="number">1</span>], b[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> L[maxN + <span class="number">1</span>], R[maxN + <span class="number">1</span>], tmp[maxN + <span class="number">1</span>];</span><br><span class="line">LL sum[maxN + <span class="number">1</span>], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>( !<span class="built_in">isdigit</span>( ch ) ) &#123; <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">isdigit</span>( ch ) ) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> num * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[node].mn = <span class="built_in">min</span>(tree[node &lt;&lt; <span class="number">1</span>].mn, tree[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[node &lt;&lt; <span class="number">1</span>].mn = tree[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mn = inf;</span><br><span class="line">    tree[node &lt;&lt; <span class="number">1</span>].lazy = tree[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lazy = <span class="literal">true</span>;</span><br><span class="line">    tree[node].lazy = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[node].lazy = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123; tree[node].mn = -tmp[l]; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(node &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; y) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= l &amp;&amp; r &lt;= y)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[node].mn = inf;</span><br><span class="line">        tree[node].lazy = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree[node].lazy) <span class="built_in">pushdown</span>(node);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(node &lt;&lt; <span class="number">1</span>, l, mid, x, y);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid) <span class="built_in">modify</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y);</span><br><span class="line">    <span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, LL num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123; tree[node].mn = <span class="built_in">min</span>(tree[node].mn, num); <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree[node].lazy) <span class="built_in">pushdown</span>(node);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">change</span>(node &lt;&lt; <span class="number">1</span>, l, mid, x, num);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">change</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x, num);</span><br><span class="line">    <span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; y) <span class="keyword">return</span> inf;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= l &amp;&amp; r &lt;= y) <span class="keyword">return</span> tree[node].mn;</span><br><span class="line">    <span class="keyword">if</span>(tree[node].lazy) <span class="built_in">pushdown</span>(node);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; LL ans = inf;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) ans = <span class="built_in">min</span>(ans, <span class="built_in">query</span>(node &lt;&lt; <span class="number">1</span>, l, mid, x, y));</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid) ans = <span class="built_in">min</span>(ans, <span class="built_in">query</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123; ans = <span class="built_in">min</span>(ans, tree[node].mn + tmp[l]); <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree[node].lazy) <span class="built_in">pushdown</span>(node);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">get</span>(node &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">get</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), K = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = <span class="built_in">read</span>(), b[i] = <span class="built_in">read</span>();</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">        <span class="keyword">if</span>(b[i] == <span class="number">1</span>) L[i] = (K - <span class="number">2ll</span> * sum[i - <span class="number">1</span>] % K) % K, R[i] = (K - <span class="number">2ll</span> * sum[i] % K) % K;</span><br><span class="line">        <span class="keyword">else</span> L[i] = <span class="number">0</span>, R[i] = K - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(b[i] == <span class="number">1</span> &amp;&amp; <span class="number">2ll</span> * a[i] &gt; K)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp[++ cnt] = L[i]; tmp[++ cnt] = R[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(tmp + <span class="number">1</span>, tmp + cnt + <span class="number">1</span>);</span><br><span class="line">    cnt = <span class="built_in">unique</span>(tmp + <span class="number">1</span>, tmp + cnt + <span class="number">1</span>) - tmp - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, cnt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">lower_bound</span>(tmp + <span class="number">1</span>, tmp + cnt + <span class="number">1</span>, L[i]) - tmp, r = <span class="built_in">lower_bound</span>(tmp + <span class="number">1</span>, tmp + cnt + <span class="number">1</span>, R[i]) - tmp;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            LL t = <span class="built_in">min</span>(<span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, cnt, <span class="number">1</span>, l - <span class="number">1</span>) + tmp[l], <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, cnt, r + <span class="number">1</span>, cnt) + K + tmp[l]);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, cnt, <span class="number">1</span>, l - <span class="number">1</span>); <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, cnt, r + <span class="number">1</span>, cnt);</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>, <span class="number">1</span>, cnt, l, t - tmp[l]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            LL t = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, cnt, r + <span class="number">1</span>, l - <span class="number">1</span>) + tmp[l];</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, cnt, r + <span class="number">1</span>, l - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>, <span class="number">1</span>, cnt, l, t - tmp[l]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans = inf;</span><br><span class="line">    <span class="built_in">get</span>(<span class="number">1</span>, <span class="number">1</span>, cnt);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans + <span class="number">2ll</span> * sum[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><script type="math/tex">Atcoder</script>这种题，一般都要问题转化。</p>
<p>遇到一些列式子的情况，我们要想办法把式子转化为类似的形式，有利于后面化简（例如本题考虑时光倒流），这是本题最巧妙的思想！</p>
<p>然后对于取模意义下的区间一般都转化成判断相交并转化为不等式问题，一定要多加理解取模意义下的不等式的含义。</p>
]]></content>
      <categories>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC009E Eternal Average</title>
    <url>/2020/01/03/AGC009E-Eternal-Average/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有<script type="math/tex">n</script>个0和<script type="math/tex">m</script>个1，每次选出<script type="math/tex">k</script>个数删去，并把它们的平均数加入，最后只剩下一个数字（保证<script type="math/tex">k-1|n+m-1</script>），问最后剩下的数字有多少种可能？</p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>又是神仙题一道，<script type="math/tex">Atcoder</script>上的<script type="math/tex">dp</script>怎么都那么神仙啊。。。</p>
<p>考虑构造一个树形结构，有<script type="math/tex">n+m</script>个叶子节点，每次操作相当于给某<script type="math/tex">k</script>个点连上一个祖先，权值为其孩子的权值的平均数，显然，最后的答案是根节点的值。</p>
<p>考虑每个叶子节点的贡献，假设<script type="math/tex">n</script>个<script type="math/tex">0</script>叶子深度为<script type="math/tex">x1,x2,...xn</script>，<script type="math/tex">m</script>个<script type="math/tex">1</script>叶子深度为<script type="math/tex">y1,y2,...ym</script>，那么根节点的值就是<script type="math/tex">\sum k^{-yi}</script>。这个想一想就知道了。</p>
<p>其实想不到树形结构也没有关系，依然是考虑每个数<script type="math/tex">i</script>的贡献，若它被选了<script type="math/tex">t</script>次，那么它的贡献就是<script type="math/tex">\frac{a[i]}{k^t}</script>。其中<script type="math/tex">a[i]</script>是这个数的值。</p>
<p>然而后面的就不好想了，我们怎么计算这个东西的值呢？</p>
<p>看到这样一个固定的值<script type="math/tex">k</script>的若干次方和，就应该想到转化为<script type="math/tex">k</script>进制数来统计。我们只要统计满足条件的<script type="math/tex">k</script>进制小数个数即可。</p>
<p>问题在于，满足什么条件的<script type="math/tex">k</script>进制小数才是合法的呢？</p>
<p>首先，我们把<script type="math/tex">xi</script>也看成<script type="math/tex">1</script>，那么就有<script type="math/tex">\sum k^{-xi}+\sum k^{-yi}=1</script>（考虑那棵树的意义即可，这个真的很难想到诶），所以，当我们确定了其中<script type="math/tex">\sum k^{-yi}</script>的<script type="math/tex">k</script>进制小数时，<script type="math/tex">\sum k^{-xi}</script>的小数也确定了，所以，对于一个<script type="math/tex">k</script>进制小数<script type="math/tex">c</script>，我们不仅要看它能不能写成<script type="math/tex">c=\sum k^{-yi}</script>的形式，也要看是否有<script type="math/tex">1-c=\sum k^{-xi}</script>。那么，我们怎么看是否有<script type="math/tex">c=\sum k^{-yi}</script>呢？</p>
<p>我们假设这个<script type="math/tex">k</script>进制小数有<script type="math/tex">len</script>位，为</p>
<script type="math/tex; mode=display">
c_1,c_2,c_3,...,c_{len}</script><p>那么首先，很显然地<script type="math/tex">\sum c_i\le m</script>（虽然显然，但是还是难以想到这是一个限制条件，可能这就是这一类题的套路吧），还有，如果不考虑进位，可以得知<script type="math/tex">\sum c_i=m</script>，然后，考虑每次进位，我们会损失掉<script type="math/tex">k</script>个数，但是我们会在前面一位加上$1$个数，也就是说，每次进位，我们会损失<script type="math/tex">k-1</script>个数，那么，另外一个限制条件是<script type="math/tex">\sum c_i\equiv m\quad (mod\quad k-1)</script>。</p>
<p>所以这个限制对于<script type="math/tex">1-c</script>也是同理的，我们可以算出来<script type="math/tex">\sum(1-c)_i=(len-1)\times (k-1)+k-\sum c_i</script>，<script type="math/tex">(1-c)_i</script>表示<script type="math/tex">1-c</script>的第<script type="math/tex">i</script>位。那么，统计的时候如此判断一下即可。</p>
<p>于是，我们就可以用<script type="math/tex">dp</script>，设<script type="math/tex">dp[i][j][0/1]</script>表示前<script type="math/tex">i</script>位，和为<script type="math/tex">j</script>，最后一位为<script type="math/tex">0</script>或其他的方案数即可。为什么要有最后一位？因为我们统计的时候最后一位一定是非零的，所以要单独拿出来。然后<script type="math/tex">dp</script>方程很显然，前缀和优化一下即可。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">2005</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n, m, k, len, ans;</span><br><span class="line"><span class="keyword">int</span> f[maxN * <span class="number">2</span> + <span class="number">1</span>][maxN + <span class="number">1</span>][<span class="number">2</span>], sum[maxN * <span class="number">2</span> + <span class="number">1</span>][maxN + <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ADD</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y &gt;= mod ? x + y - mod : x + y; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">SUB</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x - y &lt; <span class="number">0</span> ? x - y + mod : x - y; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    len = (n + m - <span class="number">1</span>) / (k - <span class="number">1</span>);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) sum[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j][<span class="number">0</span>] = <span class="built_in">ADD</span>(f[i - <span class="number">1</span>][j][<span class="number">0</span>], f[i - <span class="number">1</span>][j][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(j) f[i][j][<span class="number">1</span>] = <span class="built_in">SUB</span>(sum[i - <span class="number">1</span>][j - <span class="number">1</span>], j &gt;= k ? sum[i - <span class="number">1</span>][j - k] : <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> t = (i - <span class="number">1</span>) * (k - <span class="number">1</span>) + k - j;</span><br><span class="line">            <span class="keyword">if</span>(j &lt;= m &amp;&amp; j % (k - <span class="number">1</span>) == m % (k - <span class="number">1</span>) &amp;&amp; t &lt;= n &amp;&amp; t % (k - <span class="number">1</span>) == n % (k - <span class="number">1</span>)) </span><br><span class="line">                ans = <span class="built_in">ADD</span>(ans, f[i][j][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(j) sum[i][j] = sum[i][j - <span class="number">1</span>];</span><br><span class="line">            sum[i][j] = <span class="built_in">ADD</span>(sum[i][j], <span class="built_in">ADD</span>(f[i][j][<span class="number">0</span>], f[i][j][<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>那么，这一道题，我们学到了什么？</p>
<p>首先，对于一些元素进行运算的结果之类的问题，我们可以考虑每个元素的贡献，就会简单很多。</p>
<p>对于形如<script type="math/tex">\sum_{i=1}^n k^{t_i}</script>的不同结果数的形式，我们往往把它对应到一个<script type="math/tex">k</script>进制数上去统计，而统计的条件是<script type="math/tex">\sum c_i \le n</script>，<script type="math/tex">\sum c_i \equiv n\quad (mod\quad k-1)</script>，这一点如果没做过这类题，还是挺难想的。</p>
<p>总之，<script type="math/tex">Atcoder</script>上的<script type="math/tex">dp</script>题思维难度都很高，遇到没有思路的题目，想一想转化模型，比如建图，构树之类的，也许就会豁然开朗。</p>
]]></content>
      <categories>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC021F Trinity</title>
    <url>/2020/04/02/AGC021F-Trinity/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有一个<script type="math/tex">n\times m</script>的网格，你要把它每个格子涂成黑或白色，定义<script type="math/tex">A_i</script>为第<script type="math/tex">i</script>行第一个涂成黑色的列，<script type="math/tex">B_i</script>为第<script type="math/tex">i</script>列第一个涂成黑色的行，<script type="math/tex">C_i</script>表示第<script type="math/tex">i</script>列最后一个涂成黑色的行，问有多少种可能的<script type="math/tex">(A,B,C)</script>组合？</p>
<p>其中<script type="math/tex">n\le 8000,m\le 200</script></p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>因为列的限制要多于行的限制，所以我们可以按列的顺序来考虑，每次考虑当前列行的选取情况。</p>
<p>考虑<script type="math/tex">dp</script>，设<script type="math/tex">f[i][j]</script>表示前<script type="math/tex">i</script>列，已经有<script type="math/tex">j</script>行被选的方案数。</p>
<p>然后我们发现，我们并不好转移当前列的第一个和最后一个选的是什么。</p>
<p>遇到这种情况，我们一般考虑转化一下状态的定义，设<script type="math/tex">f[i][j]</script>表示前<script type="math/tex">i</script>列，选了<script type="math/tex">j</script>行，仅考虑这<script type="math/tex">j</script>行的相对顺序，并不管具体是哪<script type="math/tex">j</script>行的方案数，那么我们每次就是要往当前的行中插入一些行。</p>
<p>那么，最后的答案显然是<script type="math/tex">ans=\sum_{i=0}^n \binom{n}{i}f[m][i]</script>。</p>
<p>然后我们考虑怎样转移。</p>
<p>我们枚举在当前列插入<script type="math/tex">k</script>个行，计算方案数。</p>
<p>我们假设我们已经插入完了，那么插入完以后，当前列有多少种的选择方案？</p>
<p>首先当前插入的行我们肯定是要选的，那么我们的问题就是原本就存在的行的选择情况。我们发现，只有在<strong>插入的第一个行的上面有多少原来存在的行和插入的最后一行下面有多少原来存在的行才对我们的答案有影响</strong>，不妨设插入的第一个行上面有<script type="math/tex">c_1</script>个行，插入的最后一个行下面有<script type="math/tex">c_2</script>个行，那么当前插入方案对答案的贡献就是<script type="math/tex">(c_1+1)(c_2+1)</script>。</p>
<p>我们将插入行的方案数和对答案的贡献放在一起考虑，我们假设插入的<script type="math/tex">k</script>个行把原来的<script type="math/tex">j</script>行分为<script type="math/tex">k+1</script>段，那么我们有</p>
<script type="math/tex; mode=display">
x_1+x_2+...+x_{k+1}=j\\x_1,x_2,...,x_{k+1}\ge 0</script><p>对于每种满足条件的方案数，对答案的贡献为</p>
<script type="math/tex; mode=display">
(x_1+1)(x_{k+1}+1)</script><p>这是一个经典的问题了，考虑组合意义，相当于我们要在分出的<script type="math/tex">k+1</script>个组的第一个和最后一个组再分为<script type="math/tex">\ge 0</script>的两个部分的方案数。</p>
<p>设</p>
<script type="math/tex; mode=display">
x_1=x_{1,0}+x_{1,1}\\
x_{k+1}=x_{k+1,0}+x_{k+1,1}</script><p>那么答案相当于</p>
<script type="math/tex; mode=display">
x_{1,0}+x_{1,1}+x_2+x_3+...+x_{k+1,0}+x_{k+1,1}=j</script><p>其中所有元素<script type="math/tex">\ge 0</script>的整数解个数，那么显然通过组合数学知识，这个方案数等于<script type="math/tex">\binom{j+k+2}{k+2}</script>。</p>
<p>但是注意，以上的分析仅在<script type="math/tex">k>0</script>的时候成立，如果<script type="math/tex">k=0</script>，要单独讨论。</p>
<p>考虑<script type="math/tex">k=0</script>的情况，首先，如果<script type="math/tex">j=0</script>，那么贡献为<script type="math/tex">1</script>；否则，考虑现在<script type="math/tex">j</script>行，一共有<script type="math/tex">j+1</script>个空位，我们选择两个空位，这样我们相当于选<strong>较上面那个空位的下面一行，较下面那个空位的上面一行</strong>，这样选的话，能精准覆盖到每一种情况，那么贡献即为<script type="math/tex">\binom{j+1}{2}+1</script>，<script type="math/tex">+1</script>表示一个都不选。</p>
<p>那么转移方程就出来了</p>
<script type="math/tex; mode=display">
f[i][j+k]+=\binom{j+k+2}{k+2}*f[i][j]\quad(k>0)\\
f[i][j]+=f[i][j]*(\binom{j+1}{2}+1)</script><p>这样时间复杂度为<script type="math/tex">O(mn^2)</script>显然无法通过本题。</p>
<p>那么我们考虑优化，第二个式子复杂度正确，不需要优化，那么我们看第一个式子。</p>
<p>第一个式子相当于</p>
<script type="math/tex; mode=display">
f[i][j]=\sum_{k=0}^{j-1}\binom{j+2}{j+2-k}*f[i][k]\\
=(j+2)!\sum_{k=0}^{j-1}\frac{1}{(j+2-k)!}*\frac{f[i][k]}{k!}</script><p>这显然是一个卷积形式，相当于</p>
<script type="math/tex; mode=display">
c[n]=\sum_{i=0}^{n-1}\frac{1}{(n-1-(i-3))!}*\frac{a[i]}{i!}</script><p>直接<script type="math/tex">NTT</script>优化即可，时间复杂度<script type="math/tex">O(mnlog_2n)</script>。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">4e4</span> + <span class="number">10</span>, mod = <span class="number">998244353</span>, g = <span class="number">3</span>, gi = <span class="number">332748118</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> lim, cnt, r[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">205</span>][<span class="number">8005</span>];</span><br><span class="line"><span class="keyword">int</span> A[maxN + <span class="number">1</span>], B[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> fac[maxN + <span class="number">1</span>], inv[maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ADD</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y &gt;= mod ? x + y - mod : x + y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">SUB</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x - y &lt; <span class="number">0</span> ? x - y + mod : x - y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>) ans = <span class="number">1ll</span> * ans * a % mod;</span><br><span class="line">        a = <span class="number">1ll</span> * a * a % mod;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; r[i]) <span class="built_in">swap</span>(a[i], a[ r[i] ]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> wn = <span class="built_in">mpow</span>(type == <span class="number">1</span> ? g : gi, (mod - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i += (mid &lt;&lt; <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; j++, w = <span class="number">1ll</span> * w * wn % mod)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x = a[i + j], y = <span class="number">1ll</span> * a[i + mid + j] * w % mod;</span><br><span class="line">                a[i + j] = <span class="built_in">ADD</span>(x, y); a[i + mid + j] = <span class="built_in">SUB</span>(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(type == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> inv = <span class="built_in">mpow</span>(lim, mod - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++) a[i] = <span class="number">1ll</span> * a[i] * inv % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span> * fac[n] * inv[m] % mod * inv[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">5</span>; i++) fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    inv[n + <span class="number">5</span>] = <span class="built_in">mpow</span>(fac[n + <span class="number">5</span>], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n + <span class="number">4</span>; i &gt;= <span class="number">0</span>; i--) inv[i] = <span class="number">1ll</span> * inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line"></span><br><span class="line">    lim = <span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(lim &lt;= n * <span class="number">2</span>) lim &lt;&lt;= <span class="number">1</span>, cnt ++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; cnt - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) B[i] = inv[i + <span class="number">3</span>];</span><br><span class="line">    <span class="built_in">NTT</span>(B, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) A[j] = <span class="number">1ll</span> * f[i - <span class="number">1</span>][j] * inv[j] % mod;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NTT</span>(A, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j++) A[j] = <span class="number">1ll</span> * A[j] * B[j] % mod;</span><br><span class="line">        <span class="built_in">NTT</span>(A, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) </span><br><span class="line">            f[i][j] = <span class="built_in">ADD</span>(<span class="number">1ll</span> * fac[j + <span class="number">2</span>] * A[j - <span class="number">1</span>] % mod, <span class="number">1ll</span> * <span class="built_in">ADD</span>(<span class="built_in">C</span>(j + <span class="number">1</span>, <span class="number">2</span>), <span class="number">1</span>) * f[i - <span class="number">1</span>][j] % mod);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j++) A[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) ans = <span class="built_in">ADD</span>(ans, <span class="number">1ll</span> * f[m][i] * <span class="built_in">C</span>(n, i) % mod);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们对于两个维度限制问题，一般按照限制多的那一维度的顺序进行<script type="math/tex">dp</script>，每次考虑当前维度的选择方案。</p>
<p>对于网格问题，也可以使用<strong>考虑相对顺序，每次插入的方法</strong>。</p>
<p>实际上，如果我们每次的决策依赖于我们已经选择的东西的顺序情况，但并不知道具体选择了什么东西的时候，就可以考虑插入的方法。</p>
<p>我们按照一定顺序进行插入，就是为了去掉一些限制，比如我们按照从大到小插入，我们就钦定了当前插入的元素是所有的元素中最小的，就去掉了大小限制，再比如这道题，我们每次插入，就能知道已经选择的行和当前插入行的顺序关系，便于做题。</p>
<p>这个思想非常重要，考试的时候如果没有思路也许可以往插入的方向想一想，有时能直接去掉一些限制。</p>
]]></content>
      <categories>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>[BZOJ1002]轮状病毒</title>
    <url>/2019/02/07/BZOJ1002-%E8%BD%AE%E7%8A%B6%E7%97%85%E6%AF%92/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>n轮状病毒的产生规律是在一个<script type="math/tex">n</script>轮状基中删去若干条边，使得各原子之间有唯一的信息通道，例如共有<script type="math/tex">16</script>个不同的<script type="math/tex">3</script>轮状病毒。</p>
<p>现给定<script type="math/tex">n<=100</script>，编程计算有多少个不同的<script type="math/tex">n</script>轮状病毒。</p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>其实刚刚看到这一题，就想到了一个东西：<strong>矩阵树定理</strong>。这不是矩阵树定理的裸题吗？</p>
<p>刚刚准备敲代码的时候，偷偷瞄了一眼题解，突然意识到这一题答案太大了，用矩阵树定理，要用高斯消元，而高斯消元要用long double来存储，而答案一大，long double就爆掉了。。。</p>
<p>果断放弃了矩阵树，怎么办呢？</p>
<p>这时，我们发现可以打表找规律，于是，我拿出草稿纸，大力画图，最终，得出一个结果：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">5</td>
<td style="text-align:center">16</td>
<td style="text-align:center">45</td>
<td style="text-align:center">121</td>
</tr>
</tbody>
</table>
</div>
<p>额，看起来好像并没有什么规律，但仔细一看，好像奇数号都是完全平方数，例如</p>
<script type="math/tex; mode=display">
1=1^2,16=4^2,121=11^2</script><p>然而，还是看不出什么规律，我们再将完全平方数联系第二个和第四个，又惊奇地发现:</p>
<script type="math/tex; mode=display">
5=3^2-4,45=7^2-4</script><p>我们再把跟平方数有关的放在一起：</p>
<script type="math/tex; mode=display">
1,3,4,7,11...</script><p>有没有发现什么？这就是以<script type="math/tex">1,3</script>开头的另一种斐波那契数列啊！！我们只要打出这一串数列，然后分类讨论一下：如果n是奇数，就直接平方，否则就平方再减四。</p>
<p>嗯，我觉得在考场上，我也许是能想出这个的，因为矩阵树定理可以帮我们把1~50（或更多）的表给打出来，然后一个一个找规律……</p>
<p>还有，这一题要高精度，可惜我高精度都不会了，重载运算符经过多人指点，终于调对了，这也可以当高精度运算的板子吧：</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN=<span class="number">1000</span> + <span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">big</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[maxN+<span class="number">1</span>],len;</span><br><span class="line">    <span class="built_in">big</span>() &#123; len=<span class="number">1</span>; <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(a)); &#125;</span><br><span class="line">    big <span class="keyword">operator</span> + (big rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        big ans;</span><br><span class="line">        ans.len=<span class="built_in">max</span>(len,rhs.len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ans.len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=a[i]+rhs.a[i];</span><br><span class="line">            ans.a[i]+=tmp%<span class="number">10</span>;</span><br><span class="line">            ans.a[i+<span class="number">1</span>]+=tmp/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(ans.a[ans.len+<span class="number">1</span>]) ans.len++;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    big <span class="keyword">operator</span> * (big rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        big ans;</span><br><span class="line">        ans.len=len+rhs.len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=rhs.len;j++) ans.a[i+j<span class="number">-1</span>]+=a[i]*rhs.a[j];</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(ans.a[i]||i&lt;=ans.len)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.a[i+<span class="number">1</span>]+=ans.a[i]/<span class="number">10</span>;</span><br><span class="line">            ans.a[i]%=<span class="number">10</span>; i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!ans.a[i]) i--;</span><br><span class="line">        ans.len=i;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    big <span class="keyword">operator</span> - (big rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        big ans;</span><br><span class="line">        ans.len=<span class="built_in">max</span>(len,rhs.len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ans.len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.a[i]+=a[i]-rhs.a[i];</span><br><span class="line">            <span class="keyword">if</span>(ans.a[i]&lt;<span class="number">0</span>) ans.a[i]+=<span class="number">10</span>,ans.a[i+<span class="number">1</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(ans.a[ans.len+<span class="number">1</span>]) ans.len++;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="comment">//高精度的板子</span></span><br><span class="line">big f[<span class="number">105</span>],ans;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(big ans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=ans.len;i&gt;=<span class="number">1</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans.a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    f[<span class="number">1</span>].a[<span class="number">1</span>]=<span class="number">1</span>; f[<span class="number">2</span>].a[<span class="number">1</span>]=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++) f[i]=f[i<span class="number">-1</span>]+f[i<span class="number">-2</span>];</span><br><span class="line">    ans=f[n]*f[n];</span><br><span class="line">    big tmp; tmp.a[<span class="number">1</span>]=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>) ans=ans-tmp;</span><br><span class="line">    <span class="built_in">print</span>(ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，除了打表找规律以外，这一题对于我来说的难度就是高精度了（捂脸），我感觉高精度已经很不熟练了呢，不过，近年来考高精度的频率到是越来越少了呢。</p>
<p>总之，综合性的题目还是很重要的，毕竟考试不太可能出裸题吧。。。</p>
]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC038E Gachapon</title>
    <url>/2020/02/29/AGC038E-Gachapon/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>由一个随机数生成器，每次生成一个<script type="math/tex">[0,n-1]</script>的数，每个数出现的概率为<script type="math/tex">\frac{a_i}{S}</script>（<script type="math/tex">S=\sum a_i</script>）。</p>
<p>我们现在要求每个数<script type="math/tex">i</script>都满足其出现次数<script type="math/tex">>=b_i</script>的期望时间。</p>
<p>其中<script type="math/tex">n\le 400,\sum a_i \le 400, \sum b_i \le 400</script>。</p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>其实，本质上就是求一个集合，其中每个元素如果存在，说明它已经出现了<script type="math/tex">>=b_i</script>次，问这个集合被填满的最晚时间的期望。</p>
<p>很显然，这是<script type="math/tex">min-max</script>容斥的模型，所以我们先套<script type="math/tex">min-max</script>容斥</p>
<script type="math/tex; mode=display">
ANS=E(max(S))=\sum_{T\subset S}(-1)^{|T|-1}E(min(T))</script><p>其中<script type="math/tex">min(T)</script>的意思是<script type="math/tex">T</script>这个集合中的元素开始存在某个出现<script type="math/tex">>=b_i</script>次的期望时间。</p>
<p>这个问题显然比一开始要求的要好一些，然而还是无法算。</p>
<p>下面是很重要的一步转化，</p>
<p>对于一个集合<script type="math/tex">T</script>，再考虑一些集合<script type="math/tex">S(T)=\{x_i|i\in T,x_i<b_i\}</script>，<script type="math/tex">x_i</script>表示<script type="math/tex">i</script>出现的次数。</p>
<p>实际上，根据期望的线性，<script type="math/tex">E(min(T))</script>等于这些<script type="math/tex">S(T)</script>中每个集合<script type="math/tex">s</script>走向下一个状态的期望步数乘以到达<script type="math/tex">s</script>这个状态的概率。</p>
<p>为什么？</p>
<p>我们考虑所有的<script type="math/tex">S(T)</script>中的集合<script type="math/tex">s</script>构成一张有向无环图，每个点表示一个状态<script type="math/tex">s</script>，连向每个后继状态一条边，边权是走到那个状态的期望步数。注意，每个节点只与<script type="math/tex">T</script>中的元素的<script type="math/tex">x</script>相关。</p>
<p>我们给所有<script type="math/tex">\{x_i|i\in T,\exists x_i=b_i\}</script>的节点连向且只连向一个终止节点<script type="math/tex">end</script>，边权为<script type="math/tex">0</script>，设初始节点<script type="math/tex">start=\{x_i|i\in T,x_i=0\}</script>。</p>
<p>那么实际上，<script type="math/tex">E(min(T))</script>就等于<script type="math/tex">start</script>到<script type="math/tex">end</script>的期望步数。</p>
<p>我们想把整个贡献拆分成边的贡献。</p>
<p>我们考虑在这个图上<script type="math/tex">dp</script>，<script type="math/tex">f[s]</script>表示到达<script type="math/tex">s</script>这个状态点的期望步数，设<script type="math/tex">t</script>为<script type="math/tex">s</script>的一个后继状态，那么显然有</p>
<script type="math/tex; mode=display">
f[t]+=(f[s]+w(s,t))*P(start->s)*p(s,t)</script><p>其中<script type="math/tex">w(s,t)</script>指<script type="math/tex">s->t</script>的期望步数，<script type="math/tex">p(s,t)</script>指的是从<script type="math/tex">s->t</script>的概率，<script type="math/tex">P(start->s)</script>表示<script type="math/tex">start</script>到<script type="math/tex">s</script>的概率。</p>
<p>我们不需要求到达每个点的期望，只需要求那个总贡献。</p>
<p>我们观察每条边<script type="math/tex">(s,t)</script>的贡献，发现实际上它的贡献是</p>
<script type="math/tex; mode=display">
P(start->s)*p(s,t)*w(s,t)*P(t->end)</script><p>对于任何一个节点，它最终一定能走到<script type="math/tex">end</script>，所以<script type="math/tex">P(t->end)=1</script>，那么每条边的贡献是</p>
<script type="math/tex; mode=display">
P(start->s)*p(s,t)*w(s,t)</script><p>注意到对于任何一个<script type="math/tex">s</script>，我们设</p>
<script type="math/tex; mode=display">
w(s,nxt)=\sum_t p(s,t)*w(s,t)</script><p>实际上，<script type="math/tex">w(s,nxt)</script>是我们可以算出来的，即每个状态到下一个状态（不管具体是什么，只要与<script type="math/tex">s</script>不同）的期望步数，具体怎么算，我们后面再说。</p>
<p>那么我们可以考虑计算<strong>每个点连出去的边对答案的贡献和</strong>。</p>
<p>那么，所有的贡献就可以写成</p>
<script type="math/tex; mode=display">
\sum_s P(start->s)*w(s,nxt)</script><p>这样，我们就证明了。实际上，这个推演方法可以推广到很多相关的题目中。</p>
<p>那么<script type="math/tex">w(s,nxt)</script>等于什么呢？我们设其为<script type="math/tex">W</script>，所有<script type="math/tex">a_i</script>的和为<script type="math/tex">S</script>，所有<script type="math/tex">i\in T</script>的<script type="math/tex">a_i</script>和为<script type="math/tex">S_T</script>，则</p>
<script type="math/tex; mode=display">
W=\frac{S_T}{S}*1+(1-\frac{S_T}{S})*(W+1)\\
W=\frac{S}{S_T}</script><p>我们现在的问题，就是求对于某个<script type="math/tex">s</script>，<script type="math/tex">P(start->s)</script>的值。</p>
<p>好，这又是这道题的另一个难点！</p>
<p>我们设<script type="math/tex">X=\sum x_i</script>，我们考虑这个随机数生成器生成的序列<script type="math/tex">t_1,t_2,...</script>，那么，我们考虑的是这个序列中前<script type="math/tex">X</script>个出现<script type="math/tex">T</script>中存在的数的位置构成的数列。</p>
<p>别的位置生成任何一个数我们都不关心，概率为<script type="math/tex">1</script>，对我们要考虑的东西没有影响。</p>
<p>所以我们相当于单独把这<script type="math/tex">X</script>个数拿来讨论。</p>
<p>我们要考虑的，是这<script type="math/tex">X</script>个数中对于每一个<script type="math/tex">i</script>，满足<script type="math/tex">i</script>出现了<script type="math/tex">x_i</script>次的概率。</p>
<p>因为这<script type="math/tex">X</script>个数只会出现<script type="math/tex">T</script>中有的数，所以别的数我们一概忽略，这<script type="math/tex">X</script>个数中每个数出现的概率为<script type="math/tex">\frac{a_i}{S_T}</script>。</p>
<p>那么总概率为</p>
<script type="math/tex; mode=display">
\frac{X!}{\prod_{i\in T}x_i!}\prod_{i\in T}(\frac{a_i}{S_T})^{x_i}</script><p>为什么呢？我们考虑后面那个式子，是我们钦定了这<script type="math/tex">X</script>个数出现的顺序并且每个<script type="math/tex">i</script>出现<script type="math/tex">x_i</script>次的概率，但是这些数是可以无序出现的，所以我们要乘以这些东西出现的顺序，就是前面那一项。</p>
<p>我们考虑如果枚举<script type="math/tex">T</script>的话时间复杂度是不现实的，</p>
<p>所以我们现在考虑把<strong>最后的答案<script type="math/tex">ANS</script></strong>拆成每个状态<script type="math/tex">s</script>的贡献。</p>
<p>我们每一个<script type="math/tex">s</script>对于一个<script type="math/tex">T</script>的贡献是</p>
<script type="math/tex; mode=display">
\frac{S}{S_T}*\frac{X!}{\prod_{i\in T}x_i!}\prod_{i\in T}(\frac{a_i}{S_T})^{x_i}\\
=S*X!*(\frac{1}{S_T})^{X+1}\prod_{i\in T}\frac{a_i^{x_i}}{x_i!}</script><p>好，我们观察这个式子，发现实际上前面只与<script type="math/tex">X</script>和<script type="math/tex">S_T</script>有关，后面才与每个数相关，而奇妙的时候，后面每个数的贡献都是独立的，与<script type="math/tex">T</script>这个集合总体无关。</p>
<p>接下来也十分巧妙！</p>
<p>那么，我们考虑<script type="math/tex">dp</script>，设<script type="math/tex">f[i][j]</script>表示所有的<script type="math/tex">s</script>满足<script type="math/tex">S_T=i</script>，<script type="math/tex">X=j</script>的容斥系数之和是多少。</p>
<p>我们枚举每一位选或不选来转移，如果不选，就继承上一次的答案，如果选了，因为多加了一个元素，所以容斥系数取反，然后转移一下就好了，细节见代码。</p>
<p>注意，初始状态为<script type="math/tex">f[0][0]=-1</script>，因为<script type="math/tex">min-max</script>容斥的系数是<script type="math/tex">(-1)^{|T|-1}</script>。</p>
<p>复杂度<script type="math/tex">O((\sum a_i)(\sum b_i)^2)</script>。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">405</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[maxN + <span class="number">1</span>], b[maxN + <span class="number">1</span>], sa, sb;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>][maxN + <span class="number">1</span>][maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> fac[maxN + <span class="number">1</span>], inv[maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ADD</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y &gt;= mod ? x + y - mod : x + y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">SUB</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x - y &lt; <span class="number">0</span> ? x - y + mod : x - y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>) ans = <span class="number">1ll</span> * ans * a % mod;</span><br><span class="line">        a = <span class="number">1ll</span> * a * a % mod;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a[i], &amp;b[i]), sa += a[i], sb += b[i];</span><br><span class="line"></span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sb; i++) fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    inv[sb] = <span class="built_in">mpow</span>(fac[sb], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = sb - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) inv[i] = <span class="number">1ll</span> * inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    f[now][<span class="number">0</span>][<span class="number">0</span>] = mod - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        now ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= sa; s++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= sb; x++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[now][s][x] = f[now ^ <span class="number">1</span>][s][x];</span><br><span class="line">                <span class="keyword">if</span>(s &lt; a[i]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">0</span>, w = <span class="number">1</span>; t &lt; b[i] &amp;&amp; t &lt;= x; t++, w = <span class="number">1ll</span> * w * a[i] % mod)</span><br><span class="line">                    f[now][s][x] = <span class="built_in">SUB</span>(f[now][s][x], <span class="number">1ll</span> * w * inv[t] % mod * f[now ^ <span class="number">1</span>][s - a[i]][x - t] % mod);			   </span><br><span class="line">                &#125;	</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= sa; s++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> INV = <span class="built_in">mpow</span>(s, mod - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>, t = INV; x &lt;= sb; x++, t = <span class="number">1ll</span> * t * INV % mod)</span><br><span class="line">            ans = <span class="built_in">ADD</span>(ans, <span class="number">1ll</span> * t * fac[x] % mod * f[now][s][x] % mod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans = <span class="number">1ll</span> * ans * sa % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>首先，这道题蕴含了许多的概率期望技巧和套路，需要牢记一些小<script type="math/tex">trick</script>，例如把总的期望步数拆成每个状态到其后继的期望步数乘以到这个状态的概率，还有可重复的数列出现概率的计算，都是应该仔细揣摩的。</p>
<p>然后，有一个思想十分重要，就是我们考虑一个数列中只跟某个集合中的数有关的位置时，我们可以忽略其他数的影响，直接考虑这些位置本身的相对关系，包括这里概率的计算，和之前有些题都是一样，这样可以大大减少思维难度，相当于只考虑一个跟这个集合中有关的数列的概率一样，因为其他位置不管出现什么数都无关，所以概率时<script type="math/tex">1</script>，可以忽略。</p>
<p>最后，非常重要的<script type="math/tex">dp</script>，我们要观察到一个东西的贡献式子如果只与这个东西的某些性质有关（比如这一题，只与集合的<script type="math/tex">\sum a_i</script>和<script type="math/tex">\sum x_i</script>有关），其他的都是独立的话，我们就可以<script type="math/tex">dp</script>，把状态设为这些性质，然后<script type="math/tex">dp</script>出其贡献的系数，最后累加即可，也是一个非常重要的思想。</p>
]]></content>
      <categories>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>概率期望</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC030F Permutation and Minimum</title>
    <url>/2021/03/01/AGC030F-Permutation-and-Minimum/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>对于<script type="math/tex">2n</script>个数的排列<script type="math/tex">p</script>，定义其生成数列<script type="math/tex">g_i=\min(p_{2i-1},p_{2i})\quad\forall 1\le i\le n</script>。现在有一个<script type="math/tex">2n</script>个数的排列，其中有一些位置还不确定，问在所有合法的填法中，能生成的不同的<script type="math/tex">g</script>的个数，答案对<script type="math/tex">1e9+7</script>取模。</p>
<p>两个<script type="math/tex">g</script>不同当且仅当存在<script type="math/tex">1\le i\le n</script>，使得<script type="math/tex">g1_i\neq g2_i</script>。</p>
<p>其中<script type="math/tex">1\le n\le 300</script>。</p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Tip1"><a href="#Tip1" class="headerlink" title="Tip1"></a>Tip1</h2><p>这类问题可以形式化地表述为：我们有一个<script type="math/tex">f</script>，根据一些操作变成<script type="math/tex">g</script>，我们要数<script type="math/tex">g</script>的个数。</p>
<p>这种问题的麻烦处在于，如果只数<script type="math/tex">f</script>，会把<script type="math/tex">g</script>算重，如果只数<script type="math/tex">g</script>，有些<script type="math/tex">g</script>是不合法的，会算多。</p>
<p>那么，我们就是要在<script type="math/tex">g</script>和<script type="math/tex">f</script>中建立一个桥梁，即一个构造方法（很多时候是贪心），使得每个合法的<script type="math/tex">g_0</script>通过构造能得到唯一一个合法的<script type="math/tex">f_0</script>，且这个<script type="math/tex">f_0</script>通过原来的操作变成的序列为<script type="math/tex">g_0</script>。</p>
<p>我们考虑对<script type="math/tex">g</script>序列进行<script type="math/tex">dp</script>，同时<script type="math/tex">dp</script>状态维护当前<script type="math/tex">g</script>经过构造形成的<script type="math/tex">f</script>的必要参数。最后，只要<script type="math/tex">f</script>的参数表明构造出了合法的<script type="math/tex">f</script>，那么<script type="math/tex">g</script>也是合法的。也就是说，最后把所有表示<script type="math/tex">f</script>合法的<script type="math/tex">dp</script>值加起来即可。</p>
<hr>
<p>现在考虑本题。</p>
<p>显然，本题中的<script type="math/tex">f</script>就是<script type="math/tex">n</script>个二元组组成的序列，<script type="math/tex">g</script>就是题目所述的生成序列。</p>
<p>可以发现，本题的<script type="math/tex">n</script>个二元组可以分为<script type="math/tex">3</script>种类型，分别为<script type="math/tex">(0,-1),(-1,-1),(0,0)</script>，其中<script type="math/tex">0</script>表示给定的数，<script type="math/tex">-1</script>表示可以随便填的数。可以发现，<script type="math/tex">(0,0)</script>对答案没用，因此可以忽略它。</p>
<p>那么，我们把所有形如<script type="math/tex">(0,-1)</script>的分为一类，设为<script type="math/tex">A</script>，所有<script type="math/tex">(-1,-1)</script>的分为一类，设为<script type="math/tex">B</script>。</p>
<p>我们考虑通过一个合法的<script type="math/tex">g</script>构造出唯一的相应的<script type="math/tex">f</script>。</p>
<p>注意到因为我们统计的是<script type="math/tex">g</script>的个数，因此每个二元组内部交换顺序，<script type="math/tex">g</script>不变，那么我们不妨假设<script type="math/tex">f</script>中所有二元组<script type="math/tex">(a_i,b_i)</script>都满足<script type="math/tex">a_i<b_i</script>。</p>
<p>考虑从小到大枚举数。</p>
<p>如果这个数是已经给定的，那么直接放到它对应的二元组去，如果那个二元组还没有数，就填在左边，否则填在右边（为了满足<script type="math/tex">a_i<b_i</script>）。</p>
<p>如果这个数不是给定的，那么有两种情况：第一种，它出现在<script type="math/tex">g</script>中，即它是某个二元组的最小值，那么我们把它填在其在<script type="math/tex">g</script>出现位置的那个二元组的左边。否则，如果它不出现在<script type="math/tex">g</script>中，那么说明它是某个二元组的最小值，那么考虑当前所有<strong>已经填了左边数且右边数不是给定的二元组</strong>，实际上它可以放在这些二元组中的任何一个，但是由于我们要求构造出唯一的一个<script type="math/tex">f</script>，不难想到将它填在其中左边数字最小的那个二元组中。</p>
<p>如此构造出相应的<script type="math/tex">f</script>。</p>
<p>可以发现，一个合法的<script type="math/tex">g</script>唯一对应一个操作序列，而一个操作序列也唯一对应一个合法的<script type="math/tex">g</script>（因为构造出来的<script type="math/tex">f</script>唯一对应一个<script type="math/tex">g</script>）。</p>
<p>那么我们现在考虑如何<script type="math/tex">dp</script>。</p>
<p>考虑如果我们想要完成这个操作序列需要知道什么？</p>
<p>首先如果这个数已经给定，那么它填的位置已经确定，所以不需要知道信息。</p>
<p>如果这个数没有被给定，那么它需要知道什么信息呢？如果它出现在<script type="math/tex">g</script>中，那么我们需要知道有多少个二元组一个数都没填，然后选一个填下去。否则，如果它不出现在<script type="math/tex">g</script>中，那么我们需要知道有多少个二元组已经填了左边数且右边数不是给定的。因此，我们一共需要这两个状态。</p>
<p>根据这个进行<script type="math/tex">dp</script>，问题似乎解决了？？</p>
<p>但是，我们很快发现这个做法有些问题。在这个算法中，可能出现我们填已经<strong>给定的数</strong>的时候，如果我们决定填左边，而实际上左边已经被填过了。又或者如果我们准备填右边，而实际上这个二元组左边还没有被填。这个时候，<script type="math/tex">g</script>已经不合法了，但还是被我们统计到了答案里。</p>
<p>如果还是考虑<strong>给定的数</strong>能否填，似乎只有记录所有<script type="math/tex">A</script>中二元组的状态？这是无法接受的。</p>
<p>既然无法考虑<strong>给定的数</strong>能否填，不如在填<strong>没给定的数</strong>的时候决定它应该和哪个进行配对，然后再考虑<strong>给定的数</strong>的时候在一个固定的集合里选择。</p>
<p>具体地，我们在状态中记录一维表示当前有多少个<strong>没给定的数</strong>决定以后和<strong>给定的数</strong>配对。那么每次填<strong>给定的数</strong>的时候，如果它想放在后面（不出现在<script type="math/tex">g</script>中）的话，就在这些数中选一个进行配对即可。</p>
<h2 id="Tip2"><a href="#Tip2" class="headerlink" title="Tip2"></a>Tip2</h2><p>这是一个很常用的思想，即当我们按照一定顺序进行<script type="math/tex">dp</script>，选出来一些元素要放在某些位置，但是如果在选出来这个元素的同时决定它放在哪个位置会影响后面的选择，那么不如先把它放入一个候选集合中，等到需要它的时候再拿出来即可。</p>
<hr>
<p>那么，我们设<script type="math/tex">f[i][j][k]</script>表示考虑了所有<script type="math/tex">\le i</script>的数，有<script type="math/tex">j</script>个数决定和<strong>给定的数</strong>配对，有<script type="math/tex">k</script>个数决定和<strong>没给定的数</strong>配对的方案数。</p>
<p>但是，这样还有一个问题，如果我们当前考虑的数是<strong>没给定的</strong>，而我们想填在<script type="math/tex">B</script>组的左边，那么我们还要记录当前有多少个还没被填的<script type="math/tex">B</script>组，来进行选择。</p>
<p>这样，时间复杂度又不对了。注意到实际上<script type="math/tex">B</script>组中的二元组是可以交换的，那么我们不妨假设所有<script type="math/tex">B</script>组二元组满足<script type="math/tex">a_1<a_2<\dots<a_k</script>（其中<script type="math/tex">k</script>是<script type="math/tex">B</script>组的大小），最后乘以<script type="math/tex">k!</script>即可。</p>
<p>因此，当我们把<strong>没给定的数</strong>填到<script type="math/tex">B</script>组的左边时无需考虑具体填到哪个二元组，因为它会自动填在当前所有已经填了左边数的<script type="math/tex">B</script>组二元组的后面那个二元组中。</p>
<p>接下来，转移过程就很简单了。设当前考虑<script type="math/tex">f[i][j][k]</script>能往哪些地方转移。</p>
<p>如果它是<strong>给定的</strong>：</p>
<p>第一种情况，想让它在<script type="math/tex">g</script>中出现，那么它后面一定配对一个<strong>没给定的数</strong>，那么<script type="math/tex">f[i+1][j][k+1]+=f[i][j][k]</script>。</p>
<p>第二种情况，它不在<script type="math/tex">g</script>中出现，那么在候选集合中选一个，<script type="math/tex">f[i+1][j-1][k]+=f[i][j][k]\times j</script>。</p>
<p>如果它是<strong>没给定的</strong>：</p>
<p>第一种情况，想让它在<script type="math/tex">g</script>中出现，那么它后面既可以配对<strong>给定的</strong>，也可以配对<strong>没给定的</strong>，因此<script type="math/tex">f[i+1][j+1][k]+=f[i][j][k],f[i+1][j][k+1]+=f[i][j][k]</script>。</p>
<p>第二种情况，不在<script type="math/tex">g</script>中出现，那么和配对集合中数字最小的那个配对，即<script type="math/tex">f[i+1][j][k-1]+=f[i][j][k]</script>。</p>
<p>最后的答案是<script type="math/tex">f[2n][0][0]\times k!</script>。</p>
<p>为什么这两个状态都是<script type="math/tex">0</script>就一定符合条件呢？这个状态中丝毫没有用到<script type="math/tex">A</script>组和<script type="math/tex">B</script>组的集合大小，会不会最后构造出来的<script type="math/tex">f</script>两个集合大小和原来不相等呢？</p>
<p>不会，因为在去除了两边都给定的二元组的情况下，只需要知道有多少个数字给定，多少个数字没给定，就能推出<script type="math/tex">A</script>和<script type="math/tex">B</script>的大小。而这两个状态都是<script type="math/tex">0</script>，说明这<script type="math/tex">2n</script>个数已经合法地填满了所有的二元组，自然满足条件。</p>
<p>时间复杂度<script type="math/tex">O(n^3)</script>。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">305</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, s;</span><br><span class="line"><span class="keyword">int</span> flag[maxN * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>][maxN + <span class="number">1</span>][maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123; x = x + y &gt;= mod ? x + y - mod : x + y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span>(x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123; flag[x] = flag[y] = <span class="number">2</span>; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; <span class="number">0</span>) flag[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(y &gt; <span class="number">0</span>) flag[y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) s ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    f[now][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        now ^= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(f[now], <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f[now]));</span><br><span class="line">        <span class="keyword">if</span>(flag[i] == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n; k++)</span><br><span class="line">                    f[now][j][k] = f[now ^ <span class="number">1</span>][j][k];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!f[now ^ <span class="number">1</span>][j][k]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> res = f[now ^ <span class="number">1</span>][j][k];</span><br><span class="line">                <span class="keyword">if</span>(!flag[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">update</span>(f[now][j + <span class="number">1</span>][k], res);</span><br><span class="line">                    <span class="built_in">update</span>(f[now][j][k + <span class="number">1</span>], res);</span><br><span class="line">                    <span class="keyword">if</span>(j) <span class="built_in">update</span>(f[now][j - <span class="number">1</span>][k], res);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">update</span>(f[now][j + <span class="number">1</span>][k], res);</span><br><span class="line">                    <span class="keyword">if</span>(k) <span class="built_in">update</span>(f[now][j][k - <span class="number">1</span>], <span class="number">1ll</span> * res * k % mod);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = f[now][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s; i++) ans = <span class="number">1ll</span> * ans * i % mod;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以后我们遇到这类计数”由某个操作生成的序列“的问题，首先考虑判定问题：一个序列能否被生成？</p>
<p>如果这个问题可以在这个序列上从头到尾遍历的同时用贪心解决，且贪心过程所用到的信息（称为贪心参数）是<script type="math/tex">O(1)</script>的，那么我们就可以从头到尾以这些信息作为状态进行<script type="math/tex">dp</script>。</p>
<p>我们的思想实际上是对<script type="math/tex">g</script>进行<script type="math/tex">dp</script>，但是有的<script type="math/tex">g</script>是不合法的，因此我们在状态中加入可以判定是否合法的贪心参数，最后对所有合法的答案累加。</p>
]]></content>
      <categories>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>[BZOJ1003]物流运输</title>
    <url>/2019/02/07/BZOJ1003-%E7%89%A9%E6%B5%81%E8%BF%90%E8%BE%93/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>物流公司要把一批货物从码头A运到码头B。由于货物量比较大，需要n天才能运完。货物运输过程中一般要转停好几个码头。物流公司通常会设计一条固定的运输路线，以便对整个运输过程实施严格的管理和跟踪。由于各种因素的存在，有的时候某个码头会无法装卸货物。这时候就必须修改运输路线，让货物能够按时到达目的地。但是修改路线是一件十分麻烦的事情，会带来额外的成本。因此物流公司希望能够订一个n天的运输计划，使得总成本尽可能地小。</p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>其实我一开始看到这一题的想法是网络流，但是发现用网络流要统计答案，特别是要加上路径的长度很难搞，就放弃了。。。</p>
<p>这一题的正解是<script type="math/tex">dp</script>，怎么<script type="math/tex">dp</script>呢？</p>
<p>我们设<script type="math/tex">f[i]</script>为第<script type="math/tex">i</script>天时的最小费用，则状态转移方程为：</p>
<script type="math/tex; mode=display">
f[i]=min(f[i],f[j-1]+(i-j+1)*L+K)(1<=j<=i);</script><p>怎么理解？其实，j枚举的是上一次改变路径的天，这样，从j~i所用的都是同一种路径方案，L就是这种方案所需要的路径最短长度（可以用最短路来解决），K就是花费。</p>
<p>接着，我们考虑损坏的码头。</p>
<p>损坏的码头只会影响<script type="math/tex">L</script>的大小，如果我们在<script type="math/tex">j->i</script>中选择某条路径，那么我们必须保证这条路径上的所有码头在<script type="math/tex">j->i</script>这段时间中都没有损坏，换句话说，我们将在<script type="math/tex">j->i</script>这段时间里会在某一天损坏的码头全部做上标记，再用最短路跑，避开做上标记的就可以了。</p>
<p>可以一个一个地判，我用的方法是倒着枚举j，然后每次如果有新的损坏的码头，就加上标记（具体看代码吧）。这样，就结束了。</p>
<p>有个小细节要注意一下：初始化的时候<script type="math/tex">f[0]=-K</script>。为什么呢？因为第一次变换路径是不需要支付K的损失的（因为那是初始路径）。其他，基本就好了。</p>
<p>这么小的数据范围，当然上<script type="math/tex">spfa</script>了（谁说它死了？）</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN=<span class="number">500</span>,inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,value,next;</span><br><span class="line">&#125;edge[maxN*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,K,e,d,dis[maxN+<span class="number">1</span>],f[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> tot,head[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> flag[maxN+<span class="number">1</span>][maxN+<span class="number">1</span>],vis[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> mark[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) num=(num&lt;&lt;<span class="number">3</span>)+(num&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> num*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++tot]=(Node)&#123;y,t,head[x]&#125;; head[x]=tot;</span><br><span class="line">    edge[++tot]=(Node)&#123;x,t,head[y]&#125;; head[y]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q; q.<span class="built_in">push</span>(<span class="number">1</span>); dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[x]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)</span><br><span class="line">            <span class="keyword">if</span>(!mark[edge[i].to]&amp;&amp;dis[x]+edge[i].value&lt;dis[edge[i].to])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[edge[i].to]=dis[x]+edge[i].value;</span><br><span class="line">                <span class="keyword">if</span>(!vis[edge[i].to])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[edge[i].to]=<span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(edge[i].to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>]=-K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(mark,<span class="literal">false</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(mark));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=m;k++)</span><br><span class="line">                <span class="keyword">if</span>(flag[k][j]) mark[k]=<span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">spfa</span>();</span><br><span class="line">            <span class="keyword">if</span>(dis[m]&gt;=inf) <span class="keyword">continue</span>;</span><br><span class="line">            f[i]=<span class="built_in">min</span>(f[i],f[j<span class="number">-1</span>]+(i-j+<span class="number">1</span>)*dis[m]+K);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),K=<span class="built_in">read</span>(),e=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=e;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>(),t=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(x,y,t);</span><br><span class="line">    &#125;</span><br><span class="line">    d=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=d;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p=<span class="built_in">read</span>(),a=<span class="built_in">read</span>(),b=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=a;j&lt;=b;j++) flag[p][j]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总之，dp方程还是不太好想的（可能我太弱了），还是要多加练习呢。</p>
]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>[BZOJ2134]单选错位</title>
    <url>/2019/01/28/BZOJ2134-%E5%8D%95%E9%80%89%E9%94%99%E4%BD%8D/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>gx 和 lc 去参加 noip 初赛，其中有一种题型叫单项选择题，顾名思义，只有一个选项是正确答案。</p>
<p>试卷上共有 <script type="math/tex">n</script> 道单选题，第 i 道单选题有 <script type="math/tex">a_i</script>个选项，这 <script type="math/tex">a_i</script>个选项编号是 <script type="math/tex">1,2,3,\ldots,a_i</script>，每个选项成为正确答案的概率都是相等的。</p>
<p>lc 采取的策略是每道题目随机写上 <script type="math/tex">1,...,a_i</script> 的某个数作为答案选项，他用不了多少时间就能期望做对 <script type="math/tex">\sum\frac{1}{a_i}</script>道题目。gx 则是认认真真地做完了这 <script type="math/tex">n</script>道题目，可是等他做完的时候时间也所剩无几了，于是他匆忙地把答案抄到答题纸上，没想到抄错位了：第 <script type="math/tex">i</script>道题目的答案抄到了答题纸上的第<script type="math/tex">i+1</script> 道题目的位置上，特别地，第 <script type="math/tex">n</script> 道题目的答案抄到了第 <script type="math/tex">1</script> 道题目的位置上。</p>
<p>现在 gx 已经走出考场没法改了，不过他还是想知道自己期望能做对几道题目，这样他就知道会不会被 lc 鄙视了。</p>
<p>我们假设 gx 没有做错任何题目，只是答案抄错位置了。</p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>我们考虑对于第<script type="math/tex">i</script>题和第<script type="math/tex">i-1</script>题，一共有<script type="math/tex">a[i]\times a[i-1]</script>种可能性，显然，其中，<script type="math/tex">ans[i]==ans[i-1]</script>的可能情况有<script type="math/tex">min(a[i],a[i-1])</script>种。</p>
<p>所以，对于每一题<script type="math/tex">i</script>，它对答案的贡献为</p>
<script type="math/tex; mode=display">
\frac{min(a[i],a[i-1])}{a[i]*a[i-1]}</script><p>化简可得</p>
<script type="math/tex; mode=display">
\frac{1}{max(a[i],a[i-1])}</script><p>由期望的线性，直接相加即可。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN=<span class="number">1e7</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxN+<span class="number">1</span>],n,A,B,C;</span><br><span class="line"><span class="keyword">double</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;n,&amp;A,&amp;B,&amp;C,a+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    a[i] = ((<span class="keyword">long</span> <span class="keyword">long</span>)a[i<span class="number">-1</span>] * A + B) % <span class="number">100000001</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    a[i] = a[i] % C + <span class="number">1</span>;</span><br><span class="line">    ans=(<span class="keyword">double</span>)<span class="number">1</span>/<span class="built_in">max</span>(a[<span class="number">1</span>],a[n]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) ans+=(<span class="keyword">double</span>)<span class="number">1</span>/<span class="built_in">max</span>(a[i],a[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3lf&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>概率期望</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC096E Everything on it</title>
    <url>/2020/02/28/ARC096E-Everything-on-it/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有一个面馆，一共有<script type="math/tex">n</script>种调料，我们要选若干碗面，满足：</p>
<p>1、没有<script type="math/tex">2</script>种面放的调料的集合相同</p>
<p>2、每种调料至少出现在<script type="math/tex">2</script>碗面中</p>
<p>求选择的方案数，答案对<script type="math/tex">mod</script>取模。</p>
<p>其中<script type="math/tex">mod</script>为质数，<script type="math/tex">n\le 3000</script>。</p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>直接算很难算，所以我们考虑计算补集。</p>
<p>但是，因为它要求每一个都满足这个条件，补集为存在某一个不满足这个条件，仍然不好直接算。</p>
<p>因此，我们考虑容斥。</p>
<p>我们钦定<script type="math/tex">m</script>个元素不满足这个条件，即有至少<script type="math/tex">m</script>个元素出现在<script type="math/tex">0/1</script>个集合中。</p>
<p>首先，这个选择方案数显然是<script type="math/tex">C(n,m)</script>。</p>
<p>然后，因为选出来的这些有的出现<script type="math/tex">0</script>次，有的出现<script type="math/tex">1</script>次，所以我们把它们分开。</p>
<p>我们枚举<script type="math/tex">i</script>表示<script type="math/tex">m</script>中有<script type="math/tex">i</script>个是出现<script type="math/tex">1</script>次的，这个选择有<script type="math/tex">C(m,i)</script>种，我们再枚举分成<script type="math/tex">j</script>个集合，那么这一部分钦定的方案数就是</p>
<script type="math/tex; mode=display">
C(n,m)\sum_{i=0}^m C(m,i)\sum_{j=1}^i S(i,j)</script><p>其中，<script type="math/tex">S(n,m)</script>是第二类斯特林数。</p>
<p>接下来，我们考虑剩下的<script type="math/tex">n-m</script>个随便选。</p>
<p>首先，其中一种情况，是只由剩下的元素组成的集合，这个方案数是<script type="math/tex">2^{2^{n-m}}</script>，因为剩下的<script type="math/tex">n-m</script>个元素可以组成<script type="math/tex">2^{n-m}</script>集合，然后每个集合选不选就是<script type="math/tex">2^{2^{n-m}}</script>。</p>
<p>还有一种情况，就是剩下的元素和我们钦定的一些元素构成一个集合。</p>
<p>考虑我们钦定的元素已经构成了<script type="math/tex">j</script>个集合，而且每个集合是独立的，我们现在让这<script type="math/tex">j</script>个集合中的每个集合去选剩下的<script type="math/tex">n-m</script>个元素有哪些和它组成集合。显然，每个集合的选择方案数是<script type="math/tex">2^{n-m}</script>，那么总的选择方案数就是<script type="math/tex">(2^{n-m})^j=2^{j(n-m)}</script>。</p>
<p>所以随便选的方案数就是<script type="math/tex">2^{2^{n-m}}·2^{j(n-m)}</script>。</p>
<p>那么，总的方案数就是</p>
<script type="math/tex; mode=display">
ans=\sum_{m=0}^n(-1)^mC(n,m)\sum_{i=0}^mC(m,i)\sum_{j=1}^iS(i,j)·2^{2^{n-m}}·2^{j(n-m)}</script><p>时间复杂度<script type="math/tex">O(n^3)</script>，并不能通过。</p>
<p>我们考虑优化这个过程，观察整个式子，我们把式子变化一下</p>
<script type="math/tex; mode=display">
ans=\sum_{m=0}^n(-1)^mC(n,m)2^{2^{n-m}}\sum_{j=1}^m2^{j(n-m)}\sum_{i=j}^mS(i,j)C(m,i)</script><p>考虑化简最后那一个式子，它的组合意义是从<script type="math/tex">m</script>个中选出若干个分成<script type="math/tex">j</script>个集合的方案数，我们可以往里面多加一个元素<script type="math/tex">0</script>，然后把这<script type="math/tex">m+1</script>个元素分为<script type="math/tex">j+1</script>组，与<script type="math/tex">0</script>为一组的我们视为不选（即不出现在集合中），与这个式子等价，那么，最后那个式子就可以变成<script type="math/tex">S(m+1,j+1)</script>。</p>
<p>整个式子变成了</p>
<script type="math/tex; mode=display">
ans=\sum_{m=0}^n(-1)^mC(n,m)2^{2^{n-m}}\sum_{j=0}^m2^{j(n-m)}S(m +1,j+1)</script><p>注意此时<script type="math/tex">j</script>变为了从<script type="math/tex">0</script>开始，因为我们会多出来一个集合放不选的。</p>
<p>那么，我们预处理一下<script type="math/tex">2^k</script>的值和<script type="math/tex">S</script>直接做就好了。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">3005</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n, mod;</span><br><span class="line"><span class="keyword">int</span> S[maxN + <span class="number">1</span>][maxN + <span class="number">1</span>], C[maxN + <span class="number">1</span>][maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> pw[maxN * maxN + <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ADD</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y &gt;= mod ? x + y - mod : x + y; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">SUB</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x - y &lt; <span class="number">0</span> ? x - y + mod : x - y; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x, <span class="keyword">int</span> mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>) ans = <span class="number">1ll</span> * ans * a % mod;</span><br><span class="line">        a = <span class="number">1ll</span> * a * a % mod;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;mod);</span><br><span class="line"> </span><br><span class="line">    S[<span class="number">0</span>][<span class="number">0</span>] = C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            C[i][j] = <span class="built_in">ADD</span>(C[i - <span class="number">1</span>][j], C[i - <span class="number">1</span>][j - <span class="number">1</span>]),</span><br><span class="line">            S[i][j] = <span class="built_in">ADD</span>(S[i - <span class="number">1</span>][j - <span class="number">1</span>], <span class="number">1ll</span> * j * S[i - <span class="number">1</span>][j] % mod);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    pw[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * n; i++)</span><br><span class="line">        pw[i] = <span class="number">2ll</span> * pw[i - <span class="number">1</span>] % mod;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">            res = <span class="built_in">ADD</span>(res, <span class="number">1ll</span> * pw[j * (n - i)] * S[i + <span class="number">1</span>][j + <span class="number">1</span>] % mod);</span><br><span class="line">        res = <span class="number">1ll</span> * res * C[n][i] % mod * <span class="built_in">mpow</span>(<span class="number">2</span>, <span class="built_in">mpow</span>(<span class="number">2</span>, n - i, mod - <span class="number">1</span>), mod) % mod;</span><br><span class="line">        ans = (i &amp; <span class="number">1</span>) ? <span class="built_in">SUB</span>(ans, res) : <span class="built_in">ADD</span>(ans, res);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从这道题里，我们学到了什么？</p>
<p>首先，如果遇到每个元素都满足什么条件并且不好搞的话，考虑<strong>正难则反</strong>，如果其补集很好算的话就直接算，如果还是不好算的话，考虑<strong>容斥</strong>，钦定一些东西不满足条件，然后别的随便选。</p>
<p>然后，对于一些式子有的时候我们无从下手来化简，这个时候我们可以考虑组合意义，比如我们不选的东西可以看成划分成一个额外的集合，然后钦定那个集合不选，有的时候就能化简复杂度。</p>
<p>另外，一定要搞清楚集合之间是否独立，例如本题中，我们钦定的元素分出来的集合是独立的，两两不同，可以随便选我们未钦定的元素构成的集合，互不干扰，这些关系一定要弄清楚再推式子。</p>
<p>容斥好难啊，还要多加练习！</p>
]]></content>
      <categories>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title>[BZOJ2173]整数的lqp拆分</title>
    <url>/2019/07/27/BZOJ2173-%E6%95%B4%E6%95%B0%E7%9A%84lqp%E6%8B%86%E5%88%86/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>一个数<script type="math/tex">N=a_1+a_2+...+a_m(m>0)</script>，它的贡献是</p>
<script type="math/tex; mode=display">
Fib{a_1}*Fib{a_2}*...*Fib_{a_m}</script><p>求它的所有整数划分的贡献之和对<script type="math/tex">1e9+7</script>取模。</p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>设<script type="math/tex">F(x)</script>是<script type="math/tex">Fibonacci</script>数列的生成函数，则答案就是</p>
<script type="math/tex; mode=display">
ans=\sum_{i=1}^{\infty}[x^n]F^i(x)=[x^n]\frac{F(x)}{1-F(x)}</script><p>我们先推一下<script type="math/tex">Fibonacci</script>数列（除去第<script type="math/tex">0</script>项）的生成函数。</p>
<script type="math/tex; mode=display">
F(x)=x+2x^2+3x^3+5x^4+...\\
xF(x)=x^2+2x^3+3x^4+5x^5+...\\
(1-x)F(x)=x+x^2+x^3+2x^4+3x^5+...\\
(1-x)F(x)=x+x^2F(x)\\
F(x)=\frac{x}{1-x-x^2}</script><p>则</p>
<script type="math/tex; mode=display">
ans=[x^n]\frac{x}{1-2x-x^2}</script><p>这个，我们该怎么搞呢？</p>
<p><del>查看题解后</del>，我们考虑用递推，我们设<script type="math/tex">G(x)=\frac{x}{1-2x-x^2}</script>，<script type="math/tex">g(n)</script>是第<script type="math/tex">x^n</script>前的系数，则</p>
<script type="math/tex; mode=display">
G(x)-2xG(x)-x^2G(x)=x\\
G(x)=2xG(x)+x^2G(x)+x</script><p>然后我们考虑第<script type="math/tex">n</script>项的系数，<script type="math/tex">G(x)</script>的第<script type="math/tex">n</script>项显然就是<script type="math/tex">g(n)</script>，然后<script type="math/tex">2xG(x)</script>第<script type="math/tex">n</script>项的系数就是<script type="math/tex">2*g(n-1)</script>，<script type="math/tex">x^2G(x)</script>第<script type="math/tex">n</script>项的系数就是<script type="math/tex">g(n-2)</script>，所以</p>
<script type="math/tex; mode=display">
g(n)=2*g(n-1)+g(n-2)</script><p>因为<script type="math/tex">G(x)</script>没有常数项，所以通过上面那个<script type="math/tex">G(x)=2xG(x)+x^2G(x)+x</script>，我们可以知道<script type="math/tex">g(1)=1,g(2)=2</script>。</p>
<p>然后大力递推就好了。</p>
<p>真是妙哉，妙哉！！</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">1e6</span> + <span class="number">100</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[maxN + <span class="number">1</span>], n;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> int</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>, f[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) f[i] = (<span class="number">2</span> * f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>]) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>[BZOJ3328]PYXFIB</title>
    <url>/2020/01/09/BZOJ3328-PYXFIB/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定<script type="math/tex">n,k,p</script>且保证<script type="math/tex">k|p-1</script>，求</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{\lfloor \frac{n}{k}\rfloor}C_n^{i*k}Fib_{i*k}</script><p>其中<script type="math/tex">Fib</script>指斐波那契数列，<script type="math/tex">n\le 1e18,k\le 2e5,p\le 1e9</script>。</p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>又一次被打败了。。。</p>
<p>看这个式子形式就很不好搞，我们换一种</p>
<script type="math/tex; mode=display">
\sum_{i=0}^n[k|i]C_n^iFib_i</script><p>一般看到组合数和某个数相乘之和，首先想到二项式定理，考虑把<script type="math/tex">Fib_i</script>化成<script type="math/tex">x^i</script>的形式。</p>
<p>注意到</p>
<script type="math/tex; mode=display">
Fib_i=(A^i)_{1,1}</script><p>，其中</p>
<script type="math/tex; mode=display">
A=\left[
\begin{matrix}
1 & 1\\
1 & 0
\end{matrix}
\right]</script><p>这样，将二项式定理推广到矩阵形式，我们有</p>
<script type="math/tex; mode=display">
\sum_{i=0}^nC_n^iFib_i=(A+I)^n_{1,1},
I=
\left[
\begin{matrix}
1 & 0\\
0 & 1
\end{matrix}
\right]</script><p>然而，那个<script type="math/tex">[k|i]</script>有什么用呢？</p>
<p>如果你看了上面那篇<strong>原根及其应用</strong>，你就会明白，</p>
<script type="math/tex; mode=display">
[k|i]=\frac{1}{k}\sum_{j=0}^{k-1}w_k^{ij},w_k=g^{\frac{p-1}{k}}</script><p>这样，原式等于</p>
<script type="math/tex; mode=display">
\frac{1}{k}\sum_{i=0}^n\sum_{j=0}^{k-1}w_k^{ij}C_n^iFib_i\\
=\frac{1}{k}\sum_{j=0}^{k-1}\sum_{i=0}^{n}w_k^{ij}C_n^iFib_i\\
=\frac{1}{k}\sum_{j=0}^{k-1}(A*w_k^{j}+I)^n_{1,1}</script><p>然后直接矩阵快速幂即可。</p>
<p>复杂度<script type="math/tex">O(klogn)</script>。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line">LL mod, n, k;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LL a[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">matrix</span>() &#123; <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a)); &#125;</span><br><span class="line"> </span><br><span class="line">    matrix <span class="keyword">operator</span> * (matrix rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        matrix ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++)</span><br><span class="line">                    ans.a[i][j] = (ans.a[i][j] + a[i][k] * rhs.a[k][j] % mod) % mod;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">mpow</span><span class="params">(LL a, LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(LL g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL x = mod - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">2</span>; i * i &lt;= x; i++)</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">mpow</span>(g, (mod - <span class="number">1</span>) / i) == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(x != <span class="number">1</span> &amp;&amp; <span class="built_in">mpow</span>(g, (mod - <span class="number">1</span>) / x) == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">solve</span><span class="params">(LL w, LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    matrix a;</span><br><span class="line">    a.a[<span class="number">0</span>][<span class="number">0</span>] = w + <span class="number">1</span>, a.a[<span class="number">0</span>][<span class="number">1</span>] = w;</span><br><span class="line">    a.a[<span class="number">1</span>][<span class="number">0</span>] = w, a.a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    matrix ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) ans.a[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>) ans = ans * a;</span><br><span class="line">        a = a * a;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>, &amp;n, &amp;k, &amp;mod);</span><br><span class="line">        LL ans = <span class="number">0</span>, g = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>( !<span class="built_in">check</span>(g) ) g ++;</span><br><span class="line">        LL w = <span class="number">1</span>, wn = <span class="built_in">mpow</span>(g, (mod - <span class="number">1</span>) / k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++, w = w * wn % mod) ans = (ans + <span class="built_in">solve</span>(w, n)) % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans * <span class="built_in">mpow</span>(k, mod - <span class="number">2</span>) % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>[BZOJ2527]Meteors</title>
    <url>/2019/09/13/BZOJ2527-Meteors/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>某地有<script type="math/tex">N</script>个成员国。现在它发现了一颗新的星球，这颗星球的轨道被分为M份（第M份和第1份相邻），第i份上有第Ai个国家的太空站。<br>这个星球经常会下陨石雨。BIU已经预测了接下来K场陨石雨的情况。<br>BIU的第i个成员国希望能够收集Pi单位的陨石样本。你的任务是判断对于每个国家，它需要在第几次陨石雨之后，才能收集足够的陨石。</p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>整体二分。</p>
<p>复杂度<script type="math/tex">O(nlog^2n)</script></p>
<p>注意：中间加的时候可能会爆<strong>long long</strong>。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">3e5</span> + <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, num;</span><br><span class="line">&#125;q[maxN + <span class="number">1</span>], qr[maxN * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> C[maxN * <span class="number">4</span> + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> ans[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> L[maxN + <span class="number">1</span>], R[maxN + <span class="number">1</span>], val[maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; place[maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>( !<span class="built_in">isdigit</span>( ch ) ) &#123; <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">isdigit</span>( ch ) ) num = (num &lt;&lt; <span class="number">3ll</span>) + (num &lt;&lt; <span class="number">1ll</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> num * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (-x); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= m; i += <span class="built_in">lowbit</span>(i)) C[i] += num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &gt; <span class="number">0</span>; i -= <span class="built_in">lowbit</span>(i)) ans += C[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r || x &gt; y) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= y; i++) ans[ q[i].id ] = l;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, t1 = <span class="number">0</span>, t2 = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= mid; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L[i] &gt; R[i]) <span class="built_in">change</span>(<span class="number">1</span>, val[i]);</span><br><span class="line">        <span class="built_in">change</span>(L[i], val[i]), <span class="built_in">change</span>(R[i] + <span class="number">1</span>, -val[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= y; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[i].id, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; place[t].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            res += <span class="built_in">query</span>(place[t][j]);</span><br><span class="line">            <span class="keyword">if</span>(res &gt;= q[i].num) <span class="keyword">break</span>;<span class="comment">//就是这里</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res &gt;= q[i].num) qr[++ t1] = q[i];</span><br><span class="line">        <span class="keyword">else</span> qr[++ t2] = q[i], qr[t2].num -= res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= mid; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L[i] &gt; R[i]) <span class="built_in">change</span>(<span class="number">1</span>, -val[i]);</span><br><span class="line">        <span class="built_in">change</span>(L[i], -val[i]), <span class="built_in">change</span>(R[i] + <span class="number">1</span>, val[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= x + t1 - <span class="number">1</span>; i++) q[i] = qr[i - x + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x + t1; i &lt;= y; i++) q[i] = qr[n + i - x - t1 + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">solve</span>(l, mid, x, x + t1 - <span class="number">1</span>); <span class="built_in">solve</span>(mid + <span class="number">1</span>, r, x + t1, y); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> int</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) place[ <span class="built_in">read</span>() ].<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) q[i].id = i, q[i].num = <span class="built_in">read</span>();</span><br><span class="line">    k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) L[i] = <span class="built_in">read</span>(), R[i] = <span class="built_in">read</span>(), val[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>, k + <span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">       <span class="keyword">if</span>(ans[i] == k + <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;NIE&quot;</span>);</span><br><span class="line">       <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title>[BZOJ3028]食物</title>
    <url>/2019/07/24/BZOJ3028-%E9%A3%9F%E7%89%A9/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>要带n个物品，要求：</p>
<p>汉堡：偶数个；可乐：0/1个；鸡腿：0/1/2个；蜜桃：奇数个；</p>
<p>鸡块：4的倍数个；包子0/1/2/3个；土豆：0/1个；面包：3的倍数个。</p>
<p>求所有情况的方案数，对10007取模。</p>
<p><strong>注意：</strong><script type="math/tex">1<=n<=10^{500}</script></p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>考虑生成函数。</p>
<p>我们对每一种情况搞一个生成函数，其中<script type="math/tex">x^i</script>指选i个，前面的系数就是选<script type="math/tex">i</script>个的方案数。最后，将它们乘起来，取第<script type="math/tex">n</script>项的系数就好了。</p>
<p>还是不清楚？继续往下看：</p>
<p>对于第一个汉堡，只有偶数个才会有贡献，所以它的生成函数是</p>
<script type="math/tex; mode=display">
1+x^2+x^4+...=\frac{1}{1-x^2}</script><p>第二个可乐，只要0/1个，所以它的生成函数是</p>
<script type="math/tex; mode=display">
1+x</script><p>同理，后面的也一样，我们把所有的合在一起，分别是：</p>
<script type="math/tex; mode=display">
\frac{1}{1-x^2}\\
1+x\\
1+x+x^2\\
x+x^3+x^5+...=\frac{x}{1-x^2}\\
1+x^4+x^8+...=\frac{1}{1-x^4}\\
1+x+x^2+x^3\\
1+x\\
1+x^3+x^6+...=\frac{1}{1-x^3}</script><p>他们乘起来，等于</p>
<script type="math/tex; mode=display">
\frac{x}{(1-x)^4}</script><p>然后，我们要把这个式子转化为普通形式。怎么办？</p>
<p>原来这个式子可以写成</p>
<script type="math/tex; mode=display">
x(1+x+x^2+...)^4</script><p>前面被提出来了一个<script type="math/tex">x</script>，那么我们就要求的是后面那个东西第<script type="math/tex">n-1</script>项的系数。</p>
<p>我们考虑它的组合意义，其实，它就是一个生成函数，第<script type="math/tex">n</script>项的系数表示把<script type="math/tex">n</script>拆成4个数的方案数(可以拆成0）。那么，我们就可以用插板法解决系数了。</p>
<p>就相当于我们有n个小球，要分成3组，每组可以为空的方案数。</p>
<p>那么第<script type="math/tex">n-1</script>项的系数是<script type="math/tex">C_{n-1+4-1}^3</script>，即</p>
<script type="math/tex; mode=display">
ans=C_{n+2}^3=\frac{n(n+1)(n+2)}{6}</script><p>本题还有一个难点在于<script type="math/tex">n</script>很大，应该怎么读入呢？</p>
<p>我们可以边读入边取模，因为</p>
<script type="math/tex; mode=display">
(a+b)\bmod p=(a\bmod p)+ (b\bmod p)</script><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">500</span> + <span class="number">10</span>, mod = <span class="number">10007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n, len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">    len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">        n = (n * <span class="number">10</span> % mod + s[i] - <span class="string">&#x27;0&#x27;</span>) % mod;</span><br><span class="line">    <span class="keyword">int</span> inv = <span class="built_in">pow</span>(<span class="number">6</span>, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, n * (n + <span class="number">1</span>) % mod * (n + <span class="number">2</span>) % mod * inv % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>[BZOJ2159]Crash的文明世界</title>
    <url>/2019/03/02/BZOJ2159-Crash%E7%9A%84%E6%96%87%E6%98%8E%E4%B8%96%E7%95%8C/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定一棵树和k，求：</p>
<script type="math/tex; mode=display">
F(i)=\sum_{j=1}^ndist(i,j)^k</script><span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>这一题有一个弱化版，就是<script type="math/tex">k=1</script>，是一个非常简单的换根dp(其实我都觉得不是dp):</p>
<p><a href="https://www.luogu.org/problemnew/show/P3478">STA-Station</a></p>
<p>而且，这一题也用了那一题的思路。</p>
<p>废话少说，来看这一题：</p>
<p>先推式子。</p>
<script type="math/tex; mode=display">
\sum_{j=1}^ndist(i,j)^k=\sum_{j=1}^n\sum_{t=0}^{min(dist(i,j),k)}S(k,t)*t!*C(dist(i,j),t)</script><p>我们假设<script type="math/tex">dist(i,j)>k</script>，毕竟，k的范围要比n要小得多。</p>
<p>则原式变为：</p>
<script type="math/tex; mode=display">
\sum_{j=1}^n\sum_{t=0}^kS(k,t)*t!*C(dist(i,j),t)\\
=\sum_{t=0}^kS(k,t)*t!*\sum_{j=1}^nC(dist(i,j),t)</script><p>前面那个式子直接暴力计算，我们主要需要计算的，是</p>
<script type="math/tex; mode=display">
\sum_{j=1}^nC(dist(i,j),t)</script><p>首先我们假设1为根，然后设<script type="math/tex">f[u][t]</script>为以<script type="math/tex">u</script>为根的子树中所有节点<script type="math/tex">v</script>的<script type="math/tex">C(dist(u,v),t)</script>之和。</p>
<p>我们再设一个<script type="math/tex">g[u][t]</script>指整棵树中除了<script type="math/tex">u</script>的子树的所有节点<script type="math/tex">v</script>的<script type="math/tex">C(dist(u,v),t)</script>之和。</p>
<p>我们用<script type="math/tex">v\in u</script>表示v在u的子树里，则上面的定义可以写成：</p>
<script type="math/tex; mode=display">
f[u][t]=\sum_{v\in u}C(dist(u,v),t)\\
g[u][t]=\sum_{v\notin u}C(dist(u,v),t)</script><p>我们知道：</p>
<script type="math/tex; mode=display">
C(n,m)=C(n-1,m)+C(n-1,m-1)</script><p>所以，我们就能进行转移啦：</p>
<script type="math/tex; mode=display">
f[u][t]=\sum_{v\in u}C(dist(u,v),t)\\
=[t=0]+\sum_{v\in u,u\neq v}\sum_{w\in v}C(dist(v,w)+1,t)</script><p>为什么要加上那一个<script type="math/tex">[t=0]</script>，因为如果t=0的话，<script type="math/tex">0^0=1</script>，所以要在统计子树的同时统计自己的贡献。</p>
<p>这个可以直接特判掉：</p>
<script type="math/tex; mode=display">
f[u][0]=1+\sum_{v\in u}f[v][0]</script><p>剩下的就是<script type="math/tex">t>1</script>的情况，就不用特别地写<script type="math/tex">u\neq v</script>了：</p>
<script type="math/tex; mode=display">
\sum_{v\in u}\sum_{w\in v}C(dist(v,w)+1,t)\\
=\sum_{v\in u}\sum_{w\in v}(C(dist(v,w),t)+C(dist(v,w),t-1))\\
=\sum_{v\in u}f[v][t]+f[v][t-1]</script><p>这就好转移了。</p>
<p>但是，怎么求g呢？</p>
<script type="math/tex; mode=display">
g[u][t]=\sum_{v\notin u}C(dist(u,v),t)\\
=\sum_{v\notin pa}C(dist(pa,v)+1,t)+\sum_{v\in pa}C(dist(pa,v)+1,t)-\sum_{v\in u}C((dist(u,v)+1)+1,t)</script><p>其中，最后那个式子中的<script type="math/tex">dist(u,v)+1</script>指的是：<script type="math/tex">dist(pa,v)(v\in pa且v\in u)</script></p>
<p>所以，</p>
<script type="math/tex; mode=display">
g[u][t]=g[pa][t]+g[pa][t-1]+f[pa][t]+f[pa][t-1]-f[u][t]-2*f[u][t-1]-f[u][t-2]</script><p>然后，然后好像就好了。</p>
<p>第二类斯特林数就暴力计算就好了。</p>
<p>注意：在计算g的时候，<script type="math/tex">u==1</script>的时候无需计算，而且计算要放在循环外面，不然叶子节点就计算不到，我就因为这个一直过不去样例（丢脸）。</p>
<p><strong>PS：我的代码风格可能有较大改变，因为学习了大佬 @menci 的代码风格。</strong></p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">1e5</span> + <span class="number">100</span>, mod = <span class="number">10007</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125;edge[maxN * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S[<span class="number">200</span>][<span class="number">200</span>], n, k, fac[<span class="number">200</span>];</span><br><span class="line"><span class="keyword">int</span> tot, head[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> f[maxN + <span class="number">1</span>][<span class="number">200</span>], g[maxN + <span class="number">1</span>][<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> num * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot ++;</span><br><span class="line">    edge[tot].to = y;</span><br><span class="line">    edge[tot].next = head[x];</span><br><span class="line">    head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[u][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i; i = edge[i].next)</span><br><span class="line">       <span class="keyword">if</span>(edge[i].to != pa)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">           <span class="built_in">dfs1</span>(v, u);</span><br><span class="line">           f[u][<span class="number">0</span>] = (f[u][<span class="number">0</span>] + f[v][<span class="number">0</span>]) % mod;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) f[u][j] = (f[u][j] + f[v][j] + f[v][j - <span class="number">1</span>]) % mod;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        g[u][<span class="number">0</span>] = ((g[pa][<span class="number">0</span>] + f[pa][<span class="number">0</span>] - f[u][<span class="number">0</span>]) % mod + mod) % mod;</span><br><span class="line">        g[u][<span class="number">1</span>] = ((g[pa][<span class="number">1</span>] + g[pa][<span class="number">0</span>] + f[pa][<span class="number">1</span>] + f[pa][<span class="number">0</span>] - f[u][<span class="number">1</span>] - <span class="number">2</span> * f[u][<span class="number">0</span>]) % mod + mod) % mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= k; j++)</span><br><span class="line">            g[u][j] = ((g[pa][j] + g[pa][j - <span class="number">1</span>] + f[pa][j] + f[pa][j - <span class="number">1</span>] - f[u][j] - <span class="number">2</span> * f[u][j - <span class="number">1</span>] - f[u][j - <span class="number">2</span>]) % mod + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i; i = edge[i].next)</span><br><span class="line">       <span class="keyword">if</span>(edge[i].to != pa) <span class="built_in">dfs2</span>(edge[i].to, u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(x, y); <span class="built_in">add</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    S[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) S[i][j] = (S[i - <span class="number">1</span>][j - <span class="number">1</span>] + S[i - <span class="number">1</span>][j] * j % mod) % mod;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; j++) </span><br><span class="line">            ans = (ans + S[k][j] * fac[j] % mod * (f[i][j] + g[i][j]) % mod) % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>[BZOJ3309]DZY Loves Math</title>
    <url>/2019/03/08/BZOJ3309-DZY-Loves-Math/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>求</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\sum_{j=1}^mf(gcd(i,j))\\
其中f(n)为n质因子分解后的最高项次数</script><span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>我们设<script type="math/tex">n<=m</script>，然后又开始大力推式子了：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\sum_{j=1}^mf(gcd(i,j))\\
=\sum_{d=1}^nf(d)*\sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)=d]\\
=\sum_{d=1}^nf(d)*\sum_{i=1}^{n/d}\sum_{j=1}^{m/d}[gcd(i,j)=1]\\
=\sum_{d=1}^nf(d)*\sum_{i=1}^{n/d}\sum_{j=1}^{m/d}\sum_{p|gcd(i,j)}\mu(p)\\
=\sum_{d=1}^nf(d)*\sum_{p=1}^{n/d}\mu(p)*\lfloor\frac{n}{dp}\rfloor*\lfloor\frac{m}{dp}\rfloor\\
=\sum_{d=1}^nf(d)*\sum_{p=1,d|p}^{n}\mu(\frac{p}{d})*\lfloor\frac{n}{p}\rfloor*\lfloor\frac{m}{p}\rfloor\\
=\sum_{p=1}^n\lfloor\frac{n}{p}\rfloor*\lfloor\frac{m}{p}\rfloor*\sum_{d|p}f(d)*\mu(\frac{p}{d})</script><p>我们考虑怎么求</p>
<script type="math/tex; mode=display">
g(n)=\sum_{d|n}f(d)*\mu(\frac{n}{d})</script><p>我们设</p>
<script type="math/tex; mode=display">
n=p1^{a1}*p2^{a2}*...*pk^{ak}\\
d=p1^{b1}*p2^{b2}*...*pk^{bk}</script><p>根据<script type="math/tex">\mu</script>的性质，如果<script type="math/tex">ai-bi>=2</script>，那么<script type="math/tex">\mu</script>就是0。</p>
<p>所以，只有<script type="math/tex">ai=bi</script>或<script type="math/tex">ai=bi+1</script>。</p>
<p>这样，我们假设<script type="math/tex">max(ai)=l</script>，那么<script type="math/tex">f(d)=l或l-1</script>。</p>
<p>那么<script type="math/tex">\frac{n}{d}</script>就是这k个质数选或者不选的问题了。</p>
<p>我们有一下两个结论：</p>
<p>1.当<script type="math/tex">ai\neq aj(i\neq j)</script>时，<script type="math/tex">g(n)=0</script>。</p>
<p>我们考虑如果选了<script type="math/tex">t个=l(0<t<k)</script>的，那么，如果我们一共选了s个质数，若s为奇数，记为s1，那么答案就会加上<script type="math/tex">l\times (-1)\times C(k-t,s1-t)</script>，若s为偶数，记为s2，则答案会加上<script type="math/tex">l\times 1\times C(k-t,s2-t)</script>，而我们考虑到，<script type="math/tex">C(k,i)</script>中奇数项和等于偶数项和，所以</p>
<script type="math/tex; mode=display">
\sum_{s1=2i-1}C(k-t,s1-t)=\sum_{s2=2i}C(k-t,s2-t)</script><p>所以最终的结果加起来等于<script type="math/tex">l\times (-1)\times C(k-t,s1-t)+l\times 1\times C(k-t,s2-t)=0</script>，同理，当乘上的数是<script type="math/tex">l-1</script>时，<script type="math/tex">g(n)=0</script>，所以结论成立。</p>
<p>因此，只有当<script type="math/tex">a1=a2=...=an</script>时，才会产生贡献。</p>
<p>2.当<script type="math/tex">a1=a2=...=ak</script>时，<script type="math/tex">g(n)=(-1)^{k+1}</script>。</p>
<p>我们设<script type="math/tex">a1=a2=...=ak=rule</script>。</p>
<p>同样的，如果不考虑前面的f，选奇数个和选偶数个的答案<script type="math/tex">\mu</script>的和都是0，但是我们考虑当这k个数都选的时候，前面的<script type="math/tex">f(d)=rule-1</script>，而其他的<script type="math/tex">f</script>都是<script type="math/tex">rule</script>，所以在加的时候，相当于全部选的时候，<script type="math/tex">(rule-1)\times (-1)^k=rule\times (-1)^k+(-1)^{k+1}</script>，其中<script type="math/tex">rule\times (-1)^k</script>可以抵消掉，会多出来一个<script type="math/tex">(-1)^{k+1}</script>。</p>
<p>所以，<script type="math/tex">g(n)=(-1)^{k+1}</script>。</p>
<hr>
<p>然后，我们考虑怎么递推求g。</p>
<p>我们考虑线性筛的原理，一个数只会被自己最小的质因子筛掉。</p>
<p>在筛的时候有两种情况：</p>
<ol>
<li>i % prime[j] != 0<br>  这个时候，<script type="math/tex">prime[j]</script>和<script type="math/tex">i</script>互质，且<script type="math/tex">prime[j]</script>是<script type="math/tex">i\times prime[j]</script>的最小的质因子（线性筛的原理），<br>  因此，我们用一数组<script type="math/tex">a[i]</script>表示i中最小的质因子出现的次数，<script type="math/tex">b[i]</script>表示i中最小质因子所构成的数值。<br>  这两个都很好转移。<br>  然后，此时的<script type="math/tex">g[i\times prime[j]]</script>就看i是否有平方因子，如果有，那么<script type="math/tex">g[i \times prime[j]]</script>就是0，否则就是<script type="math/tex">g[i]</script>的相反数。<br>  即</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i % prime[j])</span><br><span class="line">&#123;</span><br><span class="line">   a[i * prime[j]] = <span class="number">1</span>; b[i * prime[j]] = prime[j];</span><br><span class="line">   g[i * prime[j]] = a[i] == <span class="number">1</span> ? -g[i] : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>i % prime[j] == 0</p>
<p>这个时候，<script type="math/tex">i</script>里面有<script type="math/tex">prime[j]</script>的因子，且<script type="math/tex">prime[j]</script>必定是<script type="math/tex">i</script>中最小的因子，这个时候，我们可以算出<script type="math/tex">i\times  prime[j]</script>里面<script type="math/tex">prime[j]</script>出现的次数和<script type="math/tex">prime[j]</script>所构成的数值，我们怎么判断<script type="math/tex">g[i \times prime[j]]</script>的值呢？我们只要看<script type="math/tex">i</script>中除去<script type="math/tex">prime[j]</script>这个因子构成的数后的数，记为<script type="math/tex">num</script>，看<script type="math/tex">a[num]</script>是否等于<script type="math/tex">a[i\times prime[j]]</script>，如果相等的话，直接<script type="math/tex">g[i\times prime[j]]=-g[num]</script>，如果<script type="math/tex">g[num]</script>等于0，那么<script type="math/tex">g[i\times prime[j]]</script>也是0，否则，就直接是其相反数。</p>
<p>特别地，如果当前这个数<script type="math/tex">n</script>仅仅是由一个质因子的幂次方组成的，那么这个数的<script type="math/tex">g[n]=1</script>（自己推一下就好了）。</p>
<p>还有一个要注意的，就是当<script type="math/tex">num</script>变成了1，而1的所有属性都没有计算，所以要额外考虑，即此时的<script type="math/tex">i\times prime[j]</script>是<script type="math/tex">prime[j]^2</script>的形式，那么，<script type="math/tex">g[i\times prime[j]]=1</script>就好了。</p>
</li>
</ol>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">1e7</span> + <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n, m, t;</span><br><span class="line"><span class="keyword">int</span> g[maxN + <span class="number">1</span>], prime[maxN + <span class="number">1</span>], tot;</span><br><span class="line"><span class="keyword">int</span> a[maxN + <span class="number">1</span>], b[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> flag[maxN + <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123; <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> num * f;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxN; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag[i]) prime[++ tot] = i, g[i] = a[i] = <span class="number">1</span>, b[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt; maxN; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            flag[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j])</span><br><span class="line">            &#123;</span><br><span class="line">                a[i * prime[j]] = <span class="number">1</span>, b[i * prime[j]] = prime[j];</span><br><span class="line">                g[i * prime[j]] = (a[i] == <span class="number">1</span>) ? -g[i] : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                a[i * prime[j]] = a[i] + <span class="number">1</span>, b[i * prime[j]] = b[i] * prime[j];</span><br><span class="line">                <span class="keyword">int</span> num = i / b[i];</span><br><span class="line">                <span class="keyword">if</span>(num == <span class="number">1</span>) g[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> g[i * prime[j]] = a[num] == a[i * prime[j]] ? -g[num] : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxN; i++) g[i] += g[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    t = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(t --)</span><br><span class="line">    &#123;</span><br><span class="line">        n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span>(n &gt; m) <span class="built_in">swap</span>(n, m);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        LL ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="built_in">min</span>(n / (n / i), m / (m / i));</span><br><span class="line">            ans += <span class="number">1ll</span> * (g[k] - g[i - <span class="number">1</span>]) * (n / i) * (m / i);</span><br><span class="line">            i = k + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>[BZOJ3881]Divljak</title>
    <url>/2020/03/29/BZOJ3881-Divljak/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定一个字符串集合<script type="math/tex">S</script>，由<script type="math/tex">s_1,s_2,..s_n</script>组成，且<script type="math/tex">\sum|s_i|\le 2e6</script>。</p>
<p>由<script type="math/tex">q</script>个询问，每次询问有两种：</p>
<ol>
<li><p>往集合<script type="math/tex">T</script>中加入一个字符串<script type="math/tex">t</script>。</p>
</li>
<li><p>询问<script type="math/tex">s_x</script>是集合<script type="math/tex">T</script>中多少个字符串的子串。</p>
</li>
</ol>
<p>保证<script type="math/tex">\sum |t|\le 2e6,n,q\le 1e5</script>。</p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>考虑到有多个字符串，所以构建<script type="math/tex">S</script>的<script type="math/tex">AC</script>自动机。</p>
<p>这个时候如果<script type="math/tex">s</script>是<script type="math/tex">t</script>的子串，那么<script type="math/tex">s</script>一定是<script type="math/tex">t</script>在<script type="math/tex">AC</script>自动机上经过的某个节点在<script type="math/tex">fail</script>树上的祖先，如果不考虑重复出现，那么我们只要把每个节点祖先全部加一即可，但是现在有它只统计串的个数，而不是出现次数，所以，我们要转化为数颜色。</p>
<p>对于每一个<script type="math/tex">t</script>，我们在<script type="math/tex">S</script>的<script type="math/tex">AC</script>自动机上跑，把所经过的节点增加一个颜色。</p>
<p>那么，我们的询问就是问<script type="math/tex">fail</script>树上某个节点子树内的颜色个数。</p>
<p>这种树上数颜色的问题经典做法是离线下来扫描线，然而这道题不能离线，所以我们只能另寻他路。</p>
<p>考虑这道题有什么特殊性质？它每次都会把同一颜色的点全部给你。</p>
<p>那么，我们能不能通过一定的树上差分，使得这些点的祖先只会被统计到一次贡献呢？</p>
<p>实际上是可以的：我们先在每个点上加上<script type="math/tex">1</script>，然后，我们将这些点按照<script type="math/tex">dfs</script>序排序，然后我们对排序后相邻两个点的<script type="math/tex">LCA</script>上<script type="math/tex">-1</script>，然后求某个点的子树和就可以知道这个点内的颜色个数。</p>
<p>为什么是对的呢？画一下图可以感性理解一下。</p>
<p>因为是按照<script type="math/tex">dfs</script>序排序，我们询问的是一个子树，所以我们的询问统计到的一定是排序后序列的一个区间。</p>
<p>这个区间内的点和相邻点的<script type="math/tex">LCA</script>一定在我们询问的子树中，有<script type="math/tex">m</script>个点，就会有<script type="math/tex">m-1</script>个<script type="math/tex">LCA</script>，所以贡献为<script type="math/tex">1</script>。而其他不在该区间的点及相关的<script type="math/tex">LCA</script>必然不会在这个子树中（否则矛盾），因此这样做就是对的。</p>
<p><strong>注意本题求<script type="math/tex">LCA</script>要用树链剖分，否则会被卡。</strong></p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AC</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fail;</span><br><span class="line">    <span class="keyword">int</span> trans[<span class="number">26</span>];</span><br><span class="line">&#125;st[maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, cnt, r;</span><br><span class="line"><span class="keyword">int</span> p[maxN + <span class="number">1</span>], t[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> dfn[maxN + <span class="number">1</span>], dep[maxN + <span class="number">1</span>], size[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> fa[maxN + <span class="number">1</span>], top[maxN + <span class="number">1</span>], wson[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> C[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">char</span> s[maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; son[maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>( !<span class="built_in">isdigit</span>( ch ) ) &#123; <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">isdigit</span>( ch ) ) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> num * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>), now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> c = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!st[now].trans[c]) st[now].trans[c] = ++ cnt;</span><br><span class="line">        now = st[now].trans[c];</span><br><span class="line">    &#125;</span><br><span class="line">    p[id] = now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_fail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(st[<span class="number">0</span>].trans[i]) q.<span class="built_in">push</span>(st[<span class="number">0</span>].trans[i]);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(st[x].trans[i]) st[ st[x].trans[i] ].fail = st[ st[x].fail ].trans[i], q.<span class="built_in">push</span>(st[x].trans[i]);</span><br><span class="line">            <span class="keyword">else</span> st[x].trans[i] = st[ st[x].fail ].trans[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[u] = pa;</span><br><span class="line">    dep[u] = dep[pa] + <span class="number">1</span>;</span><br><span class="line">    size[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; son[u].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = son[u][i];</span><br><span class="line">        <span class="built_in">dfs1</span>(v, u);</span><br><span class="line">        size[u] += size[v];</span><br><span class="line">        <span class="keyword">if</span>(!wson[u] || size[ wson[u] ] &lt; size[v]) wson[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = ++ cnt;</span><br><span class="line">    top[u] = t;</span><br><span class="line">    <span class="keyword">if</span>(wson[u]) <span class="built_in">dfs2</span>(wson[u], t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; son[u].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = son[u][i];</span><br><span class="line">        <span class="keyword">if</span>(v == wson[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[ top[x] ] &lt; dep[ top[y] ]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        x = fa[ top[x] ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &gt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= cnt; i += <span class="built_in">lowbit</span>(i)) C[i] += num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i; i ^= <span class="built_in">lowbit</span>(i)) ans += C[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> dfn[a] &lt; dfn[b]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>), now = <span class="number">0</span>;</span><br><span class="line">    t[ r = <span class="number">1</span> ] = now;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> c = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        now = st[now].trans[c];</span><br><span class="line">        t[++ r] = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(t + <span class="number">1</span>, t + r + <span class="number">1</span>, comp);</span><br><span class="line">    r = <span class="built_in">unique</span>(t + <span class="number">1</span>, t + r + <span class="number">1</span>) - t - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">change</span>(dfn[ t[i] ], <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">1</span>) <span class="built_in">change</span>(dfn[ <span class="built_in">LCA</span>(t[i - <span class="number">1</span>], t[i]) ], <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">insert</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">get_fail</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) son[ st[i].fail ].<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    q = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(q --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> op = <span class="built_in">read</span>(), x;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>), <span class="built_in">work</span>();</span><br><span class="line">        <span class="keyword">else</span> x = p[ <span class="built_in">read</span>() ], <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(dfn[x] + size[x] - <span class="number">1</span>) - <span class="built_in">query</span>(dfn[x] - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>遇到子树数颜色的问题，如果给了这个颜色的所有点，那么我们可以用按照<script type="math/tex">dfs</script>序排序的方法，使得这个颜色的点对所有祖先贡献为<script type="math/tex">1</script>，这个思想非常重要，而且巧妙，一定要加以运用。</p>
]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>[BZOJ3601]一个人的数论</title>
    <url>/2019/06/26/BZOJ3601-%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%95%B0%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>求</p>
<script type="math/tex; mode=display">
fk(n)=\sum_{i=1}^n[gcd(i,n)=1]*i^m</script><p>给出</p>
<script type="math/tex; mode=display">
n,1<=w<=1000,1<=ai,pi<=10^9\\
n=\prod_{i=1}^wpi^{ai}</script><span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>先推式子</p>
<script type="math/tex; mode=display">
fk(n)=\sum_{i=1}^ni^m*\sum_{d|gcd(i,n)}\mu(d)\\
=\sum_{d|n}\mu(d)*\sum_{i=1}^{n/d}(id)^m\\
=\sum_{d|n}\mu(d)*d^m*\sum_{i=1}^{n/d}i^m</script><p>先看后面那个是前缀m次和的形式，考虑怎么推那个东西</p>
<p>这里有一个知识点，伯努利数，如果没有学过出门右转：</p>
<p><a href="https://cmwqf.github.io/2019/06/26/%E4%BC%AF%E5%8A%AA%E5%88%A9%E6%95%B0%E7%9B%B8%E5%85%B3/#more">伯努利数相关</a></p>
<p>这样原式就可以写成</p>
<script type="math/tex; mode=display">
fk(n)=\sum_{d|n}\mu(d)*d^m*\frac{1}{m+1}*\sum_{k=0}^{m}C(m+1,k)*B_k*(\frac{n}{d})^{m+1-k}\\
设a[i]=\frac{1}{m+1}*C(m+1,m+1-i)*B_{m+1-i}\\
fk(n)=\sum_{d|n}\mu(d)*d^m*\sum_{i=1}^{m+1}a[i]*(\frac{n}{d})^i\\
=\sum_{i=1}^{m+1}a[i]*\sum_{d|n}\mu(d)*d^m*(\frac{n}{d})^i\\
=\sum_{i=1}^{m+1}a[i]*n^i*\sum_{d|n}\mu(d)*d^{m-i}\\</script><p>狄利克雷卷积有一个性质：</p>
<script type="math/tex; mode=display">
如果f,g为积性函数，则f*g也是积性函数</script><p>证明如下：</p>
<script type="math/tex; mode=display">
设h=f*g，gcd(n,m)=1(不完全积性函数)，则\\
h(n)h(m)=\sum_{d|n}f(d)*g(\frac{n}{d})\sum_{p|m}f(p)*g(\frac{m}{p})\\
=\sum_{d|n}\sum_{p|m}f(dp)*g(\frac{nm}{dp})\\
=\sum_{dp|mn}f(dp)*g(\frac{nm}{dp})\\
=h(nm)</script><p>则</p>
<script type="math/tex; mode=display">
h(n)=\sum_{d|n}\mu(d)*d^{m-i}为积性函数</script><p>所以我们只需考虑<script type="math/tex">h(p^a)</script>就可以了</p>
<script type="math/tex; mode=display">
h(p^a)=\sum_{j=0}^a\mu(p^j)*p^{jm-ij}</script><p>只有当<script type="math/tex">j=0/1</script>时才会有贡献，因此</p>
<script type="math/tex; mode=display">
h(p^a)=1-p^{m-i}</script><p>因此，</p>
<script type="math/tex; mode=display">
h(n)=(1-p_1^{m-i})*...*(1-p_w^{m-i})</script><p>即</p>
<script type="math/tex; mode=display">
ans=\sum_{i=1}^{m+1}a[i]*n^i*\prod_{j=1}^w(1-p_j^{m-i})\\
a[i]=\frac{1}{m+1}*C(m+1,m+1-i)*B_{m+1-i}</script><p>这样，就结束了。。。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fac[maxN + <span class="number">1</span>], inv[maxN + <span class="number">1</span>], B[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> w, m, n = <span class="number">1</span>, ans;</span><br><span class="line"><span class="keyword">int</span> p[maxN + <span class="number">1</span>], x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>( !<span class="built_in">isdigit</span>( ch ) ) &#123; <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">isdigit</span>( ch ) ) num = (num &lt;&lt; <span class="number">3LL</span>) + (num &lt;&lt; <span class="number">1LL</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> num * f;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fac[n] * inv[m] % mod * inv[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxN; i++) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    inv[maxN - <span class="number">1</span>] = <span class="built_in">pow</span>(fac[maxN - <span class="number">1</span>], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = maxN - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) inv[i] = inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxN; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) B[i] = (B[i] + <span class="built_in">C</span>(i + <span class="number">1</span>, j) * B[j] % mod) % mod;</span><br><span class="line">        B[i] = - B[i] * <span class="built_in">pow</span>(i + <span class="number">1</span>, mod - <span class="number">2</span>) % mod; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> int</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    m = <span class="built_in">read</span>(), w = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= w; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = <span class="built_in">read</span>(), x = <span class="built_in">read</span>();</span><br><span class="line">        n = n * <span class="built_in">pow</span>(p[i], x) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="built_in">pow</span>(m + <span class="number">1</span>, mod - <span class="number">2</span>) * <span class="built_in">C</span>(m + <span class="number">1</span>, m + <span class="number">1</span> - i) % mod * B[m + <span class="number">1</span> - i] % mod;</span><br><span class="line">        res = res * <span class="built_in">pow</span>(n, i) % mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= w; j++) res = res * (<span class="number">1</span> - <span class="built_in">pow</span>(p[j], i == m + <span class="number">1</span> ? mod - <span class="number">2</span> : m - i)) % mod;</span><br><span class="line">        ans = (ans + res) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, (ans % mod + mod) % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>[BZOJ2724]蒲公英 </title>
    <url>/2019/07/26/BZOJ2724-%E8%92%B2%E5%85%AC%E8%8B%B1/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>在线求静态区间众数。</p>
<p>给你一个长度为<script type="math/tex">n</script>的序列，每次询问<script type="math/tex">[l,r]</script>的众数是多少（如果有多个，输出最小的）。</p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>经典的分块题，但我到现在才会。。。</p>
<p>首先，我们将序列分为<script type="math/tex">block</script>块，然后我们考虑区间众数的性质：</p>
<ol>
<li>区间众数可能是第<script type="math/tex">belong[l+1]->belong[r-1]</script>的众数；</li>
<li>区间众数可能是<script type="math/tex">[l,rb[belong[l]]</script>或<script type="math/tex">[lb[belong[r]],r]</script>中的数。</li>
</ol>
<p>这个是很显然的，因为如果一个数它既不在外面出现，也不是里面块的众数，它不可能成为整个区间的众数。</p>
<p>那么，我们只要处理出这两种情况就好了。怎么办呢？</p>
<p>首先，我们把这些数离散化一下。</p>
<p>然后，我们预处理两个数组：</p>
<script type="math/tex; mode=display">
f[i][j]:从第i块到第j块的众数\\
g[i][j]:从序列开始一直到第i块数字j出现的次数</script><p>我们考虑怎么预处理第一个数组，首先枚举每一个块，然后从这个块向序列末扫一遍，然后统计一下就好了（具体可以看代码）。</p>
<p>那么第二个呢？从头到尾扫一遍，然后更新一下，就好了。</p>
<p>复杂度<script type="math/tex">O(n\sqrt{n})</script></p>
<p>然后，就没了。。。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">4e4</span> + <span class="number">100</span>, maxB = <span class="number">250</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxN + <span class="number">1</span>], block, tmp[maxN + <span class="number">1</span>], res;</span><br><span class="line"><span class="keyword">int</span> belong[maxN + <span class="number">1</span>], lb[maxN + <span class="number">1</span>], rb[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> f[maxB + <span class="number">1</span>][maxB + <span class="number">1</span>], g[maxB + <span class="number">1</span>][maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, ans;</span><br><span class="line"><span class="keyword">bool</span> flag[maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>( !<span class="built_in">isdigit</span>( ch ) ) &#123; <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">isdigit</span>( ch ) ) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> num * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= belong[n]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = lb[i]; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt[ a[j] ] ++;</span><br><span class="line">            <span class="keyword">if</span>(cnt[ a[j] ] &gt; ans || (cnt[ a[j] ] == ans &amp;&amp; a[j] &lt; res))</span><br><span class="line">                ans = cnt[ a[j] ], res = a[j];</span><br><span class="line">            f[i][ belong[j] ] = res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(belong[i] != belong[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= res; j++) g[ belong[i] ][j] = g[ belong[i - <span class="number">1</span>] ][j];</span><br><span class="line">         g[ belong[i] ][ a[i] ] ++; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g[y][num] - g[x - <span class="number">1</span>][num];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(belong[l] == belong[r])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= l; i &lt;= r; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt[ a[i] ] ++;</span><br><span class="line">            <span class="keyword">if</span>(cnt[ a[i] ] &gt; ans || (cnt[ a[i] ] == ans &amp;&amp; a[i] &lt; res))</span><br><span class="line">                ans = cnt[ a[i] ], res = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++) cnt[ a[i] ] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, res = <span class="number">0</span>, x = belong[l] + <span class="number">1</span>, y = belong[r] - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= rb[ belong[l] ]; i++) cnt[ a[i] ] ++, flag[ a[i] ] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = lb[ belong[r] ]; i &lt;= r; i++) cnt[ a[i] ] ++, flag[ a[i] ] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= rb[ belong[l] ]; i++)</span><br><span class="line">        <span class="keyword">if</span>(flag[ a[i] ])</span><br><span class="line">        &#123;</span><br><span class="line">            flag[ a[i] ] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">int</span> tmp = cnt[ a[i] ] + <span class="built_in">calc</span>(x, y, a[i]);</span><br><span class="line">            cnt[ a[i] ] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; ans || (tmp == ans &amp;&amp; a[i] &lt; res))</span><br><span class="line">                ans = tmp, res = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = lb[ belong[r] ]; i &lt;= r; i++)</span><br><span class="line">        <span class="keyword">if</span>(flag[ a[i] ])</span><br><span class="line">        &#123;</span><br><span class="line">            flag[ a[i] ] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">int</span> tmp = cnt[ a[i] ] + <span class="built_in">calc</span>(x, y, a[i]);</span><br><span class="line">            cnt[ a[i] ] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; ans || (tmp == ans &amp;&amp; a[i] &lt; res))</span><br><span class="line">                ans = tmp, res = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="built_in">calc</span>(x, y, f[x][y]);</span><br><span class="line">    <span class="keyword">if</span>(tmp &gt; ans || (tmp == ans &amp;&amp; f[x][y] &lt; res))</span><br><span class="line">        ans = tmp, res = f[x][y];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>();</span><br><span class="line">        l = (l + ans - <span class="number">1</span>) % n + <span class="number">1</span>, r = (r + ans - <span class="number">1</span>) % n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r) <span class="built_in">swap</span>(l, r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans = tmp[ <span class="built_in">query</span>(l, r) ]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    block = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = tmp[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">sort</span>(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(tmp[i] != tmp[i - <span class="number">1</span>]) tmp[++ res] = tmp[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = <span class="built_in">lower_bound</span>(tmp + <span class="number">1</span>, tmp + res + <span class="number">1</span>, a[i]) - tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) belong[i] = (i - <span class="number">1</span>) / block + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(belong[i] != belong[i - <span class="number">1</span>]) lb[ belong[i] ] = i;</span><br><span class="line">        rb[ belong[i] ] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><strong>从编译，样例到评测一遍过的题啊，激动！！</strong></p>
<p><strong>说明认真思考，想到每个细节再打代码，事半功倍。</strong></p>
]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>[BZOJ3622]已经没有什么好害怕的了</title>
    <url>/2019/08/24/BZOJ3622-%E5%B7%B2%E7%BB%8F%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%AE%B3%E6%80%95%E7%9A%84%E4%BA%86/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定两组数<script type="math/tex">a,b</script>，两两匹配，问有多少种情况使得<script type="math/tex">a_i>b_i</script>的组数比<script type="math/tex">a_i<b_i</script>的组数恰好多<script type="math/tex">k</script>个？</p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>我们先做一个小学生的变换：设有<script type="math/tex">x</script>组<script type="math/tex">a_i>b_i</script>，则</p>
<script type="math/tex; mode=display">
x-(n-x)=k\\
x=\frac{n+k}{2}</script><p>所以，问题就转化为有多少种情况使得<script type="math/tex">a_i>b_i</script>的组数恰好为<script type="math/tex">x</script>个？</p>
<p>这里要特判一下，如果<script type="math/tex">n+k</script>为奇数，直接输出<script type="math/tex">0</script>就好了。</p>
<p>思路还是很巧妙的。</p>
<p>首先，我们先把两个序列排序，以便后用。</p>
<p>我们设<script type="math/tex">f[i][j]</script>表示前<script type="math/tex">i</script>个<strong>至少</strong>有<script type="math/tex">j</script>组<script type="math/tex">a_i>b_i</script>，然后我们考虑转移。</p>
<p>因为排了序，所以我们知道比<script type="math/tex">a_i</script>小的有<script type="math/tex">k</script>个，那么前面已经选了<script type="math/tex">j</script>个比它们所对应的<script type="math/tex">a</script>小的<script type="math/tex">b</script>，而它们必然比<script type="math/tex">a_i</script>小，所以，显然贡献有一个<script type="math/tex">f[i-1][j-1]*(k-(j-1))</script>。</p>
<p>再考虑如果选比它大的有多少个。我们发现这个根本无法统计，因为我们不知道前面选了多少个比<script type="math/tex">a_i</script>大的。</p>
<p>怎么解决呢？我们先不管它，到最后再随便分配一个（后面再说）。</p>
<script type="math/tex; mode=display">
f[i][j]=f[i-1][j]+f[i-1][j-1]*(p-(j-1))</script><p>我们所需要的是<script type="math/tex">f[n][i]</script>。然而，它真的是选了至少<script type="math/tex">i</script>组的答案吗？当然不是，我们只考虑了我们钦定的<script type="math/tex">i</script>组，对于其他的我们根本就没有分配，所以，我们让<script type="math/tex">f[n][i]*(n-i)!</script>，就是剩下的<script type="math/tex">n-i</script>个随便选，这样就是至少<script type="math/tex">i</script>个了。</p>
<p>但是这样会算重复，比如说我们考虑一个恰好<script type="math/tex">k</script>组的方案，我们如果钦定了<script type="math/tex">i</script>组，剩下的随便选，那么这个方案会被统计<script type="math/tex">C(k,i)</script>次（理解一下）。</p>
<p>怎么统计答案呢？</p>
<p>我们设<script type="math/tex">g[i]</script>表示恰好<script type="math/tex">i</script>组的方案，那么我们有</p>
<script type="math/tex; mode=display">
f[i]=\sum_{j=i}^ng[j]*{j\choose i}</script><p>利用二项式反演（是个神奇的东西），可以推得：</p>
<script type="math/tex; mode=display">
g[i]=\sum_{j=i}^n(-1)^{j-i}*f[j]*{j\choose i}</script><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">2000</span> + <span class="number">100</span>, mod = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[maxN + <span class="number">1</span>][maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> ans, a[maxN + <span class="number">1</span>], b[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n, k, fac[maxN + <span class="number">1</span>], inv[maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>( !<span class="built_in">isdigit</span>( ch ) ) &#123; <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">isdigit</span>( ch ) ) num = (num &lt;&lt; <span class="number">3ll</span>) + (num &lt;&lt; <span class="number">1ll</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> num * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[n] * inv[n - m] % mod * inv[m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> int</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span>((n + k) &amp; <span class="number">1</span>) &#123; <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    k = (n + k) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) b[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(b + <span class="number">1</span>, b + n + <span class="number">1</span>);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="built_in">lower_bound</span>(b + <span class="number">1</span>, b + n + <span class="number">1</span>, a[i]) - b - <span class="number">1</span>;</span><br><span class="line">        f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            f[i][j] = (f[i - <span class="number">1</span>][j] + f[i - <span class="number">1</span>][j - <span class="number">1</span>] * <span class="built_in">max</span>(<span class="number">0ll</span>, p - (j - <span class="number">1</span>)) % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    inv[n] = <span class="built_in">fpow</span>(fac[n], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) inv[i] = inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt;= n; i++, flag = -flag) ans = (ans + flag * f[n][i] * fac[n - i] % mod * <span class="built_in">C</span>(i, k) % mod) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, (ans % mod + mod) % mod); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title>[BZOJ4036]按位或</title>
    <url>/2019/07/25/BZOJ4036-%E6%8C%89%E4%BD%8D%E6%88%96/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>刚开始你有一个数字$0$，每一秒钟你会随机选择一个$[0,2^n-1]$的数字，与你手上的数字进行或操作。选择数字<script type="math/tex">i</script>的概率是<script type="math/tex">p[i]</script>。保证<script type="math/tex">0<=p[i]<=1</script>，<script type="math/tex">\sum p[i]=1</script>问期望多少秒后，你手上的数字变成<script type="math/tex">2^n-1</script>。</p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>我们考虑<script type="math/tex">Min-max</script>容斥，题目相当于给我们一个大小为<script type="math/tex">n</script>的集合，每个元素为0/1，求这个集合全是1的期望步数，即这个集合最后一个元素变成1的期望步数，我们把它计为<script type="math/tex">max(S)</script>。</p>
<p>根据<script type="math/tex">Min-max</script>容斥</p>
<script type="math/tex; mode=display">
E(max(S))=\sum_{T\subset S}(-1)^{|T|-1}E(min(T))</script><p>那么问题就转化为如何求<script type="math/tex">E(min(T))</script>。</p>
<p>考虑<script type="math/tex">E(min(T))</script>的意思是一个集合中第一个出现1的元素的期望时间。</p>
<p>只要一个与这个集合有交的集合与它或，那么它就会出现1。</p>
<p>那么每步让集合<script type="math/tex">T</script>有一个元素变成1的概率就是(此处的<script type="math/tex">S</script>不同于上面的<script type="math/tex">S</script>)</p>
<script type="math/tex; mode=display">
P=\sum_{T\cap S}p[S]</script><p>那么，我们考虑这样一个问题，一个事件，我们每步有<script type="math/tex">P</script>的概率成功，问这个事件成功的期望步数。</p>
<p>可以看成走每步会成功<script type="math/tex">P</script>次，所以成功1次期望走<script type="math/tex">\frac{1}{P}</script>步。</p>
<p>即</p>
<script type="math/tex; mode=display">
E(min(T))=\frac{1}{\sum_{T\cap S}p[S]}</script><p>但这样貌似也不太好弄的样子，所以我们将它进行一个补集转化，变成</p>
<script type="math/tex; mode=display">
\frac{1}{1-\sum_{T\cap S=\varnothing}p[S]}</script><p>然后，我们发现，我们计集合<script type="math/tex">C</script>是<script type="math/tex">T</script>对全集的补集，那么后面那个东西实际上就是<script type="math/tex">C</script>的子集和。</p>
<p>然后我们就可以用高维前缀和或者<script type="math/tex">FWT</script>解决了。</p>
<p>还有，就是如果所有有值的<script type="math/tex">p[i]</script>的<script type="math/tex">i</script>或起来不等于<script type="math/tex">(1 << n) - 1</script>，就输出<script type="math/tex">INF</script>。</p>
<p>时间复杂度<script type="math/tex">O(2^n*n)</script>。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">2e6</span> + <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> p[maxN + <span class="number">1</span>], ans;</span><br><span class="line"><span class="keyword">int</span> n, tmp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;p[i]);</span><br><span class="line">        <span class="keyword">if</span>(p[i] &gt; <span class="number">0</span>) tmp |= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tmp != ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>)) &#123; <span class="built_in">puts</span>(<span class="string">&quot;INF&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); j++)</span><br><span class="line">            <span class="keyword">if</span>(j &amp; (<span class="number">1</span> &lt;&lt; i)) p[j] += p[j ^ (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span>(i &amp; (<span class="number">1</span> &lt;&lt; j)) tmp = -tmp;</span><br><span class="line">        ans += tmp * <span class="number">1</span> / (<span class="number">1</span> - p[ ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>) ^ i ]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.9lf&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>概率期望</tag>
        <tag>容斥原理</tag>
        <tag>多项式</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title>[BZOJ4542]大数</title>
    <url>/2019/01/25/BZOJ4542-%E5%A4%A7%E6%95%B0/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>小 B 有一个很大的数 S，长度达到了 N 位；这个数可以看成是一个串，它可能有前导 0，例如00009312345。小B还有一个素数P。现在，小 B 提出了 M 个询问，每个询问求 S 的一个子串中有多少子串是 P 的倍数（0 也是P 的倍数）。例如 S为0077时，其子串 007有6个子串：0,0,7,00,07,007；显然0077的子串007有6个子串都是素数7的倍数。</p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>根据某位大神的叙述，如果碰到统计序列的子序列的问题，要么是用扫描线，要么使用莫队；</p>
<p>首先，我们考虑用<script type="math/tex">num[i]</script>表示<script type="math/tex">[i,n]</script>的数，则如果一个子序列<script type="math/tex">[l,r]</script>是<script type="math/tex">p</script>的倍数，则必有</p>
<script type="math/tex; mode=display">
\frac{num[l]-num[r+1]}{10^{n-r}}\equiv 0 (mod \quad p)</script><p>即</p>
<script type="math/tex; mode=display">
num[l]-num[r+1]\equiv0(mod \quad p)</script><script type="math/tex; mode=display">
num[l]\equiv num[r+1](mod\quad p)</script><p>所以，我们不妨设<script type="math/tex">num[i]=num[i]%p</script>，这样我们只需要统计在<script type="math/tex">[l,r]</script>这个区间中</p>
<script type="math/tex; mode=display">
num[i]==num[j](i,j\in[l,r],i\ne j)</script><p>的个数就可以了；</p>
<p>我们把取模过后的<script type="math/tex">num</script>离散化一下，这样，记<script type="math/tex">cnt[x]</script>为<script type="math/tex">num[i]==x</script>的个数，就可以在莫队的时候转移了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;ans+=cnt[x]; cnt[x]++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;ans-=cnt[x]<span class="number">-1</span>; cnt[x]--;&#125;</span><br></pre></td></tr></table></figure>
<p>为什么<script type="math/tex">ans-=cnt[x]-1</script>呢？因为当时把这个即将要删除的数<script type="math/tex">x</script>加入的时候，<script type="math/tex">ans</script>加上的是目前的<script type="math/tex">cnt[x]-1</script>,所以减的时候，就要和原来一样，减去<script type="math/tex">cnt[x]-1</script>；</p>
<p>这就很简单了，就是一个裸的莫队了；</p>
<p>难道结束了吗？ naive！！</p>
<p>这个时候兴致勃勃地提交上去，你就会获得95分的好成绩，多么优（抠）秀（脚）的算法！为什么呢？</p>
<p>我们的同余方程中，把那个分母去掉的条件是<script type="math/tex">(p,10)==1</script>，然而，问题来了，如果<script type="math/tex">p==2</script>或<script type="math/tex">5</script>怎么办呢？</p>
<p>特判！！</p>
<p>我们抛开前面所有的东西，重新回到起点，可以发现，<script type="math/tex">2</script>和<script type="math/tex">5</script>的倍数很有特点，就是这个数最后一位如果是<script type="math/tex">2</script>或<script type="math/tex">5</script>的倍数，那么整个这个数便就是<script type="math/tex">2</script>或<script type="math/tex">5</script>的倍数；我们采用前缀和的思想：</p>
<p>我们用<script type="math/tex">pre[i]</script>记录<script type="math/tex">[1,i]</script>中是<script type="math/tex">p</script>的倍数的子序列有多少个，<script type="math/tex">sum[i]</script>记录<script type="math/tex">[1,i]</script>中有多少个数（单独的数字）是<script type="math/tex">p</script>的倍数，<script type="math/tex">pre</script>和<script type="math/tex">sum</script>也很好转移；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pre[i]=pre[i<span class="number">-1</span>],sum[i]=sum[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>((ch[i]-<span class="string">&#x27;0&#x27;</span>)%p==<span class="number">0</span>) pre[i]+=i,sum[i]++;</span><br></pre></td></tr></table></figure>
<p>这样，我们就可以直接计算出<script type="math/tex">[l,r]</script>中的<script type="math/tex">p</script>的倍数的子序列：</p>
<script type="math/tex; mode=display">
ans=pre[r]-pre[l-1]-(sum[r]-sum[l-1])\times(l-1);</script><p>为什么呢？</p>
<p>首先，<script type="math/tex">pre[r]</script>是以<script type="math/tex">[1,r]</script>中<script type="math/tex">p</script>的倍数的子序列个数，减去<script type="math/tex">pre[l]</script>剔除了<script type="math/tex">[1,l]</script>中<script type="math/tex">p</script>的倍数的子序列个数，但是，这并没有去除完，因为</p>
<script type="math/tex; mode=display">
数[l,r](l\in[1,l-1],r\in [l,r])还没有被排除掉</script><p>所以，我们必须把这些也给排除，这些有多少个呢？就是有</p>
<script type="math/tex; mode=display">
(sum[r]-sum[l-1])\times(l-1)</script><p>至此，应该说的已经够详细的了，还有什么不懂的，可以看看代码（溜了）。</p>
<p>对了，还要开<strong>long long​</strong>！</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN=<span class="number">1e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,id;</span><br><span class="line">&#125;q[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,id;</span><br><span class="line">&#125;temp[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> num[maxN+<span class="number">1</span>],p,tot;</span><br><span class="line"><span class="keyword">int</span> n,m,belong[maxN+<span class="number">1</span>],block;</span><br><span class="line"><span class="keyword">int</span> ans,cnt[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> res[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">char</span> ch[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) num=(num&lt;&lt;<span class="number">3</span>)+(num&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> num*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(S a,S b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(Node a,Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> belong[a.l] ^ belong[b.l] ? belong[a.l]&lt;belong[b.l] : belong[a.l]&amp;<span class="number">1</span> ? a.r&lt;b.r : a.r&gt;b.r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;ans-=cnt[x]<span class="number">-1</span>; cnt[x]--;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;ans+=cnt[x]; cnt[x]++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=q[<span class="number">1</span>].l;i&lt;=q[<span class="number">1</span>].r;i++) <span class="built_in">add</span>(num[i]);</span><br><span class="line">    l=q[<span class="number">1</span>].l,r=q[<span class="number">1</span>].r; res[q[<span class="number">1</span>].id]=ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;q[i].l) <span class="built_in">del</span>(num[l++]);</span><br><span class="line">        <span class="keyword">while</span>(l&gt;q[i].l) <span class="built_in">add</span>(num[--l]);</span><br><span class="line">        <span class="keyword">while</span>(r&gt;q[i].r) <span class="built_in">del</span>(num[r--]);</span><br><span class="line">        <span class="keyword">while</span>(r&lt;q[i].r) <span class="built_in">add</span>(num[++r]);</span><br><span class="line">        res[q[i].id]=ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum[maxN+<span class="number">1</span>],pre[maxN+<span class="number">1</span>];<span class="comment">//pre[i]:[1,i]有多少个序列是p的倍数，sum[i]:[1,i]有几个数%p==0 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[i]=pre[i<span class="number">-1</span>]; sum[i]=sum[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>((ch[i]-<span class="string">&#x27;0&#x27;</span>)%p==<span class="number">0</span>) pre[i]+=i,sum[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="built_in">read</span>(),r=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,pre[r]-pre[l<span class="number">-1</span>]-(sum[r]-sum[l<span class="number">-1</span>])*(l<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> int</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p=<span class="built_in">read</span>(); <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ch+<span class="number">1</span>); m=<span class="built_in">read</span>();</span><br><span class="line">    n=<span class="built_in">strlen</span>(ch+<span class="number">1</span>); block=n/<span class="built_in">sqrt</span>(m*<span class="number">2</span>/<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">2</span>||p==<span class="number">5</span>) &#123;<span class="built_in">work2</span>(); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n,tmp=<span class="number">1</span>;i&gt;=<span class="number">1</span>;i--,tmp=tmp*<span class="number">10</span>%p) temp[i].x=((ch[i]-<span class="string">&#x27;0&#x27;</span>)*tmp%p+temp[i+<span class="number">1</span>].x)%p,temp[i].id=i;</span><br><span class="line">    <span class="built_in">sort</span>(temp+<span class="number">1</span>,temp+n+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(temp[i].x!=temp[i<span class="number">-1</span>].x) tot++;</span><br><span class="line">        num[temp[i].id]=tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) belong[i]=(i<span class="number">-1</span>)/block+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) q[i].l=<span class="built_in">read</span>(),q[i].r=<span class="built_in">read</span>()+<span class="number">1</span>,q[i].id=i;</span><br><span class="line">    <span class="built_in">sort</span>(q+<span class="number">1</span>,q+m+<span class="number">1</span>,comp);</span><br><span class="line">    <span class="built_in">work1</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>[BZOJ1010]玩具装箱</title>
    <url>/2019/07/23/BZOJ1010-%E7%8E%A9%E5%85%B7%E8%A3%85%E7%AE%B1/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>把一个长度为n(<script type="math/tex">1<=n<=50000</script>)的序列分为若干段，每段[i~j]的费用是</p>
<script type="math/tex; mode=display">
(j-i-L+\sum_{k=i}^jC[k])^2</script><p>求最小费用是多少？</p>
<span id="more"></span>
<h1 id="一般的方法"><a href="#一般的方法" class="headerlink" title="一般的方法"></a>一般的方法</h1><p>对于一个式子</p>
<script type="math/tex; mode=display">
f[i]=f[j]+...</script><p>我们把这个式子分组，写成<script type="math/tex">f[i]=a[i]\times b[j]+c[j]+</script>（一个只与i有关的常数）。</p>
<p>设<script type="math/tex">a[i]</script>表示一个只与<script type="math/tex">i</script>有关的数。</p>
<p>然后，我们移项，写成<script type="math/tex">-a[i]\times b[j]+f[i]=c[j]</script>。</p>
<p>这就是一个<script type="math/tex">y=kx+b</script>的形式啦。</p>
<p>这样，我们把<script type="math/tex">-a[i]</script>看成斜率<script type="math/tex">k</script>，<script type="math/tex">f[i]</script>看成截距<script type="math/tex">b</script>，那么问题就转化为，我们已知这条直线的斜率为<script type="math/tex">k</script>，还有很多个点<script type="math/tex">(b[j],c[j])</script>，我们要找出一个点，它构成的直线截距最小。</p>
<p>然后就可以用单调队列了。</p>
<h1 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h1><p>首先，很显然，我们能想出一个暴力dp</p>
<script type="math/tex; mode=display">
f[i]=min(f[i],f[j]+(i-j-1+sum[i]-sum[j]-L)^2)</script><p>但这是一个<script type="math/tex">O(n^2)</script>的，显然不符合条件。</p>
<p>可以看到，后面的通过组合可以形成关于<script type="math/tex">i,j</script>的一个相同形式：<script type="math/tex">i+sum[i]</script>和<script type="math/tex">j+sum[j]</script>。于是，我们计<script type="math/tex">s[i]=i+sum[i]</script>，再把<script type="math/tex">L++</script>，则原式可以写成</p>
<script type="math/tex; mode=display">
f[i]=f[j]+(s[i]-s[j]-L)^2\\
f[i]=f[j]+s[i]^2+s[j]^2+L^2-2*s[i]*s[j]-2*s[i]*L+2*s[j]*L</script><p>我们考虑刚刚所说的方法：</p>
<script type="math/tex; mode=display">
2*s[i]*s[j]+f[i]=f[j]+s[j]^2+2*s[j]*L+(s[i]-L)^2</script><p>因为后面那个<script type="math/tex">(s[i]-L)^2</script>是个常数，我们暂且不管它，最后加上就好了。</p>
<p>那么，对于每一个<script type="math/tex">j</script>，都是一个固定的点<script type="math/tex">(s[j],f[j]+s[j]^2+2\times s[j]\times L)</script>。</p>
<p>这样，<script type="math/tex">2\times s[i]</script>就是斜率<script type="math/tex">k</script>了。</p>
<p>我们可以发现，随着<script type="math/tex">i</script>的增长，<script type="math/tex">k</script>也是递增的且恒大于0。</p>
<p>我们考虑对于横坐标递增的两个点<script type="math/tex">A(x1,y1)</script>和<script type="math/tex">B(x2,y2)</script>，必然有<script type="math/tex">x1<=x2，y1<=y2</script>。</p>
<p>如果<script type="math/tex">B</script>比<script type="math/tex">A</script>更优的话，当且仅当</p>
<script type="math/tex; mode=display">
y2-k*x2<y1-k*x1\\
y2-y1<k*(x2-x1)\\
\frac{y2-y1}{x2-x1}<k</script><p>也就是说，如果这两个点所构成的直线的斜率小于<script type="math/tex">k</script>，那么<script type="math/tex">A</script>点就可以直接舍弃了，因为后面的<script type="math/tex">k</script>递增，永远都不可能用到<script type="math/tex">A</script>点了。</p>
<p>我们每次选择队里的第一个点来更新。为什么呢？</p>
<p>首先，可以证明，队里的每一个点与它后面的那一个组成的直线的斜率一定是它和队里它后面所有点组成的直线的斜率中最小的那一个，所以如果一个点比它后面那一个点更优，根据传递性，它一定比它后面所有的点更优。</p>
<p>假如我们有这样一条直线<script type="math/tex">AB</script>满足条件，而且<script type="math/tex">A,B</script>是队里前后相邻的两个点。则有：</p>
<script type="math/tex; mode=display">
\frac{yb-ya}{xb-xa}>k\\
ya-k*xa<yb-k*xb</script><p>所以，我们选<script type="math/tex">A</script>必然比选<script type="math/tex">B</script>更优。</p>
<p>所以，队头的那个点一定是最优解。</p>
<p>这样，我们可以确定单调队列里是按照斜率从小到大来排列的。</p>
<p>我们考虑新加入一个点，从队尾开始不断比较，如果它的斜率小于对尾的斜率，就不断弹出来，就好了。</p>
<p>复杂度<script type="math/tex">O(n)</script>。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">1e5</span> + <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s[maxN + <span class="number">1</span>], n, L;</span><br><span class="line"><span class="keyword">int</span> q[maxN + <span class="number">1</span>], head, tail;</span><br><span class="line"><span class="keyword">int</span> f[maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>( !<span class="built_in">isdigit</span>( ch ) ) &#123; <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">isdigit</span>( ch ) ) num = (num &lt;&lt; <span class="number">3ll</span>) + (num &lt;&lt; <span class="number">1ll</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> num * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">X</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> s[i]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Y</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> f[i] + s[i] * s[i] + <span class="number">2</span> * s[i] * L; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">Y</span>(b) - <span class="built_in">Y</span>(a)) / (<span class="built_in">X</span>(b) - <span class="built_in">X</span>(a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> int</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), L = <span class="built_in">read</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s[i] = s[i - <span class="number">1</span>] + <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s[i] += i; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(head &lt; tail &amp;&amp; <span class="built_in">calc</span>(q[head], q[head + <span class="number">1</span>]) &lt; <span class="number">2</span> * s[i]) head ++;</span><br><span class="line">        <span class="keyword">int</span> j = q[head];</span><br><span class="line">        f[i] = f[j] + (s[i] - s[j] - L) * (s[i] - s[j] - L);</span><br><span class="line">        <span class="keyword">while</span>(head &lt; tail &amp;&amp; <span class="built_in">calc</span>(q[tail - <span class="number">1</span>], q[tail]) &gt; <span class="built_in">calc</span>(q[tail], i)) tail --;</span><br><span class="line">        q[++ tail] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title>[BZOJ3994]约数个数和</title>
    <url>/2019/02/21/BZOJ3994-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>求</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\sum_{j=1}^md(ij)\\
d(n)指的是n的约数个数</script><span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先，我们要知道这个式子，不然整个题目就无从下手：</p>
<script type="math/tex; mode=display">
d(ij)=\sum_{x|i}\sum_{y|j}[gcd(x,y)==1]</script><p>证明如下：</p>
<script type="math/tex; mode=display">
若i=p_1^{a_1}*p_2^{a_2}...,j=p_1^{b_1}p_2^{b_2}...则ij=p_1^{a_1+b_1}p_2^{a_2+b_2}...\\
如果x|i,y|j,且gcd(x,y)==1。x=p_1^{c_1}*p_2^{c_2}...,y=p_1^{d_1}*p_2^{d_2}...\\
对于一个p_t,x中c_t和y中d_t必有一个为0。\\
如果c_t=0,则d_t有b_t+1种取值，反过来，如果d_t=0,则c_t有a_t+1种可能性，\\
也就是说，对于一个p_t,\\
有a_t+b_t+2-1=a_t+b_t+1种可能(减1是去掉两个都是0的情况)\\
如此，共有\prod_{i}(a_i+b_i+1)中可能，而ij的约数个数和也恰好等于这个式子。\\
证毕。</script><p>有了这个式子以后，我们就开始大力推式子了。</p>
<p> 原式可以变成：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\sum_{j=1}^m\sum_{x|i}\sum_{y|j}[gcd(x,y)==1]\\
\sum_{i=1}^n\sum_{j=1}^m\sum_{x|i}\sum_{y|j}\sum_{d|gcd(x,y)}\mu(d)\\</script><p>我们换成枚举x,y:</p>
<script type="math/tex; mode=display">
\sum_{x=1}^n\sum_{y=1}^m\lfloor\frac{n}{x}\rfloor \lfloor\frac{m}{y}\rfloor*\sum_{d|gcd(x,y)}\mu(d)\\
\sum_{d=1}^n\mu(d)*\sum_{x=1}^n\sum_{y=1}^m\lfloor\frac{n}{x}\rfloor \lfloor\frac{m}{y}\rfloor*[d|gcd(x,y)]</script><p>我们改为枚举x,y是d的多少倍，这样就可以去掉那个后面整除的东西了：</p>
<script type="math/tex; mode=display">
\sum_{d=1}^n\mu(d)*\sum_{x=1}^{n/d}\sum_{y=1}^{m/d}\lfloor\frac{n}{dx}\rfloor \lfloor\frac{m}{dy}\rfloor\\
\sum_{d=1}^n\mu(d)*(\sum_{x=1}^{n/d}\lfloor\frac{n}{dx}\rfloor)(\sum_{y=1}^{m/d} \lfloor\frac{m}{dy}\rfloor)\\</script><p>这样，我们预处理出</p>
<script type="math/tex; mode=display">
1.\sum_{i=1}^n\mu(i)\\
2.\sum_{i=1}^{n}\lfloor\frac{n}{i}\rfloor</script><p>然后就可以在<script type="math/tex">O(T\sqrt{n})</script>的时间内完成计算。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN=<span class="number">5e4</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxN+<span class="number">1</span>],sum[maxN+<span class="number">1</span>],t,n,m;</span><br><span class="line"><span class="keyword">int</span> mu[maxN+<span class="number">1</span>],prime[maxN+<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">bool</span> flag[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) num=(num&lt;&lt;<span class="number">3</span>)+(num&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> num*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> maxT)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxT;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag[i]) prime[++tot]=i,mu[i]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot&amp;&amp;i*prime[j]&lt;=maxT;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            flag[prime[j]*i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]) mu[i*prime[j]]=-mu[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxT;i++) sum[i]=sum[i<span class="number">-1</span>]+mu[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">1</span>;n&lt;=maxT;n++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=n/i,k=n/j;</span><br><span class="line">            ans+=(k-i+<span class="number">1</span>)*j;</span><br><span class="line">            i=k+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f[n]=ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> int</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">50000</span>);</span><br><span class="line">    t=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&gt;m) <span class="built_in">swap</span>(n,m);</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=<span class="built_in">min</span>(n/(n/i),m/(m/i));</span><br><span class="line">            ans+=(sum[j]-sum[i<span class="number">-1</span>])*f[n/i]*f[m/i];</span><br><span class="line">            i=j+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>[BZOJ3027]Sweet</title>
    <url>/2019/07/25/BZOJ3027-Sweet/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有<script type="math/tex">n</script>种糖果，每种有<script type="math/tex">m_i</script>个，求一共吃<script type="math/tex">a->b</script>个糖果的方案数之和（对2004取模）。</p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>考虑生成函数，对于每种糖果，它的生成函数是</p>
<script type="math/tex; mode=display">
1+x+x^2+...+x^{m_i}=\frac{1-x^{m_i+1}}{1-x}</script><p>所有的乘起来，再变换一下，就是</p>
<script type="math/tex; mode=display">
(1+x+x^2+...)^n\prod_{i=1}^n(1-x^{m_i+1})</script><p>我们要求的，就是这个式子<script type="math/tex">x</script>次数为<script type="math/tex">a->b</script>的前面的系数之和。</p>
<p>怎么办呢？我们发现，后面那个式子最多只有<script type="math/tex">2^n</script>项，所以我们可以暴力展开，<script type="math/tex">dfs</script>枚举每一项。</p>
<p>注意前面那个式子<script type="math/tex">x^i</script>前面的系数是<script type="math/tex">C_{i+n-1}^{n-1}</script></p>
<p>假设我们现在枚举到了<script type="math/tex">t*x^k</script>，那么这一项对答案的贡献就是：</p>
<script type="math/tex; mode=display">
t*(C_{a-k+n-1}^{n-1}+...+C_{b-k+n-1}^{n-1})</script><p>我们知道</p>
<script type="math/tex; mode=display">
C_{n-1}^{n-1}+...+C_{i+n-1}^{n-1}=C_{i+n}^n</script><p>所以对答案的贡献可以写成</p>
<script type="math/tex; mode=display">
t*(C_{b-k+n}^n-C_{a-k+n-1}^n)</script><p>那么，问题来了，因为2004是个合数，所以可能不存在逆元，那么我们怎么算后面这个东西呢？</p>
<p>我们考虑暴力计算<script type="math/tex">(n-m+1)*...*n</script>，这样，我们就剩下要除以一个<script type="math/tex">n!</script>了。</p>
<p>首先，前面那个式子一定有<script type="math/tex">n!</script>这个因子，设为<script type="math/tex">(k*mod+r)*n!</script>，那么答案应该就是<script type="math/tex">r</script>，现在因为我们不能直接除以<script type="math/tex">n!</script>，所以我们改为将它模<script type="math/tex">mod*n!</script>。</p>
<p>这样，我们算出来的答案就是<script type="math/tex">r*n!</script>，然后我们再除以<script type="math/tex">n!</script>就好了。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">500</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m[maxN + <span class="number">1</span>], mod = <span class="number">2004</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">1</span>, ans;</span><br><span class="line"><span class="keyword">int</span> n, a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - m + <span class="number">1</span>; i &lt;= n; i++) ans = ans * i % mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> lim, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lim &gt; b) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += num * ( <span class="built_in">C</span>(b - lim + n, n) - <span class="built_in">C</span>(a - lim + n - <span class="number">1</span>, n) ) % mod;</span><br><span class="line">        ans %= mod;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(x + <span class="number">1</span>, lim, num);</span><br><span class="line">    <span class="built_in">dfs</span>(x + <span class="number">1</span>, lim + m[x] + <span class="number">1</span>, -num);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> int</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>, &amp;n, &amp;a, &amp;b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;m[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) tmp *= i;</span><br><span class="line">    mod *= tmp;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    ans /= tmp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, (ans % <span class="number">2004</span> + <span class="number">2004</span>) % <span class="number">2004</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>[BZOJ4555]求和</title>
    <url>/2019/02/28/BZOJ4555-%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>求</p>
<script type="math/tex; mode=display">
\sum_{i=0}^n\sum_{j=0}^iS(i,j)*2^j*(j!)</script><span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>其实我觉得，就第一步最难想：</p>
<p>因为当<script type="math/tex">i<j</script>时，<script type="math/tex">S(i,j)</script>必然是0，所以原式可以写成：</p>
<script type="math/tex; mode=display">
\sum_{i=0}^n\sum_{j=0}^nS(i,j)*2^j*(j!)</script><p>然后，我们交换求和号：</p>
<script type="math/tex; mode=display">
\sum_{j=0}^n2^j*(j!)*\sum_{i=0}^nS(i,j)</script><p>我们考虑如何化简<script type="math/tex">S(i,j)</script>：</p>
<script type="math/tex; mode=display">
\sum_{i=0}^nS(i,j)=\sum_{i=0}^n\sum_{k=0}^j(-1)^k*C(j,k)*(j-k)^i*\frac{1}{j!}\\
=\sum_{i=0}^n\sum_{k=0}^j\frac{(-1)^k}{k!}*\frac{(j-k)^i}{(j-k)!}\\
=\sum_{k=0}^j\frac{(-1)^k}{k!}*\frac{\sum_{i=0}^n(j-k)^i}{(j-k)!}</script><p>很明显地，这就是一个卷积的形式了：</p>
<p>我们设：</p>
<script type="math/tex; mode=display">
f(i)=\frac{(-1)^i}{i!}\\
g(i)=\frac{\sum_{k=0}^ni^k}{i!}=\frac{i^{n+1}-1}{i!*(i-1)}</script><p>后面那个式子，就通过一个等比数列求和就好了。</p>
<p>然后答案就是在求：</p>
<script type="math/tex; mode=display">
ans=\sum_{j=0}^n2^j*(j!)*(f*g)(j)</script><p>然后。。就好了。</p>
<p>有一些要注意的细节：</p>
<p>求g的时候，我们发现当<script type="math/tex">i=0时,g[i]=1;i=1时g[i]=n+1</script>，而这两项，用公式是算不出来的，所以要加一个特判。</p>
<p>然后，好像就没什么了。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN=<span class="number">1e6</span> + <span class="number">100</span>,mod=<span class="number">998244353</span>,G=<span class="number">3</span>,Gi=<span class="number">332748118</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxN+<span class="number">1</span>],g[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> lim,cnt,r[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> inv[maxN+<span class="number">1</span>],fac[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x&amp;<span class="number">1</span>) ans=ans*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++)</span><br><span class="line">       <span class="keyword">if</span>(i&lt;r[i]) <span class="built_in">swap</span>(a[i],a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid=<span class="number">1</span>;mid&lt;lim;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> wn=<span class="built_in">pow</span>(type==<span class="number">1</span> ? G : Gi,(mod<span class="number">-1</span>)/(mid&lt;&lt;<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i+=(mid&lt;&lt;<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> w=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;mid;j++,w=w*wn%mod)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x=a[i+j],y=w*a[i+mid+j]%mod;</span><br><span class="line">                a[i+j]=(x+y)%mod; a[i+mid+j]=((x-y)%mod+mod)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> int</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    inv[n]=<span class="built_in">pow</span>(fac[n],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) inv[i]=inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) f[i]=(i&amp;<span class="number">1</span>) ? -inv[i] : inv[i];</span><br><span class="line">    g[<span class="number">0</span>]=<span class="number">1</span>; g[<span class="number">1</span>]=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) g[i]=(<span class="built_in">pow</span>(i,n+<span class="number">1</span>)<span class="number">-1</span>)*inv[i]%mod*<span class="built_in">pow</span>(i<span class="number">-1</span>,mod<span class="number">-2</span>)%mod;</span><br><span class="line">    </span><br><span class="line">    lim=<span class="number">1</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(lim&lt;=(n*<span class="number">2</span>+<span class="number">2</span>)) lim&lt;&lt;=<span class="number">1</span>,cnt++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++) r[i]=(r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>) | ((i&amp;<span class="number">1</span>) &lt;&lt; cnt<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">NTT</span>(f,<span class="number">1</span>); <span class="built_in">NTT</span>(g,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++) f[i]=f[i]*g[i]%mod;</span><br><span class="line">    <span class="built_in">NTT</span>(f,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> tmp=<span class="built_in">pow</span>(lim,mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++) f[i]=f[i]*tmp%mod;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,t=<span class="number">1</span>;i&lt;=n;i++,t=t*<span class="number">2</span>%mod) ans=(ans+t*fac[i]%mod*f[i]%mod)%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>[BZOJ5093]图的价值</title>
    <url>/2019/02/26/BZOJ5093-%E5%9B%BE%E7%9A%84%E4%BB%B7%E5%80%BC/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>“简单无向图”是指无重边、无自环的无向图（不一定连通）。</p>
<p>一个带标号的图的价值定义为每个点度数的k次方的和。</p>
<p>给定n和k，请计算所有n个点的带标号的简单无向图的价值之和。</p>
<p>因为答案很大，请对998244353取模输出。</p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>很容易地，我们可以推出这么一个式子：</p>
<script type="math/tex; mode=display">
ans=n*2^{C(n-1,2)}*\sum_{i=0}^{n-1}C(n-1,i)*i^k</script><p>这个式子的意思就是，我们枚举每一个点向外连的度数，假如度数是<script type="math/tex">i</script>,就一共有<script type="math/tex">C(n-1,i)</script>种它连接外面的方案，而另外<script type="math/tex">n-1</script>个点可以随便练，然后再乘上一个自己的贡献，就是：</p>
<script type="math/tex; mode=display">
ans=n*\sum_{i=0}^{n-1}C(n-1,i)*2^{C(n-1,2)}*i^k=n*2^{C(n-1,2)}*\sum_{i=0}^{n-1}C(n-1,i)*i^k</script><p>主要，我们要计算的，就是</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{n-1}C(n-1,i)*i^k</script><p>根据第二类斯特林数，这个式子可以变形为：</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{n-1}C(n-1,i)*\sum_{j=0}^iS(k,j)*j!*C(i,j)\\
=\sum_{j=0}^{n-1}S(k,j)*j!*\sum_{i=j}^{n-1}C(n-1,i)*C(i,j)\\</script><p>众所周知，</p>
<script type="math/tex; mode=display">
C(n-1,i)*C(i,j)=C(n-1,j)*C(n-1-j,i-j)</script><p>所以，式子变成了</p>
<script type="math/tex; mode=display">
\sum_{j=0}^{n-1}S(k,j)*j!*\sum_{i=j}^{n-1}C(n-1,j)*C(n-1-j,i-j)\\
=\sum_{j=0}^{n-1}S(k,j)*j!*C(n-1,j)*\sum_{i=j}^{n-1}C(n-1-j,i-j)\\
=\sum_{j=0}^{n-1}S(k,j)*j!*C(n-1,j)*\sum_{i=0}^{n-j-1}C(n-j-1,i)\\
=\sum_{j=0}^{n-1}S(k,j)*j!*C(n-1,j)*2^{n-j-1}</script><p>所以，</p>
<script type="math/tex; mode=display">
ans=n*2^{C(n-1,2)}*\sum_{i=0}^{n-1}S(k,i)*i!*C(n-1,i)*2^{n-i-1}\\
=n*2^{C(n-1,2)}*\sum_{i=0}^{min(n-1,k)}S(k,i)*i!*C(n-1,i)*2^{n-i-1}</script><p>我们用<script type="math/tex">NTT</script>求出<script type="math/tex">S</script>，然后再搞一搞就好了。</p>
<script type="math/tex; mode=display">NTT$$求$$S$$：</script><p>S(n,m)=\sum_{i=0}^m\frac{(-1)^i}{i!}*\frac{(m-i)^n}{(m-i)!}</p>
<p>$$</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">998244353</span>,maxN=<span class="number">1e6</span> + <span class="number">100</span>,g=<span class="number">3</span>,gi=<span class="number">332748118</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">int</span> S[maxN+<span class="number">1</span>],T[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> fac[maxN+<span class="number">1</span>],inv[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> lim,cnt,r[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> C[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x&amp;<span class="number">1</span>) ans=ans*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++)</span><br><span class="line">       <span class="keyword">if</span>(i&lt;r[i]) <span class="built_in">swap</span>(a[i],a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid=<span class="number">1</span>;mid&lt;lim;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> wn=<span class="built_in">pow</span>(type==<span class="number">1</span> ? g : gi,(mod<span class="number">-1</span>)/(mid&lt;&lt;<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i+=(mid&lt;&lt;<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> w=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;mid;j++,w=w*wn%mod)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x=a[i+j],y=w*a[i+mid+j]%mod;</span><br><span class="line">                a[i+j]=(x+y)%mod; a[i+mid+j]=((x-y)%mod+mod)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="built_in">min</span>(n<span class="number">-1</span>,k);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=S[i]*fac[i]%mod*C[i]%mod*<span class="built_in">pow</span>(<span class="number">2</span>,n-i<span class="number">-1</span>)%mod;</span><br><span class="line">        ans=(ans+tmp)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=ans*n%mod*<span class="built_in">pow</span>(<span class="number">2</span>,(n<span class="number">-1</span>)*(n<span class="number">-2</span>)/<span class="number">2</span>)%mod,</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> int</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    inv[k]=<span class="built_in">pow</span>(fac[k],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) inv[i]=inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">    C[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) C[i]=C[i<span class="number">-1</span>]*(n-i)%mod*<span class="built_in">pow</span>(i,mod<span class="number">-2</span>)%mod;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++) S[i]=(i&amp;<span class="number">1</span>) ? -inv[i] : inv[i],T[i]=<span class="built_in">pow</span>(i,k)*inv[i]%mod;</span><br><span class="line">    lim=<span class="number">1</span>;cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(lim&lt;=(<span class="number">2</span>*k)) lim&lt;&lt;=<span class="number">1</span>,cnt++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++) r[i]=(r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>) | ((i&amp;<span class="number">1</span>)&lt;&lt; cnt<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">NTT</span>(S,<span class="number">1</span>); <span class="built_in">NTT</span>(T,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++) S[i]=S[i]*T[i]%mod;</span><br><span class="line">    <span class="built_in">NTT</span>(S,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> tmp=<span class="built_in">pow</span>(lim,mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++) S[i]=S[i]*tmp%mod;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>[BZOJ5414]归程</title>
    <url>/2019/03/05/BZOJ5415-%E5%BD%92%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>本题的故事发生在魔力之都，在这里我们将为你介绍一些必要的设定。 魔力之都可以抽象成一个 n 个节点、m 条边的无向连通图（节点的编号从 1 至 n）。我们依次用 l,a 描述一条边的长度、海拔。 作为季风气候的代表城市，魔力之都时常有雨水相伴，因此道路积水总是不可避免 的。由于整个城市的排水系统连通，因此有积水的边一定是海拔相对最低的一些边。我们用水位线来描述降雨的程度，它的意义是：所有海拔不超过水位线的边都是有积水的。</p>
<p>Yazid 是一名来自魔力之都的OIer，刚参加完ION2018 的他将踏上归程，回到他 温暖的家。 Yazid 的家恰好在魔力之都的 1 号节点。对于接下来 Q 天，每一天Yazid 都会告诉你他的出发点 v ，以及当天的水位线p。 每一天，Yazid 在出发点都拥有一辆车。这辆车由于一些故障不能经过有积水的边。 Yazid 可以在任意节点下车，这样接下来他就可以步行经过有积水的边。但车会被留在他下车的节点并不会再被使用。 需要特殊说明的是，第二天车会被重置，这意味着：</p>
<p>1、车会在新的出发点被准备好。<br>2、Yazid 不能利用之前在某处停放的车。 </p>
<p>Yazid 非常讨厌在雨天步行，因此他希望在完成回家这一目标的同时，最小化他步行经过的边的总长度。请你帮助 Yazid 进行计算。</p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>我们考虑，对于每一个起始点<script type="math/tex">u</script>和水位<script type="math/tex">rule</script>，我们记<script type="math/tex">dis[i]</script>为1-&gt;i的最短路，那么，我们要求的，就是u所能到达的所有的点<script type="math/tex">v</script>中<script type="math/tex">dis[v]</script>的最小值。</p>
<p>这个时候，我们考虑Kruskal重构树，我们按照从大到小的顺序排边，这样在重构树中任意一个节点的祖先的权值必然小于这个节点，所以，我们只要倍增查找<script type="math/tex">u</script>所能到达的深度最浅的祖先<script type="math/tex">pa</script>，那么，<script type="math/tex">pa</script>的子树中的所有节点的海拔必然大于<script type="math/tex">rule</script>，这时，我们只要找这个<script type="math/tex">pa</script>的子树中所有叶子节点<script type="math/tex">dis</script>的最小值（因为所有叶子结点对应的才是图上的节点）就可以了。</p>
<p>怎么求这个最小值呢？我们可以dfs求<script type="math/tex">ans[i]</script>（就是以<script type="math/tex">i</script>为根的子树中所有叶子节点的最小值），很简单，直接在所有孩子的<script type="math/tex">ans</script>中取<script type="math/tex">min</script>就好了。</p>
<p>其实，如果知道了<script type="math/tex">Kruskal</script>重构树，这一题就是一道裸题，还是挺简单的。。。</p>
<p>如果你还不会<script type="math/tex">Kruskal</script>重构树，请看这一篇：<a href="https://cmwqf.github.io/2019/03/04/%E6%B5%85%E8%B0%88%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E9%87%8D%E6%9E%84%E6%A0%91/">浅谈Kruskal重构树</a></p>
<p><strong>PS:这一题好像还卡SPFA，我的一位学长就是因为这个与银牌擦肩而过qwq</strong></p>
<p><strong>所以，SPFA已经死了。。</strong></p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">4e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> LL inf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, value, next;</span><br><span class="line">&#125;edge[maxN * <span class="number">2</span> + <span class="number">1</span>], E[maxN * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, dis;</span><br><span class="line">    <span class="built_in">S</span>(<span class="keyword">int</span> X = <span class="number">0</span>, <span class="keyword">int</span> D = <span class="number">0</span>) &#123;x = X; dis = D; &#125; </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (S rhs) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dis &gt; rhs.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">int</span> n, m, tot, head[maxN + <span class="number">1</span>];</span><br><span class="line">LL dis[maxN + <span class="number">1</span>], ans[maxN + <span class="number">1</span>];;</span><br><span class="line"><span class="keyword">int</span> q, k, s, val[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> fa[maxN + <span class="number">1</span>][<span class="number">20</span>], dep[maxN + <span class="number">1</span>], lg[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> pa[maxN + <span class="number">1</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123; <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> num * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">    tot = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(E, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(E));</span><br><span class="line">    <span class="built_in">memset</span>(fa, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(fa));</span><br><span class="line">    <span class="built_in">memset</span>(val, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(val));</span><br><span class="line">    <span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dep));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++ tot] = (Node) &#123;x, y, t, head[x]&#125;; head[x] = tot;</span><br><span class="line">    edge[++ tot] = (Node) &#123;y, x, t, head[y]&#125;; head[y] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxN; i++) dis[i] = inf;</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;S&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>( <span class="built_in">S</span>(<span class="number">1</span>, <span class="number">0</span>) );</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        S now = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(now.dis != dis[ now.x ]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> x = now.x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].next)</span><br><span class="line">           <span class="keyword">if</span>(dis[x] + edge[i].value &lt; dis[ edge[i].to ])</span><br><span class="line">           &#123;</span><br><span class="line">               dis[ edge[i].to ] = dis[x] + edge[i].value;</span><br><span class="line">               q.<span class="built_in">push</span>( <span class="built_in">S</span>(edge[i].to, dis[ edge[i].to ]) );</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(Node a, Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.value &gt; b.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> pa[x] == x ? x : pa[x] = <span class="built_in">find</span>(pa[x]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[x] = dep[pa] + <span class="number">1</span>;</span><br><span class="line">    fa[x][<span class="number">0</span>] = pa;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= dep[x]; i++) fa[x][i] = fa[ fa[x][i - <span class="number">1</span>] ][i - <span class="number">1</span>];</span><br><span class="line">    ans[x] = dis[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].next)</span><br><span class="line">       <span class="keyword">if</span>(edge[i].to != pa) </span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">dfs</span>(edge[i].to, x);</span><br><span class="line">           ans[x] = <span class="built_in">min</span>(ans[x], ans[ edge[i].to ]);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> rule)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = lg[ dep[x] ]; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">       <span class="keyword">if</span>(val[ fa[x][i] ] &gt; rule) x = fa[x][i];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>(), l = <span class="built_in">read</span>(), a = <span class="built_in">read</span>();</span><br><span class="line">            E[i].from = x, E[i].to = y, E[i].value = a;</span><br><span class="line">            <span class="built_in">add</span>(x, y, l);</span><br><span class="line">        &#125;</span><br><span class="line">        q = <span class="built_in">read</span>(), k = <span class="built_in">read</span>(), s = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">Dijkstra</span>();</span><br><span class="line">        <span class="built_in">sort</span>(E + <span class="number">1</span>, E + m + <span class="number">1</span>, comp);</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(head)); tot = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) pa[i] = i;</span><br><span class="line">        cnt = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = E[i].from, v = E[i].to;</span><br><span class="line">            u = <span class="built_in">find</span>(u), v = <span class="built_in">find</span>(v);</span><br><span class="line">            <span class="keyword">if</span>(u == v) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> node = ++cnt;</span><br><span class="line">            pa[u] = pa[v] = pa[node] = node;</span><br><span class="line">            val[node] = E[i].value;</span><br><span class="line">            <span class="built_in">add</span>(u, node, <span class="number">0</span>); <span class="built_in">add</span>(node, v, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) lg[i] = lg[i - <span class="number">1</span>] + ((<span class="number">1</span> &lt;&lt; lg[i - <span class="number">1</span>]) == i);</span><br><span class="line">        <span class="built_in">dfs</span>(cnt, <span class="number">0</span>);</span><br><span class="line">        LL lastans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(q --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = (<span class="built_in">read</span>() + k * lastans - <span class="number">1</span>) % n + <span class="number">1</span>, rule = (<span class="built_in">read</span>() + k * lastans) % (s + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, lastans = ans[ <span class="built_in">query</span>(u, rule) ]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>Kruskal重构树</tag>
      </tags>
  </entry>
  <entry>
    <title>[BZOJ4762]最小集合</title>
    <url>/2020/02/21/BZOJ4762-%E6%9C%80%E5%B0%8F%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>定义一个非空集合是合法的，当且仅当它满足以下两个条件。<br>1、集合内所有元素<script type="math/tex">and</script>和为<script type="math/tex">0</script><br>2、它的非空子集中仅有它本身满足<script type="math/tex">1</script><br>给出一个集合<script type="math/tex">S</script>，求它的合法非空子集数。</p>
<p>其中<script type="math/tex">n\le 1000,a_i<1024</script></p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>真是一道神仙题！</p>
<p>首先，由于<script type="math/tex">and</script>不太好操作，我们把所有运算转化成<script type="math/tex">or</script>运算。</p>
<p>我们把所有的数取反（<script type="math/tex">\oplus 1023</script>)，那么，条件<script type="math/tex">1</script>：<script type="math/tex">and</script>和为<script type="math/tex">0</script>等价于新的数<script type="math/tex">or</script>起来等于<script type="math/tex">1023</script>。</p>
<p>而第二个条件，我们把转化一下，条件相当于对于一个满足条件<script type="math/tex">1</script>的集合<script type="math/tex">S</script>，不能存在<script type="math/tex">a\in S</script>，使得<script type="math/tex">S</script>去掉<script type="math/tex">a</script>后仍然满足条件<script type="math/tex">1</script>，也等价于对于<script type="math/tex">S</script>中任何一个元素，都不能有它的前缀和后缀（不包括它）或起来等于<script type="math/tex">1023</script>。</p>
<p>我们考虑<script type="math/tex">dp</script>，但是直接<script type="math/tex">dp</script>显然无法算出满足条件<script type="math/tex">2</script>的<script type="math/tex">S</script>。</p>
<p>我们考虑我们要统计什么样的集合数量？</p>
<p>如果一个集合，存在一个数<script type="math/tex">a</script>，使得它前缀和后缀或起来（不包括它）和整个集合或起来的数相等，那么我们必然不能统计这个集合。</p>
<p>因为，即使后面加一些数使得它满足条件<script type="math/tex">1</script>，那么我们将这个集合去掉<script type="math/tex">a</script>，并不改变整个集合或起来的值，不满足条件<script type="math/tex">2</script>。所以，我们考虑统计所有集合满足<strong>不存在一个数，使得去掉它以后集合的值不改变（即前缀和后缀或起来的值等于带上它或起来的值）。</strong></p>
<p>这个怎么<script type="math/tex">dp</script>呢？我们<script type="math/tex">dp</script>到每一个数，考虑带不带上加入这个数的某个集合，我们不仅要知道当前选的数或出来的值，设为<script type="math/tex">s</script>，还要知道后面选的或出来的值，设为<script type="math/tex">t</script>，我们每次要判断是否有：</p>
<script type="math/tex; mode=display">
s\quad or\quad t=s\quad or\quad x\quad or\quad  t</script><p>如果有，我们就不能统计这个集合，否则，我们就统计。</p>
<p>一个很显然的想法是记<script type="math/tex">f[i][s][t]</script>表示我们考虑了前<script type="math/tex">i</script>个数的选择，我们已经选的数或起来是<script type="math/tex">s</script>，我们希望后面选的数或起来是<script type="math/tex">t</script>，在此前提下，满足条件的集合数。</p>
<p>一个很<script type="math/tex">naive</script>的转移就是枚举<script type="math/tex">t</script>的所有子集<script type="math/tex">k</script>，如果满足<script type="math/tex">k|x=t</script>且<script type="math/tex">k|x|s\neq k|s</script>，就加上贡献。</p>
<p>先不说这个算法的时间复杂度，实际上，这个算法是错误的！</p>
<p>为什么呢？考虑你如果有一个集合，你会在多个<script type="math/tex">t</script>中算上贡献，如果你原本转移到的一些<script type="math/tex">t</script>再往后转移到同一个<script type="math/tex">t'</script>，那么<script type="math/tex">t'</script>会加上多个这个集合的贡献，换句话说，这个集合被算了多次，会被算重！</p>
<p>怎么办呢？</p>
<p>我们考虑这种方法的缺陷在于一个集合的贡献被加到很多状态中，导致算重，能不能只加到一个状态中呢？</p>
<p>我们发现，所有满足<script type="math/tex">k|x=t</script>的状态<script type="math/tex">k</script>都是某个集合的超集！为什么呢？考虑某一位，如果<script type="math/tex">t</script>中是<script type="math/tex">1</script>，<script type="math/tex">x</script>中是<script type="math/tex">1</script>，那么<script type="math/tex">k</script>中这一位可以是<script type="math/tex">0</script>也可以是<script type="math/tex">1</script>，如果<script type="math/tex">t</script>中是<script type="math/tex">1</script>，<script type="math/tex">x</script>中是<script type="math/tex">0</script>，那么<script type="math/tex">k</script>中这一位必然是<script type="math/tex">1</script>。所以，所有满足<script type="math/tex">k|x=t</script>的状态<script type="math/tex">k</script>一定是<script type="math/tex">t</script> ^ (<script type="math/tex">t</script> &amp; <script type="math/tex">x</script>)的超集。</p>
<p>我们还发现，所有满足<script type="math/tex">k|x=t</script>且<script type="math/tex">k|x|s=k|s</script>的状态<script type="math/tex">k</script>也是某个集合的超集！首先这个集合一定是<script type="math/tex">t</script>^(<script type="math/tex">t</script>&amp;<script type="math/tex">x</script>)的超集，然后考虑某一位，如果<script type="math/tex">s</script>中是<script type="math/tex">0</script>，<script type="math/tex">x</script>中是<script type="math/tex">1</script>，那么<script type="math/tex">k</script>中必然是<script type="math/tex">1</script>，其他位<script type="math/tex">k</script>既可以是<script type="math/tex">0</script>，也可以是<script type="math/tex">1</script>，也就是说，这些状态都是(<script type="math/tex">t</script> ^ (<script type="math/tex">t</script> &amp; <script type="math/tex">x</script>)) | (<script type="math/tex">x</script> ^ (<script type="math/tex">x</script> &amp; <script type="math/tex">s</script>))的超集！</p>
<p>我们设第一种“某个集合”为<script type="math/tex">k1</script>，第二种设为<script type="math/tex">k2</script>。</p>
<p>那么，我们把贡献都加到<script type="math/tex">k1</script>上，然后再在<script type="math/tex">k2</script>上把减掉，就满足每个集合贡献一次了。</p>
<p>然后考虑原本所有<script type="math/tex">k</script>能更新到的后面的状态也是某个集合的超集，而且那个集合一定都能被<script type="math/tex">k1,k2</script>更新到（考虑<script type="math/tex">k1,k2</script>的式子可以知道），所以，这样就完美解决了算重的问题，而且还减少了转移的时间复杂度！</p>
<p>所以，我们换一种<script type="math/tex">dp</script>状态，设<script type="math/tex">f[i][s][t]</script>表示我们处理完了前<script type="math/tex">i</script>个数，已经选择的集合或起来是<script type="math/tex">s</script>，我们希望后面选的集合包含<script type="math/tex">t</script>（是<script type="math/tex">t</script>的超集）的满足条件的集合数。</p>
<p>那么，我们每次</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">f[i][s | x][ t ^ (t &amp; x) ] += f[i][s][t];</span><br><span class="line">f[i][s | x][ (t ^ (t &amp; x)) | (x ^ (x &amp; s)) ] -= f[i][s][t];</span><br></pre></td></tr></table></figure>
<p>即可。</p>
<p>推到现在，我们考虑时间复杂度为<script type="math/tex">O(4^{10}n)</script>，仍然无法通过此题！</p>
<p><del>真令人头大！</del></p>
<p>考虑优化这个<script type="math/tex">dp</script>。</p>
<p>方法一：我会打表找规律！</p>
<p>没错，打表可以发现，如果<script type="math/tex">f[i][s][t]</script>有值，必然有<script type="math/tex">t</script>是<script type="math/tex">s</script>的子集。</p>
<p>方法二：开动人类智慧！</p>
<p>为什么这个结论是对的呢？</p>
<p>我们用归纳法证明：</p>
<p>首先初始时<script type="math/tex">f[0][0][0]=1</script>显然满足条件。</p>
<p>假设<script type="math/tex">f[i-1][s][t]</script>的所有状态满足结论，则有<script type="math/tex">t</script>是<script type="math/tex">s</script>的子集，那么我们观察转移式子，假设转移到<script type="math/tex">f[i][s'][t']</script>。</p>
<p>我们发现第一个转移式，<script type="math/tex">t'</script>只会成为<script type="math/tex">t</script>的子集，而<script type="math/tex">s'=s|x</script>只会越来越大，所以更加满足条件。</p>
<p>第二个转移式，<script type="math/tex">t'</script>是<script type="math/tex">t</script>的子集或上<script type="math/tex">x</script>的子集，<script type="math/tex">t</script>的子集显然是<script type="math/tex">s</script>的子集，那更是<script type="math/tex">s|x</script>的子集，而<script type="math/tex">x</script>的子集也是<script type="math/tex">s|x</script>的子集，也满足<script type="math/tex">t'</script>是<script type="math/tex">s'</script>的子集。</p>
<p>所以，我们每次只要枚举<script type="math/tex">s</script>的子集就行了。</p>
<p>所以时间复杂度<script type="math/tex">O(3^mn)</script>可以通过此题，空间复杂度上，第一维显然可以滚动数组滚掉，所以空间复杂度也没有问题。</p>
<p>对了，最后输出就是<script type="math/tex">f[n][1023][0]</script>，理解一下状态的意义就能知道了！</p>
<p>至此，这道题就完美解决了！真是一道奥妙重重的题！</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n, x;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>][<span class="number">1</span> &lt;&lt; <span class="number">11</span>][<span class="number">1</span> &lt;&lt; <span class="number">11</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ADD</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y &gt;= mod ? x + y - mod : x + y; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">SUB</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x - y &lt; <span class="number">0</span> ? x - y + mod : x - y; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    f[now][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        now ^= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        x ^= <span class="number">1023</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; <span class="number">10</span>); s++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t = s; ; t = (t - <span class="number">1</span>) &amp; s)</span><br><span class="line">            &#123;</span><br><span class="line">                f[now][s][t] = f[now ^ <span class="number">1</span>][s][t];</span><br><span class="line">                <span class="keyword">if</span>(!t) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; <span class="number">10</span>); s++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t = s; ; t = (t - <span class="number">1</span>) &amp; s)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> &amp;a = f[now][s | x][t ^ (t &amp; x)], &amp;b = f[now][s | x][(t ^ (t &amp; x)) | (x ^ (x &amp; s))];</span><br><span class="line">                a = <span class="built_in">ADD</span>(a, f[now ^ <span class="number">1</span>][s][t]); b = <span class="built_in">SUB</span>(b, f[now ^ <span class="number">1</span>][s][t]);</span><br><span class="line">                <span class="keyword">if</span>(!t) <span class="keyword">break</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[now][<span class="number">1023</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>K-D Tree进阶</title>
    <url>/2019/02/04/K-D-Tree%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h1 id="新的KD-Tree写法"><a href="#新的KD-Tree写法" class="headerlink" title="新的KD-Tree写法"></a>新的KD-Tree写法</h1><p>最近做了一些题目后，发现之前写的模板不好记，且难以用于矩形数点（可能使我太弱了），但是，我在zzq等大佬的博客中找到了另一种写法，这里以二维的写法为标准（因为我发现大部分题目都是在二维上进行操作）：</p>
<span id="more"></span>
<h2 id="节点的存储"><a href="#节点的存储" class="headerlink" title="节点的存储"></a>节点的存储</h2><p>这种写法，tree节点存的是</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KD</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;<span class="comment">//左右子树</span></span><br><span class="line">&#125;tree[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">2</span>];</span><br><span class="line">&#125;lu[maxN+<span class="number">1</span>],rd[maxN+<span class="number">1</span>],cur[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="comment">//lu:当前这个节点所管辖的矩形的左上角，ru:当前这个节点所管的矩形的右下角</span></span><br><span class="line"><span class="comment">//cur:当前这个节点所代表的点</span></span><br></pre></td></tr></table></figure>
<p>具体来说，lu.x就是它所管的所有点x的最小值，lu.y就是y的最小值，而rd是最大值；</p>
<p>为什么要记录它所管的矩形呢？</p>
<p>这样，我们在矩形数点的时候，我们就可以像线段树一样查看此矩形是否在所查询的矩形之内，而在求平面k近点时，好像并没有什么特别的用处，但是在求平面k远点的时候，可以根据要查询的点到此矩形四个顶点的距离来剪枝，计算先从哪个地方出发。</p>
<h2 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h2><p>关于建树，我们可以用动态开点，来记录每一个节点的l和r。</p>
<p>一般题目都是二维上做文章，所以我们无需通过找方差来建树，可以直接以一层横线，一层竖线来划分，即</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">build</span>(l,mid<span class="number">-1</span>,d^<span class="number">1</span>); <span class="built_in">build</span>(mid+<span class="number">1</span>,r,d^<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样好写，效果也达到了。</p>
<p>我们在nth_element过后，要记录当前树的节点是哪个点，并且记录左子树和右子树，最后要更新一下节点，计算它的lu,rd的值，如果是矩形数点的话，还要更新tree[node]中的num值。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,node=++cnt;</span><br><span class="line">    now=flag;</span><br><span class="line">    <span class="built_in">nth_element</span>(a+l,a+mid,a+r+<span class="number">1</span>,comp);</span><br><span class="line">    lu[node]=rd[node]=cur[node]=a[mid];</span><br><span class="line">    tree[node].num=<span class="number">1ll</span>*a[mid].value;</span><br><span class="line">    tree[node].l=<span class="built_in">build</span>(l,mid<span class="number">-1</span>,flag^<span class="number">1</span>);</span><br><span class="line">    tree[node].r=<span class="built_in">build</span>(mid+<span class="number">1</span>,r,flag^<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">pushup</span>(node);</span><br><span class="line">    <span class="keyword">return</span> node; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="矩形数点"><a href="#矩形数点" class="headerlink" title="矩形数点"></a>矩形数点</h3><p>我们来讲一讲矩形数点时的查询：</p>
<p>1.我们要看这个节点所代表的矩形是否在要查询的矩形之外，如果完全在外面，就直接返回；</p>
<p>2.我们要看这个节点所代表的矩形是否全部被包含在要查询的矩形之内，如果完全被包含，直接统计答案，返回；</p>
<p>3.我们要看这个节点所代表的点是否在矩形内（因为再往左右子树找是不包含此点的），如果是，统计答案，但是<strong>不能返回</strong>；</p>
<p>4.往左右两个子树查找。</p>
<p>至于是否包含这类，就通过比较要查询的矩形x,y和当前矩形的lu,rd就可以了，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">fullout</span><span class="params">(<span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;K;i++) <span class="keyword">if</span>(mx.p[i]&lt;lu[node].p[i]||rd[node].p[i]&lt;mn.p[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">fullin</span><span class="params">(<span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;K;i++) <span class="keyword">if</span>(!(mx.p[i]&gt;=rd[node].p[i]&amp;&amp;mn.p[i]&lt;=lu[node].p[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">pointin</span><span class="params">(<span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;K;i++) <span class="keyword">if</span>(!(cur[node].p[i]&lt;=mx.p[i]&amp;&amp;cur[node].p[i]&gt;=mn.p[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fullout</span>(node)) <span class="keyword">return</span>;<span class="comment">//全部在外 </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fullin</span>(node)) &#123;ans+=tree[node].num; <span class="keyword">return</span>;&#125;<span class="comment">//全部在内 </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pointin</span>(node)) ans+=cur[node].value;<span class="comment">//单点在内 </span></span><br><span class="line">    <span class="built_in">query</span>(tree[node].l); <span class="built_in">query</span>(tree[node].r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最近点"><a href="#最近点" class="headerlink" title="最近点"></a>最近点</h3><p>下面给出二维k-d树寻找距离点P最近的点：</p>
<p>1.设定初始答案ans=inf</p>
<p>2.从根节点开始，先用根代表的节点更新答案，由于左右儿子都可能存在最近点，我们优先选择距离P最近的矩形递归查询</p>
<p>3.以P为圆心，ans为半径画圆，若与之前未递归的矩形相交，就再往那查询；</p>
<p>具体做法与上一篇<a href="https://cmwqf.github.io/2019/02/03/%E6%B5%85%E8%B0%88K-D-Tree/">浅谈K-D Tree</a>相近，就不给出代码了</p>
<h3 id="k远点"><a href="#k远点" class="headerlink" title="k远点"></a>k远点</h3><p>我们维护一个小根堆，初始向里面放入k个-inf，然后之前与ans比较就变成了与对顶比较了。</p>
<p>（先留个坑，代码以后再写）</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>对，K-D Tree还能插入，但是插入之后，复杂度便不能保证了，但是插入还是很既简单的，就是比较K-D Tree与当前节点在d维度上的值，来决定到底是往左还是往右，但是要记得更新当前节点。</p>
<p>（代码也以后再补吧）</p>
<h2 id="模板-amp-例题"><a href="#模板-amp-例题" class="headerlink" title="模板&amp;例题"></a>模板&amp;例题</h2><p><a href="https://www.luogu.org/problemnew/show/P3755">CQOI2017老C的任务</a></p>
<p>是一道省选题，出题人应该不想让K-D Tree过掉，但是我开了O2还是水过去了。</p>
<p>最后一次提交是把O2去掉之后的结果。。。</p>
<p>就是一个矩形数点的模板题，代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls tree[node].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs tree[node].r</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN=<span class="number">1e5</span> + <span class="number">100</span>,K=<span class="number">2</span>,inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">2</span>],value;</span><br><span class="line">&#125;a[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KD</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> num;</span><br><span class="line">&#125;tree[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,now,cnt;</span><br><span class="line"><span class="keyword">int</span> root;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line">Node lu[maxN+<span class="number">1</span>],rd[maxN+<span class="number">1</span>],cur[maxN+<span class="number">1</span>];</span><br><span class="line">Node mn,mx;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) num=(num&lt;&lt;<span class="number">3</span>)+(num&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> num*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(Node a,Node b)</span> </span>&#123;<span class="keyword">return</span> a.p[now]&lt;b.p[now];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[node].num+=tree[ls].num+tree[rs].num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;K;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        lu[node].p[i]=<span class="built_in">min</span>(lu[node].p[i],<span class="built_in">min</span>(lu[ls].p[i],lu[rs].p[i]));</span><br><span class="line">        rd[node].p[i]=<span class="built_in">max</span>(rd[node].p[i],<span class="built_in">max</span>(rd[ls].p[i],rd[rs].p[i]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,node=++cnt;</span><br><span class="line">    now=flag;</span><br><span class="line">    <span class="built_in">nth_element</span>(a+l,a+mid,a+r+<span class="number">1</span>,comp);</span><br><span class="line">    lu[node]=rd[node]=cur[node]=a[mid];</span><br><span class="line">    tree[node].num=<span class="number">1ll</span>*a[mid].value;</span><br><span class="line">    tree[node].l=<span class="built_in">build</span>(l,mid<span class="number">-1</span>,flag^<span class="number">1</span>);</span><br><span class="line">    tree[node].r=<span class="built_in">build</span>(mid+<span class="number">1</span>,r,flag^<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">pushup</span>(node);</span><br><span class="line">    <span class="keyword">return</span> node; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">fullout</span><span class="params">(<span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;K;i++) <span class="keyword">if</span>(mx.p[i]&lt;lu[node].p[i]||rd[node].p[i]&lt;mn.p[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">fullin</span><span class="params">(<span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;K;i++) <span class="keyword">if</span>(!(mx.p[i]&gt;=rd[node].p[i]&amp;&amp;mn.p[i]&lt;=lu[node].p[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">pointin</span><span class="params">(<span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;K;i++) <span class="keyword">if</span>(!(cur[node].p[i]&lt;=mx.p[i]&amp;&amp;cur[node].p[i]&gt;=mn.p[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fullout</span>(node)) <span class="keyword">return</span>;<span class="comment">//全部在外 </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fullin</span>(node)) &#123;ans+=tree[node].num; <span class="keyword">return</span>;&#125;<span class="comment">//全部在内 </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pointin</span>(node)) ans+=cur[node].value;<span class="comment">//单点在内 </span></span><br><span class="line">    <span class="built_in">query</span>(tree[node].l); <span class="built_in">query</span>(tree[node].r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        a[i].p[<span class="number">0</span>]=<span class="built_in">read</span>(),a[i].p[<span class="number">1</span>]=<span class="built_in">read</span>(),a[i].value=<span class="built_in">read</span>();</span><br><span class="line">    lu[<span class="number">0</span>].p[<span class="number">0</span>]=lu[<span class="number">0</span>].p[<span class="number">1</span>]=inf; rd[<span class="number">0</span>].p[<span class="number">0</span>]=rd[<span class="number">0</span>].p[<span class="number">1</span>]=-inf;</span><br><span class="line">    root=<span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        mn.p[<span class="number">0</span>]=<span class="built_in">read</span>(),mn.p[<span class="number">1</span>]=<span class="built_in">read</span>(),mx.p[<span class="number">0</span>]=<span class="built_in">read</span>(),mx.p[<span class="number">1</span>]=<span class="built_in">read</span>();</span><br><span class="line">        ans=<span class="number">0</span>; <span class="built_in">query</span>(root);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>K-D Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>[LOJ3120]珍珠</title>
    <url>/2020/03/19/LOJ3120-%E7%8F%8D%E7%8F%A0/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有一个<script type="math/tex">n</script>个数的序列，每个数取值在<script type="math/tex">[1,D]</script>之间，问有多少种可能的序列使得相同的数有至少<script type="math/tex">m</script>对（一个数只能出现在一对里面）。</p>
<p>其中<script type="math/tex">D\le 1e5,n,m\le 1e9</script></p>
<p><strong>本题来源于CTS2019。</strong></p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>我们假设不考虑顺序，设第<script type="math/tex">c</script>种数有<script type="math/tex">cnt[c]</script>个，那么题目相当于</p>
<script type="math/tex; mode=display">
\sum_{i=1}^D\lfloor\frac{cnt[i]}{2}\rfloor\ge m\\
\sum_{i=1}^D\frac{cnt[i]-cnt[i]\%2}{2}\ge m\\
\sum_{i=1}^Dcnt[i]-\sum_{i=1}^Dcnt[i]\% 2\ge 2m\\
\sum_{i=1}^Dcnt[i]\%2\le n - 2m</script><p>那么实际上我们要求有多少种<script type="math/tex">cnt[i]</script>的取值使得<script type="math/tex">\sum cnt[i]\% 2\le n-2m</script>，每种方案贡献为</p>
<script type="math/tex; mode=display">
\frac{1}{\prod_{i=1}^Dcnt[i]!}</script><p>，最后再乘上<script type="math/tex">n!</script>就是答案。</p>
<p>这个显然是指数型生成函数的模型，那么，我们构造指数型生成函数。</p>
<p>因为只有<script type="math/tex">cnt[i]</script>为奇数时才与限制有关，所以我们可以把分为两种：奇数与偶数。</p>
<p>设<script type="math/tex">A(x)=x+\frac{x^3}{3!}+\frac{x^5}{5!}+...=\frac{e^x-e^{-x}}{2}</script>，<script type="math/tex">B(x)=1+\frac{x^2}{2!}+\frac{x^4}{4!}+...=\frac{e^x+e^{-x}}{2}</script>。</p>
<p>那么我们要做的就是对于每一个<script type="math/tex">k\le n-2m</script>，将<script type="math/tex">\binom{D}{k}A^k(x)B^{D-k}(x)</script>第<script type="math/tex">n</script>项累加，乘上<script type="math/tex">n!</script>即可。</p>
<p>但问题来了，因为<script type="math/tex">A</script>和<script type="math/tex">B</script>形式都不好看（都有两项），如果暴力二项式定理展开无从下手（听说也能做？）。</p>
<p>根据套路，如果其中一个变成<script type="math/tex">e^{tx}</script>的形式，往下推的时候更顺利。</p>
<p>那么，怎么办呢？如果我们把其中一个变成<script type="math/tex">e^{tx}</script>相当于那一部分要随便选，所以我们考虑容斥。</p>
<p>我们设<script type="math/tex">f[k]</script>为我们钦定<script type="math/tex">k</script>个颜色为奇数，剩下的随便选的方案数，设<script type="math/tex">g[k]</script>为恰好<script type="math/tex">k</script>个颜色为奇数的方案数，那么我们有</p>
<script type="math/tex; mode=display">
f[k]=\sum_{i=k}^D\binom{i}{k}g[i]</script><p>根据二项式反演，我们有</p>
<script type="math/tex; mode=display">
g[k]=\sum_{i=k}^D(-1)^{i-k}\binom{i}{k}f[i]</script><p>这个东西显然可以卷积算，请读者自行推导（其实是我不想推了）。</p>
<p>那么，我们的问题变为如何求<script type="math/tex">f[k]</script>？</p>
<p>根据定义，</p>
<script type="math/tex; mode=display">
f[k]=n!*\binom{D}{k}*[x^n](\frac{e^x-e^{-x}}{2})^k(e^{x})^{D-k}\\
=\binom{D}{k}*n!*\frac{1}{2^k}*[x^n]\sum_{i=0}^k((-1)^{k-i}\binom{k}{i}e^{ix}e^{(k-i)x})e^{(D-k)x}\\
=\binom{D}{k}*n!*\frac{1}{2^k}*\sum_{i=0}^k(-1)^{k-i}\binom{k}{i}[x^n]e^{(D-2(k-i))x}\\
=\frac{D!}{k!(D-k)!}*n!*\frac{1}{2^k}*\sum_{i=0}^k(-1)^{k-i}*\frac{k!}{i!(k-i)!}*\frac{(D-2(k-i))^n}{n!}\\
=\frac{D!}{2^k(D-k)!}*\sum_{i=0}^k\frac{(-1)^i(D-2i)^n}{i!}*\frac{1}{(k-i)!}</script><p>很显然的卷积形式，直接<script type="math/tex">NTT</script>即可。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">5e5</span> + <span class="number">10</span>, mod = <span class="number">998244353</span>, g = <span class="number">3</span>, gi = <span class="number">332748118</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> D, n, m;</span><br><span class="line"><span class="keyword">int</span> lim, cnt, ans;</span><br><span class="line"><span class="keyword">int</span> r[maxN + <span class="number">1</span>], F[maxN + <span class="number">1</span>], G[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> fac[maxN + <span class="number">1</span>], inv[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> A[maxN + <span class="number">1</span>], B[maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ADD</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y &gt;= mod ? x + y - mod : x + y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">SUB</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x - y &lt; <span class="number">0</span> ? x - y + mod : x - y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>) ans = <span class="number">1ll</span> * ans * a % mod;</span><br><span class="line">        a = <span class="number">1ll</span> * a * a % mod;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; r[i]) <span class="built_in">swap</span>(a[i], a[ r[i] ]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> wn = <span class="built_in">mpow</span>(type == <span class="number">1</span> ? g : gi, (mod - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i += (mid &lt;&lt; <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; j++, w = <span class="number">1ll</span> * w * wn % mod)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x = a[i + j], y = <span class="number">1ll</span> * w * a[i + mid + j] % mod;</span><br><span class="line">                a[i + j] = <span class="built_in">ADD</span>(x, y); a[i + mid + j] = <span class="built_in">SUB</span>(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(type == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> inv = <span class="built_in">mpow</span>(lim, mod - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++) a[i] = <span class="number">1ll</span> * a[i] * inv % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;D, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(n - <span class="number">2</span> * m &lt; <span class="number">0</span>) &#123; <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span>(D &lt;= n - <span class="number">2</span> * m) &#123; <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">mpow</span>(D, n)); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= D; i++) fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    inv[D] = <span class="built_in">mpow</span>(fac[D], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = D - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) inv[i] = <span class="number">1ll</span> * inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    </span><br><span class="line">    lim = <span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(lim &lt;= <span class="number">2</span> * D) lim &lt;&lt;= <span class="number">1</span>, cnt ++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; cnt - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= D; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1ll</span> * <span class="built_in">mpow</span>(<span class="built_in">SUB</span>(D, <span class="number">2</span> * i), n) * inv[i] % mod;</span><br><span class="line">        <span class="keyword">if</span>(i &amp; <span class="number">1</span>) A[i] = <span class="built_in">SUB</span>(<span class="number">0</span>, x);</span><br><span class="line">        <span class="keyword">else</span> A[i] = x;</span><br><span class="line">        B[i] = inv[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NTT</span>(A, <span class="number">1</span>); <span class="built_in">NTT</span>(B, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++) A[i] = <span class="number">1ll</span> * A[i] * B[i] % mod;</span><br><span class="line">    <span class="built_in">NTT</span>(A, <span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> I = <span class="number">499122177</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, pw = <span class="number">1</span>; i &lt;= D; i++, pw = <span class="number">1ll</span> * pw * I % mod)</span><br><span class="line">        F[i] = <span class="number">1ll</span> * fac[D] * inv[D - i] % mod * pw % mod * A[i] % mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= D; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        A[D - i] = <span class="number">1ll</span> * fac[i] * F[i] % mod;</span><br><span class="line">        B[i] = (i &amp; <span class="number">1</span>) ? <span class="built_in">SUB</span>(<span class="number">0</span>, inv[i]) : inv[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NTT</span>(A, <span class="number">1</span>); <span class="built_in">NTT</span>(B, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++) A[i] = <span class="number">1ll</span> * A[i] * B[i] % mod;</span><br><span class="line">    <span class="built_in">NTT</span>(A, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= D; i++) G[i] = A[D - i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">2</span> * m; i++) ans = <span class="built_in">ADD</span>(ans, <span class="number">1ll</span> * inv[i] * G[i] % mod);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是我第一次真正意义上用<script type="math/tex">EGF</script>解题，首先，用<script type="math/tex">EGF</script>一般都要转化成<script type="math/tex">e^{tx}</script>的形式，而且尽量避免多个类似<script type="math/tex">\frac{e^x+e^{-x}}{2}</script>若干次方相乘这种情况出现（要用二项式定理展开，太麻烦），尽量多出现<script type="math/tex">e^{tx}</script>，这个时候我们就需要容斥。</p>
<p>容斥的时候，以前经常担心需不需要加组合数，实际上，要加组合数一般都是用二项式反演，手推一下式子即可。一般情况下，容斥的是子集的时候不用加组合数，但容斥的是超集的时候一般都要加组合数，因为超集的贡献会有多次，而子集的贡献一般只会有一次。每次做题时，先推出类似<script type="math/tex">f[k]=\sum g[i]</script>的形式再转过来，会减少很多顾虑。</p>
<p>另外，当生成函数用于推式子的时候用到其中某一项可以用<script type="math/tex">[x^n]</script>来表示，更为惊奇的是这个东西后面的与生成函数无关的东西（与<script type="math/tex">x</script>无关的东西）可以提到前面来（其实道理也很简单，只是之前并未想到），例如本题中把<script type="math/tex">\sum_{i=1}^k(-1)^{k-i}</script>提到前面来的情况，一定要熟练掌握。</p>
]]></content>
      <categories>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>[LOJ3284]Exercise</title>
    <url>/2020/04/10/LOJ3284-Exercise/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定<script type="math/tex">n,m</script>，设一个<script type="math/tex">1</script>到<script type="math/tex">n</script>的置换<script type="math/tex">P</script>，定义<script type="math/tex">f(P)</script>是满足<script type="math/tex">P^x=I</script>的最小的<script type="math/tex">x</script>（<script type="math/tex">I</script>是单位置换），求<script type="math/tex">\prod_P f(P)\mod m</script>。</p>
<p>其中<script type="math/tex">n\le 7500,1e8\le m\le 1e9+7</script>，且<script type="math/tex">m</script>为质数。</p>
<p><strong>本题来源于USACO 2020 US Open Platinum T2。</strong></p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>注意到<script type="math/tex">f(P)</script>实际上就是<script type="math/tex">P</script>所有循环长度的最小公倍数。</p>
<p>直接求最小公倍数似乎无从下手，但题目要求的是乘积，所以我们可以枚举质数，然后计算每一个质数对答案的贡献。</p>
<p>对于一个<script type="math/tex">p</script>，定义<script type="math/tex">ord_p(x)</script>为<script type="math/tex">x</script>质因子分解后<script type="math/tex">p</script>的指数，那么我们要计算的是</p>
<script type="math/tex; mode=display">
\sum_Smax_{a\in S} ord_p(a)</script><p>对于<script type="math/tex">S</script>，我们要满足</p>
<script type="math/tex; mode=display">
\sum_{a\in S}a=n</script><p>根据套路，我们把换成</p>
<script type="math/tex; mode=display">
\sum_{k\ge 1}k*\sum_S[max_{a\in S}ord_p(a)=k]</script><p>这个时候，我们肯定是要对这个进行<script type="math/tex">dp</script>的，我们每次要枚举加入的数。</p>
<p>我们发现这个<script type="math/tex">max</script>对复杂度非常不友好，要<script type="math/tex">O(n)</script>地进行枚举，而如果改成<script type="math/tex">min</script>的话，我们枚举量就可以缩减为<script type="math/tex">\frac{n}{p^k}</script>，大大减少了复杂度。怎么把<script type="math/tex">max</script>改成<script type="math/tex">min</script>呢？<script type="math/tex">min-max</script>容斥！</p>
<p>想不到吧，<script type="math/tex">min-max</script>容斥不仅能用在期望上，有时还能优化复杂度！</p>
<p>那么我们就变为</p>
<script type="math/tex; mode=display">
\sum_{k\ge 1}k*\sum_S\sum_{T\subset S}(-1)^{|T|-1}[min_{a\in T}ord_p(a)=k]\\
=\sum_{k\ge 1}k*\sum_T(-1)^{|T|-1}[min_{a\in T}ord_p(a)=k]*coef(T)</script><p>这个<script type="math/tex">coef(T)</script>就是<script type="math/tex">T</script>对答案的贡献系数，我们后面再说。</p>
<p>我们发现这个<script type="math/tex">k</script>非常地不好弄，那么我们还有一个常用办法，把式子转变成：</p>
<script type="math/tex; mode=display">
\sum_{k\ge 1}\sum_T(-1)^{|T|-1}[ord_p(a)\ge k,\forall a\in T]*coef(T)</script><p>这个时候，一个<script type="math/tex">T</script>满足<script type="math/tex">min(ord_p(a))=k</script>，它对答案依然会产生<script type="math/tex">k</script>的贡献。这是非常常用的方法。这也是我们为什么把<script type="math/tex">max</script>转为<script type="math/tex">min</script>的重要原因！</p>
<p>我们现在来看<script type="math/tex">coef(T)</script>，实际上，它的含义为剩下的随便变成若干环排列。我们记<script type="math/tex">sum(T)</script>为<script type="math/tex">T</script>中所有元素的和，那么首先我们要从<script type="math/tex">n</script>个中选出<script type="math/tex">sum(T)</script>个，先乘以<script type="math/tex">\binom{n}{sum(T)}</script>，现在来看剩下<script type="math/tex">n-sum(T)</script>个数构成若干环排列的方案数。</p>
<p>我们设<script type="math/tex">g(m)</script>表示<script type="math/tex">m</script>个数分成若干环排列的方案数，那么我们每次考虑加入一个数，和第一类斯特林数推导类似的思想，我们考虑它放在哪：一种情况，它自立门户，单独成为一个环排列，另外一种情况，它放在前面某个数的一侧。那么递推式就有了：</p>
<script type="math/tex; mode=display">
g(m)=(m-1)*g(m-1)+g(m-1)*1=m*g(m-1)</script><p>根据<script type="math/tex">g(1)=1</script>，我们发现<script type="math/tex">g(m)=m!</script>，这也告诉我们第一类斯特林数第<script type="math/tex">i</script>行数的和为<script type="math/tex">i!</script>。</p>
<p>那么我们就有</p>
<script type="math/tex; mode=display">
coef(T)=\binom{n}{sum(T)}*(n-sum(T))!</script><p>我们发现这个<script type="math/tex">coef(T)</script>只与<script type="math/tex">sum(T)</script>有关，那么我们就可以枚举<script type="math/tex">k</script>进行<script type="math/tex">dp</script>了。</p>
<p>下面设<script type="math/tex">s=p^k</script>，我们相当于钦定每个环排列大小都是<script type="math/tex">s</script>的倍数来计算方案。</p>
<p>我们设<script type="math/tex">f[i]</script>表示<script type="math/tex">sum(T)=is</script>时的容斥系数。现在我们考虑加入一个环排列，首先容斥系数显然取反。然后为了避免算重，根据计数技巧，我们枚举与<script type="math/tex">1</script>在一起的那个环排列，一个大小为<script type="math/tex">m</script>的集合的环排列个数显然是<script type="math/tex">(m-1)!</script>，那么转移方程就出来了。</p>
<script type="math/tex; mode=display">
f[i]=-\sum_{j=1}^i \binom{i*s-1}{j*s-1}*(j*s-1)!*f[i-j]</script><p>考虑时间复杂度，我们相当于是对于所有的质数<script type="math/tex">p</script>对于时间的贡献为</p>
<script type="math/tex; mode=display">
\sum_{p^k\le n}(\lfloor\frac{n}{p^k}\rfloor)^2\le n^2*\sum_k \frac{1}{p^{2k}}=O(\frac{n^2}{p^2})</script><p>那么总复杂度为</p>
<script type="math/tex; mode=display">
n^2*\sum_p\frac{1}{p^2}\le n^2</script><p>所以复杂度为<script type="math/tex">O(n^2)</script>。</p>
<p>另外注意，我们在<script type="math/tex">dp</script>指数，所以<script type="math/tex">dp</script>值，组合数，阶乘的模数都是<script type="math/tex">\phi(mod)=mod-1</script>，而我们做快速幂的时候模数是<script type="math/tex">mod</script>，不要混淆。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">7505</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, mod, ans;</span><br><span class="line"><span class="keyword">int</span> f[maxN + <span class="number">1</span>], C[maxN + <span class="number">1</span>][maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> fac[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> flag[maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ADD</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y &gt;= mod ? x + y - mod : x + y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">SUB</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x - y &lt; <span class="number">0</span> ? x - y + mod : x - y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>) ans = <span class="number">1ll</span> * ans * a % (mod + <span class="number">1</span>);</span><br><span class="line">        a = <span class="number">1ll</span> * a * a % (mod + <span class="number">1</span>);</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = n / k, res = <span class="number">0</span>;</span><br><span class="line">    f[<span class="number">0</span>] = mod - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            f[i] = <span class="built_in">SUB</span>(f[i], <span class="number">1ll</span> * C[i * k - <span class="number">1</span>][j * k - <span class="number">1</span>] * fac[j * k - <span class="number">1</span>] % mod * f[i - j] % mod); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        res = <span class="built_in">ADD</span>(res, <span class="number">1ll</span> * C[n][i * k] * fac[n - i * k] % mod * f[i] % mod);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;mod);</span><br><span class="line">    mod --;</span><br><span class="line"></span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) C[i][j] = <span class="built_in">ADD</span>(C[i - <span class="number">1</span>][j], C[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!flag[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + i; j &lt;= n; j += i) flag[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= n; j *= i)</span><br><span class="line">                ans = <span class="number">1ll</span> * ans * <span class="built_in">mpow</span>(i, <span class="built_in">calc</span>(j)) % (mod + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>首先，对于一些特定的题目，会有<script type="math/tex">min</script>比<script type="math/tex">max</script>更适合解题或<script type="math/tex">max</script>比<script type="math/tex">min</script>更适合解题的情况，这个时候也可以考虑<script type="math/tex">min-max</script>容斥。</p>
<p>其次，对于一些情况（比如本题），我们可以用<script type="math/tex">=</script>转<script type="math/tex">\ge</script>的容斥，既放宽松了条件，又去掉了一个系数，十分巧妙。</p>
<p>另外，我们在<script type="math/tex">dp</script>有关集合的时候，为了防止算重，我们会枚举与某个特定的数在一起的那个元素（比如本题枚举与<script type="math/tex">1</script>在一起的环排列），这个技巧也要牢记。</p>
]]></content>
      <categories>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>[LOJ6047]决斗</title>
    <url>/2020/03/01/LOJ6047-%E5%86%B3%E6%96%97/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有<script type="math/tex">n</script>个位置排成一个环，每个位置有一个值<script type="math/tex">a_i</script>，还有<script type="math/tex">n</script>人，每一个人有一个位置标号<script type="math/tex">t_i</script>（不同的人<script type="math/tex">t_i</script>可能相同），还有一个值<script type="math/tex">b_i</script>。</p>
<p>现在人们按照一定顺序进入场地，当编号为<script type="math/tex">k</script>的人进入时，会找到<script type="math/tex">t_k</script>的位置，如果这个位置已经有人，那么他会从这个位置顺时针找到第一个空位并坐下。</p>
<p>设<script type="math/tex">ans</script>为最后位置上坐着的人的值大于这个位置的值的位置个数。</p>
<p>问通过不同的顺序安排方式，最大的<script type="math/tex">ans</script>时多少？</p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先，我们考虑最终的最优方案是什么样子。</p>
<p>我们设位置标号为<script type="math/tex">i</script>的人组成的集合为<script type="math/tex">s_i</script>。</p>
<p>那么必然有一个位置，它的上面坐的人属于<script type="math/tex">s_i</script>，且没有属于它之前的位置的人坐到这个位置之后。</p>
<p>显然我们选择的第一个位置就符合条件。</p>
<p>那么，我们有一个贪心策略，由于后面的数不会影响到当前决策，我们就用<script type="math/tex">set</script>维护出当前可用的人的值，然后每到一个位置，把属于当前位置的人的值先加入<script type="math/tex">set</script>，然后选择大于等于当前位置的值的最小的数，作为坐在这里的人，然后把它删去，如果没有找到，那么就删去<script type="math/tex">set</script>中最小的一个。</p>
<p>这个贪心的正确性是显然的。</p>
<p>但是，我们并不知道我们选择的第一个位置是什么，所以要枚举，再加上贪心，时间复杂度<script type="math/tex">O(n^2log_2n)</script>，显然无法通过。</p>
<p>那么，我们能不能不用枚举第一个位置是什么，而直接找呢？</p>
<p>实际上，存在一个位置，不管按照什么顺序排列，都不会有属于它之前的位置的人坐到这个位置之后。这个位置要满足什么条件呢？</p>
<p>我们记<script type="math/tex">x_i=|s_i|-1</script>，那么，这个位置要满足整个环以这个位置为开头，所有的<script type="math/tex">x_i</script>的前缀和都<script type="math/tex">>=0</script>。</p>
<p>这是啥？</p>
<p>我们考虑这个<script type="math/tex">x_i</script>的前缀和是什么含义？记其为<script type="math/tex">sum_i</script>，它表示处理完前<script type="math/tex">i</script>个位置之后还剩下来的可供填的人数。如果在任何时候都有<script type="math/tex">sum_i>=0</script>，说明所有位置不会出现人不够填的情况，就不会有后面的位置的人填到前面来。</p>
<p>是不是对于所有的顺序，这个位置记为<script type="math/tex">k</script>都不会被跨越呢？</p>
<p>是的，我们用反证法，如果存在某个位置开头填后，使得<script type="math/tex">k</script>被跨越了，那么说明<script type="math/tex">sum_{k-1}>0</script>，而所有的数的<script type="math/tex">x_i</script>之和显然等于<script type="math/tex">0</script>，那么<script type="math/tex">k</script>到末尾的位置的<script type="math/tex">x</script>之和<script type="math/tex"><0</script>，与<script type="math/tex">k</script>这个位置的定义矛盾。</p>
<p>所以，对于所有的顺序，这个<script type="math/tex">k</script>都不会被跨越，也就是说，我们只要找到这个<script type="math/tex">k</script>，就可以放心地把它当作开头来进行贪心。</p>
<p>但是，我们一定能找到这样一个<script type="math/tex">k</script>吗，怎样找这样的<script type="math/tex">k</script>呢？</p>
<p>其实，这两个问题可以放在一起解决。</p>
<p>我们考虑随便以一个位置开头，那么<script type="math/tex">sum_i</script>的值一定构成了一段折线，中间有可能会突破到<script type="math/tex">x</script>轴以下。那么，我们找到这段折线值最小的点（若有多个，任选一个），最小值记为<script type="math/tex">mn</script>，这个点为<script type="math/tex">k</script>。</p>
<p>我们让这个点<script type="math/tex">k</script>之后的那个点<script type="math/tex">k+1</script>成为第一个，这个点把当成原点（也是最后一个点），那么，我们相当于把<script type="math/tex">k</script>之后的函数图像从向上平移了<script type="math/tex">|mn|</script>个单位，这个时候这一段不存在<script type="math/tex">x</script>轴以下的点，这个时候我们再把前面那一段给接到这个函数末尾，那么这个函数此时不会有任何一段再<script type="math/tex">x</script>轴以下（否则就和<script type="math/tex">mn</script>是之前那段函数的最小值矛盾）。</p>
<p>那么，我们不仅证明了这样的点一定存在，还知道了找到<script type="math/tex">k</script>的方法。</p>
<p>我们从任何一个点开始（比如从<script type="math/tex">1</script>），求<script type="math/tex">x_i</script>的前缀和<script type="math/tex">sum_i</script>，取<script type="math/tex">sum</script>最小的点<script type="math/tex">k</script>，然后以<script type="math/tex">k+1</script>作为开始点进行贪心即可。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[maxN + <span class="number">1</span>], b[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> sum[maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; num[maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>( !<span class="built_in">isdigit</span>( ch ) ) &#123; <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">isdigit</span>( ch ) ) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> num * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) num[ <span class="built_in">read</span>() ].<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) b[i] = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + num[i].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum[i] &lt; sum[now]) now = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    now ++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++, now++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(now &gt; n) now = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num[now].<span class="built_in">size</span>(); j++)</span><br><span class="line">            s.<span class="built_in">insert</span>(b[ num[now][j] ]);</span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt;::iterator it = s.<span class="built_in">lower_bound</span>(a[now]);</span><br><span class="line">        <span class="keyword">if</span>(it != s.<span class="built_in">end</span>()) ans ++, s.<span class="built_in">erase</span>(it ++);</span><br><span class="line">        <span class="keyword">else</span> it = s.<span class="built_in">begin</span>(), s.<span class="built_in">erase</span>(it ++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们经常遇到一个环<script type="math/tex">x_i</script>，其总和为<script type="math/tex">0</script>，然后我们要以某个位置开头，使得每个前缀和都<script type="math/tex">>=0</script>，那么我们可以使用以上的分析方法，必然存在这样的一个点满足条件，而且通过函数图像解题，调整，都是贪心的常用技巧，一定要熟练掌握。</p>
]]></content>
      <categories>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1307G Cow and Exercise</title>
    <url>/2021/02/22/CF1307G-Cow-and-Exercise/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定<script type="math/tex">n</script>个点<script type="math/tex">m</script>条边的有向图（无重边自环），每条边有边权。</p>
<p>一共<script type="math/tex">q</script>次询问，每次给定一个数<script type="math/tex">x_i</script>，我们可以增加某些边的边权，要求在总增加量不超过<script type="math/tex">x_i</script>的前提下让<script type="math/tex">1</script>到<script type="math/tex">n</script>的最短路最大，问这个最大值是多少。</p>
<p>其中<script type="math/tex">2\le n\le 50,1\le m\le n(n-1),q\le 10^5</script>。</p>
<span id="more"></span>
<h1 id="线性规划对偶性"><a href="#线性规划对偶性" class="headerlink" title="线性规划对偶性"></a>线性规划对偶性</h1><p><strong>什么是线性规划？</strong></p>
<p>我们有<script type="math/tex">n</script>个变量<script type="math/tex">x_1,x_2,\dots,x_n</script>，然后有<script type="math/tex">m</script>条限制，第<script type="math/tex">i</script>条限制为</p>
<script type="math/tex; mode=display">
\sum_{j=1}^na_{j,i}x_j\le c_i</script><p>我们的目标是求</p>
<script type="math/tex; mode=display">
\max \sum_{i=1}^nb_ix_i</script><p>上面的<script type="math/tex">\le</script>可以取反，<script type="math/tex">\max</script>也可以变成<script type="math/tex">\min</script>。</p>
<p>这一类问题称为线性规划问题，在<script type="math/tex">OI</script>中一般采用单纯形进行解决。但是，有许多线性规划问题由于问题本身的特殊性可以用网络流解决。</p>
<p><strong>那么，线性规划的对偶问题又是什么呢？</strong></p>
<p>对于上面这个线性规划，其对偶问题为</p>
<p>我们有<script type="math/tex">m</script>个变量<script type="math/tex">y_1,y_2,\dots,y_m</script>，有<script type="math/tex">n</script>条限制，第<script type="math/tex">i</script>条限制为</p>
<script type="math/tex; mode=display">
\sum_{j=1}^ma_{i,j}y_j\ge b_i</script><p>目标是</p>
<script type="math/tex; mode=display">
\min \sum_{i=1}^mc_iy_i</script><p><strong>那么，如何直观地理解对偶问题呢？</strong></p>
<p>实际上，我们可以从经济学的角度理解对偶问题。</p>
<p>为了方便起见，不妨设原问题为问题<script type="math/tex">a</script>，其对偶问题为问题<script type="math/tex">b</script>。</p>
<p>有两个公司<script type="math/tex">A,B</script>，其中，<script type="math/tex">A</script>公司是制作产品的，<script type="math/tex">B</script>公司是回收原料的。</p>
<p>现在，有<script type="math/tex">n</script>个产品，<script type="math/tex">m</script>种原料，第<script type="math/tex">i</script>个产品需要用<script type="math/tex">a_{i,j}</script>个第<script type="math/tex">j</script>种原料。<script type="math/tex">c_i</script>表示第<script type="math/tex">i</script>种原料有<script type="math/tex">c_i</script>个，<script type="math/tex">b_i</script>表示第<script type="math/tex">i</script>种产品的利润为每个<script type="math/tex">b_i</script>元。</p>
<p>问题<script type="math/tex">a</script>是对于<script type="math/tex">A</script>公司而言的，公司<script type="math/tex">A</script>要选择每种产品制作多少个，它的目标是在满足要求的情况下总利润最大。设它决定第<script type="math/tex">i</script>个产品制作<script type="math/tex">x_i</script>个，那么<script type="math/tex">A</script>公司制作产品一定要满足原料的个数在限制范围内，即</p>
<script type="math/tex; mode=display">
\sum_{j=1}^na_{j,i}x_j\le c_i</script><p>它所希望的总利润最大即</p>
<script type="math/tex; mode=display">
\max \sum_{i=1}^nb_ix_i</script><p>而问题<script type="math/tex">b</script>是针对<script type="math/tex">B</script>公司而言的，现在<script type="math/tex">B</script>公司想要从<script type="math/tex">A</script>公司手中收购原材料，那么显然它要向<script type="math/tex">A</script>公司报价。设第<script type="math/tex">i</script>种材料的报价为<script type="math/tex">y_i</script>。而<script type="math/tex">A</script>公司也不傻，它同意这个报价当且仅当对于每一种产品，其原材料卖给<script type="math/tex">B</script>公司的收益不小于产品的利润（否则，不如不卖这些原材料，做成产品，收益更大）。而<script type="math/tex">B</script>公司的目标自然是最小化购入成本。</p>
<p>那么，<script type="math/tex">A</script>公司同意的条件为</p>
<script type="math/tex; mode=display">
\sum_{j=1}^m a_{i,j}y_j\ge b_i</script><p>而<script type="math/tex">B</script>公司希望的最小化成本为</p>
<script type="math/tex; mode=display">
\min \sum_{i=1}^mc_iy_i</script><p>这样，我们就能很直观地看出对偶问题的关系。可以发现，这两个问题是互为对偶的。</p>
<p><strong>那么，这两个问题有什么性质？</strong></p>
<p>这里，我们不加证明地给出线性规划的对偶性：</p>
<script type="math/tex; mode=display">
\max \sum_{i=1}^nb_ix_i=\min \sum_{i=1}^mc_iy_i</script><p>感性理解一下也是可以的：如果前者更大，那么<script type="math/tex">A</script>公司为什么要进行这个交易来减少收益呢？显然不合理。如果后者更大，那么<script type="math/tex">A</script>公司为什么要制作产品，倒手卖原材料岂不更好？因此，两者只能相等。</p>
<p>但是注意，虽然上述理解过程中我们以产品，材料来便于理解，但实际上<script type="math/tex">x_i,y_i,c_i,d_i,a_{i,j}</script>不一定是整数，甚至不一定是正数，在实际应用中不要混淆。</p>
<p>线性规划的对偶性让我们可以把<script type="math/tex">\max</script>转为<script type="math/tex">\min</script>，也可以把较复杂的问题简化，从而有利于解题。当我们看到一个线性规划问题十分复杂困难时，也许其对偶问题比较简单。</p>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>这道题看起来十分不可做的样子，但是无法暴力以及较小的数据范围启发我们往线性规划的方面想。</p>
<p>注意到最短路是可以转化为线性规划的形式的。设<script type="math/tex">d_u</script>为<script type="math/tex">1</script>到<script type="math/tex">u</script>的最短路，那么原问题可以形式化地写为：</p>
<p>我们有如下条件</p>
<script type="math/tex; mode=display">
d_u+val_{u,v}+c_{u,v}\ge d_v\\
d_u,c_{u,v}\ge 0</script><p>其中<script type="math/tex">val_{u,v}</script>为边的长度，<script type="math/tex">c_{u,v}</script>为边增加的长度。</p>
<p>原本还有条件应该是<script type="math/tex">\sum c_{u,v}\le x_i</script>，但是注意到询问非常多，如果限制与<script type="math/tex">x_i</script>有关的话应该不太行。这种有那么多询问的题目应该是每次询问在一个特定的候选集合中找符合条件的。</p>
<p>因此我们考虑对于某个答案<script type="math/tex">D</script>，求出其所需要的最小的<script type="math/tex">\sum c_{u,v}</script>。</p>
<p>那么限制为</p>
<script type="math/tex; mode=display">
d_u-d_v+c_{u,v}\ge -val_{u,v}\\
d_n-d_1\ge D\\
d_u,c_{u,v}\ge 0\\</script><p>我们要求出</p>
<script type="math/tex; mode=display">
\min \sum c_{u,v}</script><p>在这个问题中一共有<script type="math/tex">n+m</script>个变量，分别为<script type="math/tex">d_1,\dots,d_n</script>以及<script type="math/tex">c_{u,v}</script>。</p>
<p>考虑这个问题的对偶问题，设<script type="math/tex">F</script>为上面第二个条件对偶后的变量，</p>
<p>则限制为</p>
<script type="math/tex; mode=display">
\left\{
\begin{array}{lr}
\sum y_{u,v}-\sum y_{v,u}-F\le 0, & u=1\\
\sum y_{u,v}-\sum y_{v,u}\le 0, & \forall u=2,\dots,n-1\\
\sum y_{u,v}-\sum y_{v,u}+F\le 0, & u=n\\
y_{u,v}\le 1, & \forall(u,v)\in E
\end{array}
\right.</script><p>而我们的目标是</p>
<script type="math/tex; mode=display">
\max D\times F-\sum y_{u,v}val_{u,v}</script><p>观察限制，我们断言，</p>
<script type="math/tex; mode=display">
\forall 1<u<n,\sum y_{u,v}=\sum y_{v,u}\\
u=1,\sum y_{u,v}=\sum y_{v,u}+F\\
u=n,\sum y_{u,v}=\sum y_{v,u}-F</script><p>为什么呢？我们把前三个限制组成的不等式全部相加，因为这是一张图，那么不等式左边和不等式右边都是<script type="math/tex">0</script>，说明不等式是取等的。那么对于每个不等式都是取等的。</p>
<p>观察这个性质，很明显，这个相当于以<script type="math/tex">1</script>为源点，<script type="math/tex">n</script>为汇点的网络流，<script type="math/tex">y_{u,v}</script>为<script type="math/tex">(u,v)</script>的流量，对于<script type="math/tex">1<u<n</script>满足流量守恒，而<script type="math/tex">F</script>是整个网络的流量。每条边的流量上界为<script type="math/tex">1</script>。</p>
<p>那么对于一个<script type="math/tex">D</script>，我们只需要检查所有<script type="math/tex">F</script>与<script type="math/tex">y_{u,v}</script>的取值中使得<script type="math/tex">D\times F-\sum y_{u,v}val_{u,v}</script>最大的那一个是否<script type="math/tex">\le x_i</script>即可。</p>
<p>对于一个固定的<script type="math/tex">F</script>，后面的<script type="math/tex">\sum y_{u,v}val_{u,v}</script>最小值显然是以<script type="math/tex">val_{u,v}</script>为代价的最小费用流，因此我们只需要对于每个<script type="math/tex">F</script>，求出最小费用流，每次询问的时候逐一检查即可。</p>
<p>但是我们显然不能枚举<script type="math/tex">D</script>，我们只需要枚举所有二元组<script type="math/tex">(F,C)</script>，此时<script type="math/tex">D\le \frac{x_i+C}{F}</script>，对此取<script type="math/tex">\min</script>即可。</p>
<p>注意到<script type="math/tex">F</script>只有<script type="math/tex">O(n)</script>种取值，因此每次检查的时间复杂度为<script type="math/tex">O(n)</script>，总时间复杂度为<script type="math/tex">O(nq)</script>。</p>
<p>实际上根据费用流一些结论，这<script type="math/tex">n</script>个取值构成凸壳，可以在凸壳上二分，但是本题并不需要。</p>
<p>对于每个<script type="math/tex">F</script>求费用流可以建立超级源汇，往<script type="math/tex">1</script>和<script type="math/tex">n</script>连流量为<script type="math/tex">F</script>的边跑最小费用最大流，但这是不必要的。考虑求费用流的过程，如果每次增广单位流量，那么<script type="math/tex">F</script>的最小费用流就是<script type="math/tex">F-1</script>的最小费用流加上这次增广的结果，但是如果采用多路增广这个方法就不行了。</p>
<p>时间复杂度<script type="math/tex">O(maxflow+nq)</script>。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">55</span>;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, value, cost, next;</span><br><span class="line">&#125;edge[maxN * maxN * <span class="number">4</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q, cnt, s, t;</span><br><span class="line"><span class="keyword">int</span> head[maxN + <span class="number">1</span>], tot = <span class="number">1</span>, pre[maxN + <span class="number">1</span>], id[maxN + <span class="number">1</span>];</span><br><span class="line">LL dis[maxN + <span class="number">1</span>], ans[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> flag[maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> t, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++ tot] = (Node)&#123;y, t, c, head[x]&#125;; head[x] = tot;</span><br><span class="line">    edge[++ tot] = (Node)&#123;x, <span class="number">0</span>, -c, head[y]&#125;; head[y] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) dis[i] = INF, pre[i] = id[i] = <span class="number">0</span>, flag[i] = <span class="literal">false</span>;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s); dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        flag[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to, w = edge[i].cost;</span><br><span class="line">            <span class="keyword">if</span>(!edge[i].value || dis[u] + w &gt;= dis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            dis[v] = dis[u] + w;</span><br><span class="line">            pre[v] = u; id[v] = i;</span><br><span class="line">            <span class="keyword">if</span>(!flag[v]) flag[v] = <span class="literal">true</span>, q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre[t] &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MCMF</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">spfa</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">        cnt ++;</span><br><span class="line">        ans[cnt] = ans[cnt - <span class="number">1</span>] + dis[t];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> now = t; now != s; now = pre[now])</span><br><span class="line">            edge[ id[now] ].value --, edge[ id[now] ^ <span class="number">1</span> ].value ++;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, t;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;x, &amp;y, &amp;t);</span><br><span class="line">        <span class="built_in">add</span>(x, y, <span class="number">1</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = <span class="number">1</span>, t = n;</span><br><span class="line">    <span class="built_in">MCMF</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1e18</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) res = <span class="built_in">min</span>(res, (<span class="keyword">double</span>)(x + ans[i]) / (<span class="keyword">double</span>)(i));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在以后做题的过程中，如果题目很难下手，可以往线性规划上面想，而如果线性规划的式子可以写成如下形式：</p>
<p>限制为</p>
<script type="math/tex; mode=display">
\left\{
\begin{array}{lr}
d_u-d_v+x_{u,v}\ge w_{u,v}\\
d_u\ge 0, x_{u,v}\ge 0
\end{array}
\right.</script><p>目标为</p>
<script type="math/tex; mode=display">
\min \sum c_{u,v}x_{u,v}</script><p>那么就可以对偶为费用流问题。</p>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>线性规划</tag>
      </tags>
  </entry>
  <entry>
    <title>[LOJ6053]简单的函数</title>
    <url>/2019/07/29/LOJ6053-%E7%AE%80%E5%8D%95%E7%9A%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有一个函数<script type="math/tex">f(x)</script>：</p>
<script type="math/tex; mode=display">
f(1)=1\\
f(p^c)=p\oplus c(p\in Prime)\\
f(ab)=f(a)f(b)</script><p>求<script type="math/tex">\sum_{i=1}^nf(i)\quad mod\quad 1e9+7</script></p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>考虑<script type="math/tex">f(p)</script>的值，可以发现</p>
<script type="math/tex; mode=display">
f(p)=
\begin{cases}
p-1\quad(p\neq2)\\
p+1\quad(p=2)
\end{cases}</script><p>我们不妨假设所有的<script type="math/tex">f(p)=p-1</script>，最后只要在含有<script type="math/tex">p=2</script>的答案<script type="math/tex">+2</script>就行了。</p>
<p>按照之前讲的，直接积性函数计算并不好计算，所以我们把它拆成两个式子，一个是<script type="math/tex">p</script>，一个是<script type="math/tex">1</script>。</p>
<p>也就是说，我们改为计算</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n[i\in Prime]i和\sum_{i=1}^n[i\in Prime]1</script><p>所以我们只要维护这两个东西就好了，设为<script type="math/tex">g,h</script>。</p>
<p>那么，最后的计算就是</p>
<script type="math/tex; mode=display">
S(n,j)=g(n,|P|)-\sum_{i=1}^{j-1}P_i-(h(n,|P|)-(j-1))+...</script><p>后面的就是之前推过的式子了。</p>
<p>注意，当<script type="math/tex">j==1</script>的时候，答案要加上<script type="math/tex">2</script>，之前说过的。</p>
<p>最后的答案就是<script type="math/tex">S(n,1)+1</script>了。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p><strong>注意：随时取模。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">1e6</span> + <span class="number">100</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, id1[maxN + <span class="number">1</span>], id2[maxN + <span class="number">1</span>], m, w[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> g[maxN + <span class="number">1</span>], h[maxN + <span class="number">1</span>], sum[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> prime[maxN + <span class="number">1</span>], tot, lim, inv2;</span><br><span class="line"><span class="keyword">bool</span> flag[maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lim = std::<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= lim; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag[i]) prime[++ tot] = i, sum[tot] = (sum[tot - <span class="number">1</span>] + i) % mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt;= lim; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            flag[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>; inv2 = <span class="built_in">pow</span>(<span class="number">2</span>, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = n / i, k = n / j;</span><br><span class="line">        w[++ m] = j;</span><br><span class="line">        <span class="keyword">if</span>(w[m] &lt;= lim) id1[ w[m] ] = m;</span><br><span class="line">        <span class="keyword">else</span> id2[ n / w[m] ] = m;</span><br><span class="line">        h[m] = (w[m] - <span class="number">1</span>) % mod;</span><br><span class="line">        g[m] = w[m] % mod * ((w[m] + <span class="number">1</span>) % mod) % mod * inv2 % mod;</span><br><span class="line">        g[m] = (g[m] - <span class="number">1</span>) % mod;</span><br><span class="line">        i = k + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m &amp;&amp; prime[j] * prime[j] &lt;= w[i]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = (w[i] / prime[j] &lt;= lim ? id1[ w[i] / prime[j] ] : id2[ n / (w[i] / prime[j]) ]);</span><br><span class="line">            g[i] = (g[i] - prime[j] * (g[k] - sum[j - <span class="number">1</span>]) % mod) % mod;</span><br><span class="line">            h[i] = (h[i] - h[k] + j - <span class="number">1</span>) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">S</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= <span class="number">1</span> || prime[y] &gt; x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k = (x &lt;= lim ? id1[x] : id2[n / x]), res = g[k] - sum[y - <span class="number">1</span>] - (h[k] - (y - <span class="number">1</span>));</span><br><span class="line">    res %= mod;</span><br><span class="line">    <span class="keyword">if</span>(y == <span class="number">1</span>) res = (res + <span class="number">2</span>) % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = y; i &lt;= tot &amp;&amp; prime[i] * prime[i] &lt;= x; i++) </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>, t = prime[i]; t * prime[i] &lt;= x; j++, t *= prime[i])</span><br><span class="line">           res = (res + <span class="built_in">S</span>(x / t, i + <span class="number">1</span>) * (prime[i] ^ j) % mod + (prime[i] ^ (j + <span class="number">1</span>)) % mod) % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> int</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="built_in">S</span>(n, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, (ans % mod + mod) % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>Min_25筛</tag>
      </tags>
  </entry>
  <entry>
    <title>Min_25筛略解</title>
    <url>/2019/07/29/Min-25%E7%AD%9B%E7%95%A5%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Min-25筛"><a href="#Min-25筛" class="headerlink" title="Min_25筛"></a>Min_25筛</h1><p>大名鼎鼎的<script type="math/tex">Min25</script>筛，是用来干什么的呢？</p>
<p>它是用来求积性函数前缀和<script type="math/tex">\sum f(i)</script>的，而且复杂度很优，是<script type="math/tex">O(\frac{N^\frac{3}{4}}{log_2N})</script>。使用它要满足一下几个条件：</p>
<script type="math/tex; mode=display">
1.f是积性函数\\
2.f(p)(p\in Prime)是简单多项式形式\\
3.f(p^k)(p\in prime)可以很快地算出来</script><span id="more"></span>
<p>对于第二个条件，我的理解是如果遇到一个类似<script type="math/tex">p^{a1}+p^{a2}+...</script>，把每一项分开来算（后面的例题可以看出），这样才能算出来，也就是说，即使一个函数<script type="math/tex">f</script>是积性函数，比如<script type="math/tex">f(p)=p-1(p\in Prime),f(ab)=f(a)f(b)</script>，也不能直接拿<script type="math/tex">f(p)=p-1</script>来筛，而是把它拆成两个<script type="math/tex">f1(p)=p,f2(p)=1</script>，再来算。</p>
<h1 id="求解g"><a href="#求解g" class="headerlink" title="求解g"></a>求解g</h1><p>我们考虑先设</p>
<script type="math/tex; mode=display">
g(n,j)=\sum_{i=1}^n[i\in Prime\quad or\quad min(p)>Prime_j,p|i,p\in Prime]f(i)</script><p>换句话说，<script type="math/tex">g(n,j)</script>就是<script type="math/tex">1</script>到<script type="math/tex">n</script>中是质数或最小质因子大于<script type="math/tex">Prime_j</script>的贡献和。</p>
<p>然后，我们计算出对于所有<script type="math/tex">x=\lfloor\frac{n}{i}\rfloor</script>的<script type="math/tex">g(x,j)</script>的值。我们考虑怎么计算转移。</p>
<ol>
<li><p>如果<script type="math/tex">Prime_j^2>x</script>，那么答案不会产生变化。</p>
</li>
<li><p>如果<script type="math/tex">Prime_j^2<=x</script>，那么答案相较于<script type="math/tex">g(x,j-1)</script>会减少，减少的量容斥一下就好了。</p>
</li>
</ol>
<p>后面的<script type="math/tex">Prime_j</script>用<script type="math/tex">P_j</script>表示。</p>
<script type="math/tex; mode=display">
g(x,j)=
\begin{cases}
g(x,j-1)\quad (P_j^2>x)\\
g(x,j-1)-f(P_j)*(g(\lfloor\frac{x}{P_j}\rfloor,j-1)-\sum_{i=1}^{j-1}f(P_i))\quad (P_j^2<=x)
\end{cases}</script><p>理解起来也很简单，我们要减去的，就是之前最小因子为<script type="math/tex">P_j</script>的数的<script type="math/tex">f</script>，所以，我们把<script type="math/tex">f(P_j)</script>提出来，然后，先把所有的去掉<script type="math/tex">P_j</script>的答案去掉，但是这样会多算第<script type="math/tex">j-1</script>以内的所有质数的<script type="math/tex">f</script>，减掉就好了。</p>
<p>然后，边界条件是什么？<script type="math/tex">g(x,0)</script>表示所有的数都当成质数带入<script type="math/tex">f(p)</script>的值之和。</p>
<p>最后，我们只要求出<script type="math/tex">g(n,|P|)</script>即可，根据转移的过程，我们发现<script type="math/tex">g</script>只需要开一维。</p>
<h1 id="求解S"><a href="#求解S" class="headerlink" title="求解S"></a>求解S</h1><p>上一步我们求出了<script type="math/tex">g</script>。</p>
<p>其实，我们只需要用到<script type="math/tex">g(n,|P|)</script>这一个值，表示所有质数的<script type="math/tex">f</script>之和。</p>
<p>然后，我们设<script type="math/tex">S(n,j)</script></p>
<script type="math/tex; mode=display">
S(n,j)=\sum_{i=1}^n[min(p)>=P_j]f(i)</script><p>这个怎么转移呢？我们先把质数的算出来，然后考虑合数，我们可以枚举它的最小质因子和它出现的次数，就可以转移了。</p>
<script type="math/tex; mode=display">
S(n,j)=g(n,|P|)-\sum_{i=1}^{j-1}f(P_i)+\sum_{k=j}^{P_k^2<=n}\sum_e^{P_k^{e+1}<=n}(S(\lfloor\frac{n}{P_k^e}\rfloor,k+1)*f(P_k^e)+f(P_k^{e+1}))</script><p>然后，就没有了，最后的答案就是<script type="math/tex">S(n,1)+f(1)</script>。</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://cmwqf.github.io/2019/07/29/LOJ6053-%E7%AE%80%E5%8D%95%E7%9A%84%E5%87%BD%E6%95%B0/">简单的函数</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>Min_25筛</tag>
      </tags>
  </entry>
  <entry>
    <title>Tribles</title>
    <url>/2019/01/26/Tribles/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给你<script type="math/tex">k</script>个球，  一个球可以活一天，在它死的时候会有概率<script type="math/tex">pi</script>生出<script type="math/tex">i</script>个小球<script type="math/tex">(0<=i<n)</script>， 现在问你<script type="math/tex">m</script>天后 所有小球全部死亡的概率是多少？</p>
<span id="more"></span>
<h1 id="Soltuion"><a href="#Soltuion" class="headerlink" title="Soltuion"></a>Soltuion</h1><p>由于每个球是独立的，我们可以把每个答案算出来，最后k次方一下就好了；</p>
<p>问题就转变为开始有一个球，过m天后全部死亡的概率是多少？</p>
<p>我们设f[i]表示<strong>还有i天所有球全部死亡的概率</strong>，则有：</p>
<script type="math/tex; mode=display">
f[i]=p0+p1*f[i-1]^1+p2*f[i-1]^2...</script><p>为什么是<script type="math/tex">f[i-1]</script>呢？</p>
<p>因为今天每个球又变成了独立的个体，如果一个球生了<script type="math/tex">j</script>个，那么这<script type="math/tex">j</script>个必然在<script type="math/tex">i-1</script>天后死去，而这<script type="math/tex">j</script>个球也是独立的个体，所以每个球死亡的概率都是<script type="math/tex">f[i-1]</script>,所以要<script type="math/tex">j</script>次方。</p>
<p>最后，统计一下答案，就可以了。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN=<span class="number">1000</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">double</span> p[maxN+<span class="number">1</span>],f[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,k,t,cnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;k,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;p[i]);</span><br><span class="line">        f[<span class="number">0</span>]=<span class="number">0</span>; f[<span class="number">1</span>]=p[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) f[i]+=p[j]*<span class="built_in">pow</span>(f[i<span class="number">-1</span>],j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %lf\n&quot;</span>,++cnt,<span class="built_in">pow</span>(f[m],k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>dp</tag>
        <tag>概率期望</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客迁移和同步管理</title>
    <url>/2019/02/08/hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%92%8C%E5%90%8C%E6%AD%A5%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>有一些代码需要牢记：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;some description&quot;</span><br><span class="line">git push origin hexo</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>还有，换新电脑的时候，要记得提交ssh密钥。</p>
<p><a href="https://www.jianshu.com/p/fceaf373d797">好的教程</a></p>
]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>[LOJ3276]遗迹</title>
    <url>/2020/03/25/LOJ3276-%E9%81%97%E8%BF%B9/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有<script type="math/tex">2n</script>个数，每个数在<script type="math/tex">[1,n]</script>之间，且<script type="math/tex">[1,n]</script>中每个数出现恰好两次。</p>
<p>进行<script type="math/tex">n</script>次操作，每次操作，对于每个<script type="math/tex">[1,n]</script>的数，如果数列中存在这个数，找出这个数出现在最右边的位置<script type="math/tex">x_0</script>，然后将除了<script type="math/tex">x_0</script>以外所有出现这个数的位置上的数减一。</p>
<p>那么，最后会剩下<script type="math/tex">n</script>个非零的数。现在给出最后这<script type="math/tex">n</script>个数的位置（只给位置，不知道数），问有多少种初始序列，使得经过<script type="math/tex">n</script>次操作后非<script type="math/tex">0</script>的数的位置是给定的这<script type="math/tex">n</script>个位置。</p>
<p>其中<script type="math/tex">n\le 600</script></p>
<p><strong>本题来源于JOISC2020 D2T3</strong>。</p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>非常巧妙的一道题。</p>
<p>首先考虑如果给你一个长度<script type="math/tex">2n</script>的序列，怎样判断最后留下来的是否是给定的<script type="math/tex">n</script>个位置。</p>
<p>我们可以通过以下代码进行检查</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> * n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = a[i]; j &gt;= <span class="number">1</span>; j--)</span><br><span class="line">        <span class="keyword">if</span>(!vis[j])</span><br><span class="line">        &#123;</span><br><span class="line">            vis[j] = flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<script type="math/tex">flag</script>为<script type="math/tex">true</script>，那么这个位置就会被保留。</p>
<p>这个东西的正确性比较明显，就是每次检查这个位置上的数到一的所有数，如果它右边已经有这个数被选择，那么它一定会减小，否则，说明它右边都没有出现这个数，它最后就是这个数。</p>
<p>我们考虑这段代码的另外一个意义：</p>
<p>有<script type="math/tex">2n</script>个人，还有<script type="math/tex">n</script>个座位，每个人依次来选座位，每个人有一个权值<script type="math/tex">a_i</script>，那么它会从第<script type="math/tex">a_i</script>个位置开始，如果这个位置为空，那么它就选择这个位置，否则就一直往前走，直到遇到一个空位，并选择它。如果一直找不到，这个人就出局。</p>
<p>那么，我们就来统计每个人初始选择序列<script type="math/tex">a_i</script>满足最后留下来的人为给定的<script type="math/tex">n</script>个人的序列个数。</p>
<p><strong>注意，以下的位置指的是座位位置，整个问题完全转化为坐座位问题，与原问题没有关系，不要混淆。</strong></p>
<p><strong>为了计算方便，我们把相同的两个数看成不同的，以便计算，在最后的时候除以<script type="math/tex">(2!)^n</script>即可。</strong></p>
<p>其实这个选座位的模型比较经典，我们考虑<script type="math/tex">dp</script>，这个<script type="math/tex">dp</script>的状态一点都不自然，记住就好：</p>
<p>设<script type="math/tex">f[i][j]</script>表示选了前<script type="math/tex">i</script>个人，目前座位前<script type="math/tex">j</script>个位置被选了，且第<script type="math/tex">j+1</script>个位置没选，其他位置情况不知道的方案数。</p>
<p>注意，这里我们并不考虑其他人的选择情况，只计算前<script type="math/tex">j</script>个位置上的人和出局的人的选择情况（出局的人一定选的是前<script type="math/tex">j</script>个中的一个，否则必定有位置选择）。</p>
<p>然后对于其他人选择情况，我们在他所在的那一段被拼接到整个前缀的时候再统计贡献（这个思想非常巧妙，现在读者也许不太明白，看后面就知道了）。</p>
<p>因为每个人是否留下题目已经给定了，现在我们考虑转移。</p>
<p>假设前<script type="math/tex">i</script>个人中，有<script type="math/tex">s_0</script>个出局的，<script type="math/tex">s_1</script>个留下来的。</p>
<p>那么我们现在考虑转移到<script type="math/tex">i+1</script>。</p>
<p>如果第<script type="math/tex">i+1</script>个人最后没有留下，那么说明这个人出局了，前面说了，这个人出局说明他的权值一定在前<script type="math/tex">j</script>个中，否则一定有位置坐。那么考虑他的选择方案，前<script type="math/tex">j</script>个位置有<script type="math/tex">2j</script>种权值选择（因为每个出现两次），去掉已经坐下来的<script type="math/tex">j</script>个人，再去掉出局的<script type="math/tex">s_0</script>个人（之前出局的人一定在前<script type="math/tex">j</script>个中），还剩<script type="math/tex">2j-j-s_0=j-s_0</script>个，那么此时转移方程就是</p>
<script type="math/tex; mode=display">
f[i+1][j]+=f[i][j]*(j-s_0)</script><p>再看另外一种情况，第<script type="math/tex">i+1</script>个人留下来了，那么他又有两种情况：</p>
<p>第一个，他最后没有出现在第<script type="math/tex">j+1</script>个位置上，根据我们状态的原则，不出现在当前前缀上的人的选择不予考虑（等到后面再考虑），因此</p>
<script type="math/tex; mode=display">
f[i+1][j]+=f[i][j]</script><p>第二个，他最后出现在第<script type="math/tex">j+1</script>个位置上，那么，他会增加<script type="math/tex">j</script>的值，换句话说，他会将当前的前缀<script type="math/tex">j</script>和某个段拼接起来。那么，我们枚举他后面那个段的长度<script type="math/tex">k</script>，那么他的贡献就是</p>
<script type="math/tex; mode=display">
f[i+1][j+k+1]+=f[i][j]*\binom{s_1-j}{k}*(k+2)*g[k]</script><p>这是什么意思？首先<script type="math/tex">\binom{s_1-j}{k}</script>指的是后面那个长度为<script type="math/tex">k</script>的段的人具体是什么的选择方案数，而当前第<script type="math/tex">i+1</script>个人的选择，有<script type="math/tex">2k-k+2=k+2</script>种选择（可以就是<script type="math/tex">j+1</script>，有两种选择，还可以是后面的段中的某个，有<script type="math/tex">2k-k</script>种选择）。那么，<script type="math/tex">g[k]</script>是什么？<script type="math/tex">g[k]</script>指的是后面这一段中，这<script type="math/tex">k</script>个人在<script type="math/tex">2k</script>个数中安排为其中<script type="math/tex">k</script>个数，使得按人的顺序放最后没有人出局的方案数。</p>
<p>这个看起来没有什么直接的算法（听<script type="math/tex">qty</script>大佬说是<script type="math/tex">C_{k+1}n!</script>，不会不会）。</p>
<p>我们考虑用<script type="math/tex">dp</script>来计算这个问题。</p>
<p>这个问题可以转化为有<script type="math/tex">n</script>个人，在<script type="math/tex">2n</script>个数（每个<script type="math/tex">[1,n]</script>的数出现<script type="math/tex">2</script>次）中选<script type="math/tex">n</script>个数，使得最后没有人出局的方案数。</p>
<p>一般这种有两个维度的问题（人，数），我们都从另外一个角度进行<script type="math/tex">dp</script>（正着角度是人选数，另外一个就是数选人）。</p>
<p>一开始的想法是从小到大考虑数选人，但是后面选的数的位置会影响到前面选的数的位置，所以更容易的想法是从大到小地考虑数选人，因为我们假设已经考虑了前<script type="math/tex">i</script>大的数，那么选择的座位一定是一个后缀（因为要求没有人出局），更容易思考。</p>
<p>我们考虑目前选的人的相对顺序，然后考虑当前数选的人往前面选的人里插，这是常见思路。</p>
<p>设<script type="math/tex">g[i][j]</script>表示处理完前<script type="math/tex">i</script>大的数，选了<script type="math/tex">j</script>个数的方案数。</p>
<p>那么当前这个数，有三种选择：</p>
<p>第一种，一个都不选，直接过，即<script type="math/tex">g[i+1][j]+=g[i][j]</script>。</p>
<p>第二种，我们选其中一个，插入到原来人的序列中，因为我们是从大往小考虑的，所以不管插在哪个位置，只要选的是<script type="math/tex">\le n</script>个人，一定是合法的（即不会有人没位置）。因为有<script type="math/tex">j</script>个人，所以有<script type="math/tex">j+1</script>种插空方法，所以</p>
<script type="math/tex; mode=display">
g[i+1][j+1]+=g[i][j]*(j+1)*2</script><p>因为这个数有两个，所以任选一个乘以<script type="math/tex">2</script>。</p>
<p>第三种，我们两个都选，那么一样不管插在哪个位置，只要选<script type="math/tex">\le n</script>个人都合法，第一个有<script type="math/tex">j+1</script>个空可插，第二个有<script type="math/tex">j+2</script>个空可插，所以</p>
<script type="math/tex; mode=display">
g[i+1][j+2]+=g[i][j]*(j+1)*(j+2)</script><p>那么我们需要的就是<script type="math/tex">g[k][k]</script>了！</p>
<p>这样一来，整道题就做完了，不要忘记最后还要除以<script type="math/tex">2^n</script>。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">1205</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>, I = <span class="number">5e8</span> + <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f[maxN + <span class="number">1</span>][maxN + <span class="number">1</span>], g[maxN + <span class="number">1</span>][maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> C[maxN + <span class="number">1</span>][maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> flag[maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ADD</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y &gt;= mod ? x + y - mod : x + y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            C[i][j] = <span class="built_in">ADD</span>(C[i - <span class="number">1</span>][j], C[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            g[i + <span class="number">1</span>][j] = <span class="built_in">ADD</span>(g[i + <span class="number">1</span>][j], g[i][j]);</span><br><span class="line">            <span class="keyword">if</span>(j + <span class="number">1</span> &lt;= n) g[i + <span class="number">1</span>][j + <span class="number">1</span>] = <span class="built_in">ADD</span>(g[i + <span class="number">1</span>][j + <span class="number">1</span>], <span class="number">2ll</span> * (j + <span class="number">1</span>) * g[i][j] % mod);</span><br><span class="line">            <span class="keyword">if</span>(j + <span class="number">2</span> &lt;= n) g[i + <span class="number">1</span>][j + <span class="number">2</span>] = <span class="built_in">ADD</span>(g[i + <span class="number">1</span>][j + <span class="number">2</span>], <span class="number">1ll</span> * (j + <span class="number">1</span>) * (j + <span class="number">2</span>) * g[i][j] % mod);	</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        flag[<span class="number">2</span> * n - x + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pre</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> s0 = <span class="number">0</span>, s1 = <span class="number">0</span>;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!flag[i + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = s0; j &lt;= s1; j++)</span><br><span class="line">                f[i + <span class="number">1</span>][j] = <span class="built_in">ADD</span>(f[i + <span class="number">1</span>][j], <span class="number">1ll</span> * f[i][j] * (j - s0) % mod);</span><br><span class="line">            s0 ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = s0; j &lt;= s1; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i + <span class="number">1</span>][j] = <span class="built_in">ADD</span>(f[i + <span class="number">1</span>][j], f[i][j]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= s1 - j; k++)</span><br><span class="line">                    f[i + <span class="number">1</span>][j + k + <span class="number">1</span>] = <span class="built_in">ADD</span>(f[i + <span class="number">1</span>][j + k + <span class="number">1</span>], <span class="number">1ll</span> * f[i][j] * C[s1 - j][k] % mod * g[k][k] % mod * (k + <span class="number">2</span>) % mod);</span><br><span class="line">            &#125;</span><br><span class="line">            s1 ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = f[<span class="number">2</span> * n][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = <span class="number">1ll</span> * ans * I % mod;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以后遇到这种计数题，可以先考虑怎样判定一个最终状态（或初始状态）是否满足条件，可以简化许多问题。</p>
<p>遇到有相同数的时候，有时将它们看成不同的，最后再除以<script type="math/tex">k!</script>，会使问题简化，一定要想到这一点。</p>
<p>遇到这种选座位模型的题目，要想想那个奇怪的状态定义<script type="math/tex">f[i][j]</script>表示处理了前<script type="math/tex">i</script>个人，选座位的前缀是<script type="math/tex">j</script>，这样的好处是如果某个人出局，那么他选的一定是前<script type="math/tex">j</script>个里面的一个。主要难点在于考虑每次考虑合并前缀和某一段。</p>
<p>我们遇到有两个维度相关的问题，一般不从题目给的角度来考虑，而从另外的一个角度考虑，有时问题就迎刃而解。</p>
<p>一定熟练掌握考虑选择东西的相对顺序，后面选的往前面插的思路，有时能解决许多问题。</p>
<p>有一些限制的时候，我们将限制从小往大这样考虑问题，这样的话前面选的数一定符合后面的限制，选择的时候可以直接排除，无需顾虑太多。</p>
]]></content>
      <categories>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>[UOJ22]外星人</title>
    <url>/2020/03/31/UOJ22-%E5%A4%96%E6%98%9F%E4%BA%BA/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有<script type="math/tex">n</script>个数<script type="math/tex">a_i</script>，给定初始值<script type="math/tex">m</script>，你要决定一种排列顺序<script type="math/tex">p_1,p_2,...,p_n</script>，使得</p>
<script type="math/tex; mode=display">
m\%a_{p_1}\%a_{p_2}...\%a_{p_n}</script><p>的值最大，输出最大值，并输出有多少种排列顺序使得最后的值是这个最大值。</p>
<p>其中<script type="math/tex">n\le 1000,m,a_i\le 5000</script>。</p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>很好的一道题。</p>
<p>首先注意到我们只需要解决第二个问题即可。</p>
<p>注意到，最终序列中如果一个数字前面存在比它小的数，那么这个数必然是没有用的。</p>
<p>我们考虑留下来哪些数（即可能有用的数），留下来的数必然是单调减的，所以我们可以从大往小进行<script type="math/tex">dp</script>。</p>
<p>可是如果直接这样<script type="math/tex">dp</script>还是不好算，那么我们有一个十分重要的思想：<strong>计数转概率</strong>。</p>
<h2 id="计数转概率"><a href="#计数转概率" class="headerlink" title="计数转概率"></a>计数转概率</h2><p>我们通常是将概率转成计数，但是有的时候，特别是有关排列的时候，更好算的是概率，因为我们只需要把我们要的数单独拿出来考虑，别的可以随便选。</p>
<p>我们来看这样一题，我们给<script type="math/tex">n</script>组数，对于所有数的排列，要求每组某个数在这一组的第一个，问方案数。</p>
<p>那么我们考虑因为每组是独立的，而第<script type="math/tex">i</script>组的某个数在这一组第一个的概率是<script type="math/tex">\frac{1}{s_i}</script>（<script type="math/tex">s_i</script>是这个组的元素个数），那么所有条件都满足的概率就是<script type="math/tex">\prod \frac{1}{s_i}</script>，那么最后的答案就是<script type="math/tex">(\sum s_i)!\prod\frac{1}{s_i}</script>。</p>
<p>所以我们遇到这样一类排列问题时，而<strong>条件互不相交或相互包含</strong>的情况下，可以将计数转为概率计算，会简便很多。</p>
<hr>
<p>那么，我们再来看这道题。</p>
<p>我们设<script type="math/tex">f[i][j]</script>表示处理完前<script type="math/tex">i</script>大的数以后剩下的数字是<script type="math/tex">j</script>的概率。</p>
<p>我们考虑转移，对于当前数<script type="math/tex">a[i]</script>，有两种可能，一种是我们把它留下来，考虑最后序列把它留下来的唯一条件是<strong>它前面没有比它小的数</strong>，也就是说，它是后<script type="math/tex">n-i+1</script>个数中第一个出现的，那么这个概率就是<script type="math/tex">\frac{1}{n-i+1}</script>；否则，如果我们不把它留下来，那么唯一的条件就是<strong>它前面出现过比它小的数</strong>，那么相应的概率也就是<script type="math/tex">1-\frac{1}{n-i+1}</script>，然后直接转移即可。</p>
<p>最后统计答案不用多说，用总排列数乘以概率即可。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">5005</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> f[maxN + <span class="number">1</span>][maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> inv[maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ADD</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y &gt;= mod ? x + y - mod : x + y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">SUB</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x - y &lt; <span class="number">0</span> ? x - y + mod : x - y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) inv[i] = mod - <span class="number">1ll</span> * (mod / i) * inv[mod % i] % mod;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>][m] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">            f[i + <span class="number">1</span>][j] = <span class="built_in">ADD</span>(f[i + <span class="number">1</span>][j], <span class="number">1ll</span> * f[i][j] * <span class="built_in">SUB</span>(<span class="number">1</span>, inv[n - i]) % mod),</span><br><span class="line">            f[i + <span class="number">1</span>][ j % a[i + <span class="number">1</span>] ] = <span class="built_in">ADD</span>(f[i + <span class="number">1</span>][ j % a[i + <span class="number">1</span>] ], <span class="number">1ll</span> * f[i][j] * inv[n - i] % mod);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = <span class="number">1ll</span> * ans * i % mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span>(f[n][i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="number">1ll</span> * ans * f[n][i] % mod);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个计数转概率的思想非常重要，一定要牢记。</p>
<p>遇到排列问题，如果不好处理，一定要往概率上想一想，如果条件不相交或者包含，就要想到概率解决。</p>
<p>如本题，即条件互相包含的例子。</p>
]]></content>
      <categories>
        <category>UOJ</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>概率期望</tag>
      </tags>
  </entry>
  <entry>
    <title>分治FFT详解</title>
    <url>/2019/02/18/%E5%88%86%E6%B2%BBFFT%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="什么是分治FFT"><a href="#什么是分治FFT" class="headerlink" title="什么是分治FFT"></a>什么是分治FFT</h1><p>分治FFT用于快速计算这样一类式子：</p>
<script type="math/tex; mode=display">
f[n]=\sum_{i=0}^{n-1}f[i]g[n-i]</script><p>与普通的FFT不同，这个式子是用自己来更新自己，所以如果暴力用FFT，时间复杂度为<script type="math/tex">O(n^2logn)</script>，因此，我们考虑用分治FFT来解决这类问题。</p>
<span id="more"></span>
<h1 id="分治FFT的实现"><a href="#分治FFT的实现" class="headerlink" title="分治FFT的实现"></a>分治FFT的实现</h1><p>分治，指的就是cdq分治（运用的是这种思想）：</p>
<p>就是我们考虑先计算出<script type="math/tex">f[l],f[l+1],...,f[mid]</script>的值，再计算它对<script type="math/tex">f[mid+1],...,f[r]</script>的贡献，最终完成计算。</p>
<p>由于计算l~mid的值是递归的事情，所以我们只要考虑<script type="math/tex">f[l...mid]</script>对于<script type="math/tex">f[mid+1...r]</script>的贡献即可。</p>
<p>首先，我们考虑，在<script type="math/tex">[mid+1,r]</script>的每一个数<script type="math/tex">x</script>,<script type="math/tex">[l,mid]</script>区间对其贡献为：</p>
<script type="math/tex; mode=display">
w[x]=\sum_{i=l}^{mid}f[i]g[x-i]</script><p>我们将求和的范围扩大到<script type="math/tex">[l,x-1]</script>，因为<script type="math/tex">f[mid+1]->f[x-1]</script>都是0，所以对式子的值并无影响。</p>
<script type="math/tex; mode=display">
w[x]=\sum_{i=l}^{x-1}f[i]g[x-i]</script><p>这时，我们考虑计算右边那个式子，我们可以设<script type="math/tex">a[i]=f[i+l],b[i]=g[i+1]</script></p>
<p>这个式子就变化为</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{x-l-1}a[i]b[x-l-1-i]</script><p>由卷积的知识可以得知，这个式子可以看成</p>
<script type="math/tex; mode=display">
c[x-l-1]=\sum_{i=0}^{x-l-1}a[i]b[x-l-1-i]</script><p>这个式子，就可以用FFT来完成了。结合上面那个<script type="math/tex">w[x]</script>的式子，可以得到：</p>
<script type="math/tex; mode=display">
w[x]=c[x-l-1]=\sum_{i=0}^{x-l-1}a[i]b[x-l-1-i]</script><p>所以，我们在做完卷积之后，直接：</p>
<script type="math/tex; mode=display">
w[x]=a[x-l-1](a为卷积后的数组)</script><p>最后，将贡献加上去就可以了：</p>
<script type="math/tex; mode=display">
f[x]+=w[x]，即f[x]+=a[x-l-1]</script><p>因此，我们所需要计算的数组的长度为<script type="math/tex">r-l-1</script>，时间复杂度为<script type="math/tex">O(nlog^2n)</script></p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">1</span> &lt;&lt; <span class="number">20</span> | <span class="number">5</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[maxN + <span class="number">1</span>], b[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> A[maxN + <span class="number">1</span>], B[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> wn[maxN + <span class="number">1</span>], R[maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>( !<span class="built_in">isdigit</span>( ch ) ) &#123; <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">isdigit</span>( ch ) ) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> num * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ADD</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y &gt;= mod ? x + y - mod : x + y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">SUB</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x - y &lt; <span class="number">0</span> ? x - y + mod : x - y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>) ans = <span class="number">1ll</span> * ans * a % mod;</span><br><span class="line">        a = <span class="number">1ll</span> * a * a % mod;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lim = <span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(lim &lt;= <span class="number">2</span> * n) lim &lt;&lt;= <span class="number">1</span>, cnt ++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> W = <span class="built_in">mpow</span>(<span class="number">3</span>, (mod - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        wn[mid] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; mid; j++) wn[mid + j] = <span class="number">1ll</span> * wn[mid + j - <span class="number">1</span>] * W % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> type, <span class="keyword">int</span> lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; R[i]) <span class="built_in">swap</span>(a[i], a[ R[i] ]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i += (mid &lt;&lt; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x = a[i + j], y = <span class="number">1ll</span> * a[i + mid + j] * wn[mid + j] % mod;</span><br><span class="line">                a[i + j] = <span class="built_in">ADD</span>(x, y); a[i + mid + j] = <span class="built_in">SUB</span>(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">if</span>(type == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> INV = <span class="built_in">mpow</span>(lim, mod - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++) a[i] = <span class="number">1ll</span> * a[i] * INV % mod;</span><br><span class="line">        <span class="built_in">reverse</span>(a + <span class="number">1</span>, a + lim);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">solve</span>(l, mid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= mid; i++) A[i - l] = a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r - l; i++) B[i - <span class="number">1</span>] = b[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lim = <span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(lim &lt;= r - l + mid - l + <span class="number">1</span>) lim &lt;&lt;= <span class="number">1</span>, cnt ++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; cnt - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NTT</span>(A, <span class="number">1</span>, lim); <span class="built_in">NTT</span>(B, <span class="number">1</span>, lim);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++) A[i] = <span class="number">1ll</span> * A[i] * B[i] % mod;</span><br><span class="line">    <span class="built_in">NTT</span>(A, <span class="number">-1</span>, lim);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = mid - l; i &lt;= r - l - <span class="number">1</span>; i++) a[i + l + <span class="number">1</span>] = <span class="built_in">ADD</span>(a[i + l + <span class="number">1</span>], A[i]);	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">solve</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) b[i] = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pre</span>();</span><br><span class="line">    </span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>伯努利数相关</title>
    <url>/2019/06/26/%E4%BC%AF%E5%8A%AA%E5%88%A9%E6%95%B0%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="伯努利数"><a href="#伯努利数" class="headerlink" title="伯努利数"></a>伯努利数</h1><p>伯努利数，是用于解决自然数幂和的一类数，并没有一定的组合意义，其通过生成函数定义如下：</p>
<script type="math/tex; mode=display">
\sum_{i\ge 0}B_i\frac{t^i}{i!}=\frac{t}{e^t-1}</script><p>其中，<script type="math/tex">B_i</script>是第<script type="math/tex">i</script>个伯努利数。</p>
<p>另外，还有伯努利多项式，定义</p>
<script type="math/tex; mode=display">
B_n(x)=\sum_{i=0}^n\binom{n}{i}B_ix^{n-i}</script><p>关于伯努利多项式也有一个生成函数定义：</p>
<script type="math/tex; mode=display">
\sum_{i\ge 0}B_i(x)\frac{t^i}{i!}=\frac{te^{xt}}{e^t-1}</script><span id="more"></span>
<h1 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h1><p>那么，怎么求伯努利数呢？</p>
<p>首先，根据定义，我们显然可以通过多项式求逆来求得伯努利数，时间复杂度<script type="math/tex">O(n\log_2n)</script>。</p>
<p>但是，更常见的求法来自以下推导。</p>
<script type="math/tex; mode=display">
[t^n](\sum_{i\ge0}B_i\frac{t^i}{i!})(e^t-1)=[t^n]\frac{t}{e^t-1}(e^t-1)\\
[t^n](\sum_{i\ge0}B_i\frac{t^i}{i!})(e^t-1)=[n=1]\\
[t^n](\sum_{i\ge0}B_i\frac{t^i}{i!})t(\sum_{j\ge0}\frac{t^j}{(j+1)!})=[n=1]\\
\sum_{i+j=n-1}B_i\frac{1}{i!(j+1)!}=[n=1]\\
\sum_{i=0}^{n-1}\binom{n}{i}B_i=[n=1]*n!\\
\sum_{i=0}^{n-1}\binom{n}{i}B_i=[n=1]</script><p>用<script type="math/tex">n</script>代<script type="math/tex">n-1</script>，可得</p>
<script type="math/tex; mode=display">
\sum_{i=0}^n\binom{n+1}{i}B_i=0\quad(i\ge1) \\
B_0=1</script><p>据此，我们可以递推地算出<script type="math/tex">B</script>。</p>
<h1 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h1><p>众所周知，伯努利数是求自然数幂和的。</p>
<p>下面我们设</p>
<script type="math/tex; mode=display">
S_k(n)=\sum_{i=0}^ni^k</script><p>那么我们有</p>
<script type="math/tex; mode=display">
\sum_{k\ge0}S_k(n)\frac{x^k}{k!}=\sum_{k\ge0}\sum_{i=0}^ni^k\frac{x^k}{k!}\\
=\sum_{i=0}^n\sum _{k\ge0}\frac{(ix)^k}{k!}=\sum_{i=0}^ne^{ix}=\frac{e^{(n+1)x}-1}{e^x-1}</script><p>我们发现给这个式子乘上一个<script type="math/tex">x</script>就和上面伯努利数的生成函数以及伯努利数多项式的生成函数很像。我们给这个式子乘上一个<script type="math/tex">x</script>，那么有</p>
<script type="math/tex; mode=display">
x\frac{e^{(n+1)x}-1}{e^x-1}=\frac{xe^{(n+1)x}}{e^x-1}-\frac{x}{e^x-1}</script><p>将伯努利数以及伯努利数多项式带入可得</p>
<script type="math/tex; mode=display">
\frac{xe^{(n+1)x}}{e^x-1}-\frac{x}{e^x-1}\\=\sum_{i\ge0}B_i(n+1)\frac{x^i}{i!}-\sum_{i\ge0}B_i\frac{x^i}{i!}\\
=\sum_{i\ge0}\sum_{j=0}^iB_j\binom{i}{j}(n+1)^{i-j}\frac{x^i}{i!}-\sum_{i\ge0}B_i\frac{x^i}{i!}\\
=\sum_{i\ge0}(\sum_{j=0}^iB_j\binom{i}{j}(n+1)^{i-j}-B_i)\frac{x^i}{i!}</script><p>而</p>
<script type="math/tex; mode=display">
\frac{S_k(n)}{k!}=[x^{k+1}]\frac{xe^{(n+1)x}-1}{e^x-1}-\frac{x}{e^x-1}</script><p>故有</p>
<script type="math/tex; mode=display">
S_k(n)=\frac{1}{k+1}(\sum_{i=0}^{k+1}\binom{k+1}{i}B_i(n+1)^{k+1-i}-B_{k+1})\\
=\frac{1}{k+1}\sum_{i=0}^{k}\binom{k+1}{i}B_i(n+1)^{k+1-i}</script><p>这就是伯努利数求自然数幂和的式子了，如果<script type="math/tex">n</script>很大，但<script type="math/tex">k</script>很小，我们就可以应用这种方法。</p>
<p>另外，还有一种求自然数交错和的数，即求<script type="math/tex">T_k(n)=\sum_{i=0}^n(-1)^ii^k</script>的数，称为欧拉数，但是所用较少，读者若有兴趣，可以自行了解。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式牛顿迭代及相关</title>
    <url>/2020/01/15/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E5%8F%8A%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="泰勒公式"><a href="#泰勒公式" class="headerlink" title="泰勒公式"></a>泰勒公式</h1><p><strong>多项式牛顿迭代</strong>是很多多项式有关算法的基础，而要了解<strong>多项式牛顿迭代</strong>，首先要知道泰勒展开公式。</p>
<p>泰勒公式定义如下：</p>
<p>如果<script type="math/tex">f(x)</script>在某个包含<script type="math/tex">x_0</script>的闭区间<script type="math/tex">[a,b]</script>存在<script type="math/tex">n</script>阶导数，且在开区间<script type="math/tex">(a,b)</script>上存在<script type="math/tex">n+1</script>阶导数，则对于<script type="math/tex">[a,b]</script>中任意一点<script type="math/tex">x</script>，有如下式子成立</p>
<script type="math/tex; mode=display">
f(x)=\frac{f(x_0)}{0!}+\frac{f'(x_0)}{1!}(x-x_0)+...+\frac{f^{n}(x_0)}{n!}(x-x_0)^n+R_n(x)</script><p>这个<script type="math/tex">R_n(x)</script>指的是一个余项。</p>
<span id="more"></span>
<p>这个公式怎么证明，我也不太会，总之，记住就好了。</p>
<p>那么，这个泰勒公式和<strong>多项式牛顿迭代</strong>有什么关系呢？</p>
<h1 id="多项式牛顿迭代"><a href="#多项式牛顿迭代" class="headerlink" title="多项式牛顿迭代"></a>多项式牛顿迭代</h1><p>多项式牛顿迭代指的是：</p>
<p>我们知道<script type="math/tex">G(x)</script>的表达式，要求解<script type="math/tex">G(F(x)) \equiv 0\pmod {x^n}</script>。</p>
<p>换句话说，我们已知<script type="math/tex">G(x)</script>，<script type="math/tex">G(F(x)) \equiv 0\pmod{x^n}</script>，我们要求<script type="math/tex">F(x)</script>在<script type="math/tex">\bmod x^n</script>下的表达式。</p>
<p>类似多项式求逆的思想，</p>
<p>我们假设已知<script type="math/tex">F_0(x)</script>满足<script type="math/tex">G(F_0(x))\equiv 0\pmod {x^{\frac{n}{2}}}</script>。</p>
<p><strong>注意，这里简写的<script type="math/tex">\frac{n}{2}</script>实际上是上取整，即<script type="math/tex">\lceil \frac{n}{2}\rceil</script>，以下所有的<script type="math/tex">\frac{n}{2}</script>均指上取整。</strong></p>
<p>我们考虑<script type="math/tex">G(F(x))</script>在<script type="math/tex">F_0(x)</script>处的泰勒展开：</p>
<script type="math/tex; mode=display">
G(F(x))\equiv G(F_0(x))+\frac{G'(F_0(x))}{1!}(F(x)-F_0(x))\\+\frac{G''(F_0(x))}{2!}(F(x)-F_0(x))^2+...\pmod{x^n}</script><p>我们观察<script type="math/tex">(F(x)-F_0(x))^2</script>，由定义可知，<script type="math/tex">F(x)</script>和<script type="math/tex">F_0(x)</script>前<script type="math/tex">\frac{n}{2}-1</script>项是相同的，那么<script type="math/tex">F(x)-F_0(x)</script>第一个非零之处是第<script type="math/tex">\frac{n}{2}</script>项，而平方一下就是第<script type="math/tex">n</script>项（因为上取整，所以也有可能是第<script type="math/tex">n+1</script>项），此时我们发现，因为是在<script type="math/tex">\bmod x^n</script>意义下进行，所以这一项是没有用的。也就是说，在二阶导及其后面的所有项在<script type="math/tex">\bmod x^n</script>下都是<script type="math/tex">0</script>，可以直接省略！</p>
<p>那么，式子就变成了</p>
<script type="math/tex; mode=display">
G(F(x))\equiv G(F_0(x))+G'(F_0(x))(F(x)-F_0(x))\pmod{x^n}</script><p>而我们知道<script type="math/tex">G(F(x))\equiv 0\pmod{x^n}</script>，所以我们有</p>
<script type="math/tex; mode=display">
F(x)\equiv F_0(x)-\frac{G(F_0(x))}{G'(F_0(x))}\pmod{x^n}</script><p>这个，就是多项式牛顿迭代的式子。</p>
<p><strong>值得注意的是，因为我们考虑的是<script type="math/tex">G(F(x))</script>在<script type="math/tex">F_0(x)</script>处的泰勒展开，整个过程相当于用<script type="math/tex">F(x)</script>代替了<script type="math/tex">x</script>，因此，我们在求导时，把<script type="math/tex">F(x)</script>看成变量而不是一个函数，而与<script type="math/tex">F(x)</script>无关的量不管是不是一个多项式都看成一个常数，这一点会在后面的<script type="math/tex">exp</script>中得到体现。</strong></p>
<p>然而，求解这个东西也需要前置知识，下面，我们先讲一些基础。</p>
<h1 id="多项式求逆"><a href="#多项式求逆" class="headerlink" title="多项式求逆"></a>多项式求逆</h1><p>什么是多项式求逆？</p>
<p>类似求整数逆元，有的时候，我们要求已知<script type="math/tex">A(x)</script>，我们要求<script type="math/tex">B(x)</script>，满足<script type="math/tex">B(x)A(x)\equiv 1\pmod{x^n}</script>，</p>
<p>我们假设我们已经知道<script type="math/tex">B_0(x)A(x)\equiv 1\pmod{x^{\frac{n}{2}}}</script>，同样地，这里也是上取整。</p>
<p>下面，我们来推式子：</p>
<script type="math/tex; mode=display">
B_0(x)A(x)-1\equiv 0\pmod{x^{\frac{n}{2}}}\\
B_0^2(x)A^2(x)-2B_0(x)A(x)+1\equiv 0\pmod{x^{n}}</script><p>注意到<script type="math/tex">B(x)A(x)\equiv 1\pmod{x^n}</script>，</p>
<script type="math/tex; mode=display">
B_0^2(x)A^2(x)-2B_0(x)A(x)+B(x)A(x)\equiv 0\pmod{x^n}\\
B_0^2(x)A(x)-2B_0(x)+B(x)\equiv 0\pmod{x^n}\\
B(x)\equiv B_0(x)(2-A(x)B_0(x))\pmod{x^n}</script><p>就这样一直迭代，每次用一下<script type="math/tex">NTT</script>，就好了。</p>
<p>复杂度<script type="math/tex">O(nlog_2n)</script>。</p>
<p>证明？</p>
<p>考虑每一次迭代长度为<script type="math/tex">deg</script>，那么复杂度为<script type="math/tex">deglog_2deg</script></p>
<p>总的复杂度为</p>
<script type="math/tex; mode=display">
\sum deglog_2deg</script><p>我们把<script type="math/tex">log_2deg</script>看得大一点，都看成<script type="math/tex">log_2n</script></p>
<p>那么式子就变为</p>
<script type="math/tex; mode=display">
log_2n*\sum deg</script><p>后面那项相当于<script type="math/tex">n+n/2+n/4+...=2n</script>，所以复杂度为<script type="math/tex">O(nlog_2n)</script></p>
<h1 id="多项式求导"><a href="#多项式求导" class="headerlink" title="多项式求导"></a>多项式求导</h1><p>因为<script type="math/tex">(x^n)'=nx^{n-1}</script></p>
<p>所以</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i - <span class="number">1</span>] = i * a[i];</span><br></pre></td></tr></table></figure>
<h1 id="多项式积分"><a href="#多项式积分" class="headerlink" title="多项式积分"></a>多项式积分</h1><p>因为<script type="math/tex">\int x^n=\frac{1}{n+1}x^{n+1}</script></p>
<p>所以</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) a[i + <span class="number">1</span>] = a[i] * inv[i + <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>但是注意，我们无法知道常数项。</p>
<h1 id="多项式求ln"><a href="#多项式求ln" class="headerlink" title="多项式求ln"></a>多项式求ln</h1><p>给定多项式<script type="math/tex">A(x)</script>，我们现在要求<script type="math/tex">B(x)\equiv ln(A(x))\pmod{x^n}</script>。</p>
<p>怎么求呢？</p>
<p>我们先推式子</p>
<script type="math/tex; mode=display">
B'(x)\equiv \frac{1}{A(x)}*A'(x)\pmod{x^n}\\
B'(x)\equiv \frac{A'(x)}{A(x)}\pmod{x^n}</script><p>那么，我们将<script type="math/tex">A(x)</script>求导，再求逆，然后两个乘起来就得到了<script type="math/tex">\frac{A'(x)}{A(x)}</script>，也就是<script type="math/tex">G'(x)</script>，然后由于</p>
<script type="math/tex; mode=display">
B(x)\equiv \int B'(x)</script><p>所以最后再求个积分即可。</p>
<p>但是，我们这样会丢失常数项，所以常数项我们要手算，一般题目会给定<script type="math/tex">a_0=1</script>，因为这样<script type="math/tex">ln1=0</script>比较好算。</p>
<p>这个贴代码太影响观看体验了，就不贴代码了吧。</p>
<h1 id="多项式exp"><a href="#多项式exp" class="headerlink" title="多项式exp"></a>多项式exp</h1><p>一般来说，题目中要对生成函数进行什么操作，都是<script type="math/tex">ln</script>和<script type="math/tex">exp</script>复合再一起的，所以一般<script type="math/tex">ln</script>和<script type="math/tex">exp</script>放在一起用。</p>
<p>什么是多项式<script type="math/tex">exp</script>？</p>
<p>给定多项式<script type="math/tex">A(x)</script>，求<script type="math/tex">B(x)\equiv e^{A(x)}\pmod{x^n}</script>。</p>
<p>这个时候，多项式牛顿迭代就派上用场了。</p>
<p>考虑到<script type="math/tex">e</script>非常不好处理，我们两边取<script type="math/tex">ln</script></p>
<script type="math/tex; mode=display">
ln(B(x))\equiv A(x)\pmod{x^n}\\
ln(B(x))-A(x)\equiv 0\pmod{x^n}</script><p>那么，我们设<script type="math/tex">G(x)=ln(x)-A(x)</script>，<script type="math/tex">F(x)=B(x)</script>，那么我们就满足</p>
<script type="math/tex; mode=display">
G(F(x))\equiv 0\pmod{x^n}</script><p>且<script type="math/tex">G(x)</script>已知。</p>
<p>那么，我们就按照多项式牛顿迭代</p>
<script type="math/tex; mode=display">
F(x)\equiv F_0(x)-\frac{G(F_0(x))}{G'(F_0(x))}\pmod{x^n}</script><p>下面，我们来看<script type="math/tex">G'(F_0(x))</script>是什么？</p>
<p><strong>注意，这里的求导是对<script type="math/tex">F_0(x)</script>求导而不是对<script type="math/tex">x</script>求导，因此，式子中的<script type="math/tex">F_0(x)</script>被看成变量，而不是函数，而<script type="math/tex">A(x)</script>则被看成常数。</strong></p>
<p>因此，</p>
<script type="math/tex; mode=display">
G'(F_0(x))=\frac{1}{F_0(x)}</script><p>所以</p>
<script type="math/tex; mode=display">
F(x)\equiv F_0(x)(1-ln(F_0(x))+A(x))</script><h1 id="多项式开方"><a href="#多项式开方" class="headerlink" title="多项式开方"></a>多项式开方</h1><p>当然，你可以选择<script type="math/tex">ln</script>之后<script type="math/tex">exp</script>，但是实际上牛顿迭代就可以解决。</p>
<p>给定<script type="math/tex">A(x)</script>，我们要求<script type="math/tex">B(x)\equiv \sqrt{A(x)}\pmod{x^n}</script>。</p>
<p>首先转化为牛顿迭代形式<script type="math/tex">B^2(x)-A(x)\equiv 0\pmod{x^n}</script>。</p>
<p>令<script type="math/tex">F(x)=B(x)</script>，<script type="math/tex">G(F(x))=F^2(x)-A(x)</script>。</p>
<p>那么</p>
<script type="math/tex; mode=display">
G'(F_0(x))=2F_0(x)</script><p>根据牛顿迭代</p>
<script type="math/tex; mode=display">
F(x)\equiv F_0(x)-\frac{G(F_0(x))}{G'(F_0(x))}\pmod{x^n}\\
F(x)\equiv F_0(x)-\frac{F_0^2(x)-A(x)}{2F_0(x)}\pmod{x^n}\\
F(x)\equiv \frac{1}{2}(F_0(x)+\frac{A(x)}{F_0(x)})\pmod{x^n}</script><p>然后直接多项式求逆牛顿迭代即可。</p>
<p>注意，不管怎么牛顿迭代（包括这里我们在牛顿迭代求开方的时候还要牛顿迭代求<script type="math/tex">ln</script>）时间复杂度都是<script type="math/tex">O(nlog_2n)</script>。</p>
<p>因为都是<script type="math/tex">T(n)=T(\frac{n}{2})+O(nlog_2n)</script>。</p>
<h1 id="多项式快速幂"><a href="#多项式快速幂" class="headerlink" title="多项式快速幂"></a>多项式快速幂</h1><p>给定<script type="math/tex">A(x),k</script>，求<script type="math/tex">B(x)\equiv A^k(x)\pmod{x^n}</script></p>
<p>这个不用多说，先取<script type="math/tex">ln</script>，乘以<script type="math/tex">k</script>，然后<script type="math/tex">exp</script>。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>Rikka with Game解题报告</title>
    <url>/2021/01/19/Rikka-with-Game%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有<script type="math/tex">n</script>个人玩游戏，有些人是朋友关系（用邻接矩阵给出）。</p>
<p>游戏开始时，先选一个人成为龙，剩下的人为勇士。</p>
<p>每轮游戏过程如下：每个勇士选择是否攻击龙，如果这个勇士和龙有朋友关系那么一定不会攻击。如果所有勇士都不攻击，游戏结束，龙胜利。否则龙被淘汰，且编号最小的选择攻击的勇士成为新的龙，游戏进入下一轮。</p>
<p>游戏结束后，被淘汰的玩家获得<script type="math/tex">1</script>分，活着的勇士获得<script type="math/tex">10</script>分，活着的龙获得<script type="math/tex">100</script>分。</p>
<p>假设每个玩家足够聪明，都想最大化自己分数。现在，对于每个玩家，你要回答：如果第一轮选的龙是他，他是否能获得<script type="math/tex">100</script>分。</p>
<p>其中<script type="math/tex">n\le 500</script>。<br><span id="more"></span></p>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先注意到游戏最多只会进行两轮。</p>
<p>因为每个玩家都足够聪明，所以每个玩家都能预测出整个游戏的过程。那么，第一轮中，一个勇士选择攻击龙当且仅当在下一轮中他能成为龙且在下一轮中获胜。</p>
<p>如果他选择攻击龙之后在下一轮中成为龙并且失败了，那么他只能获得<script type="math/tex">1</script>分，如果他什么都不干，能获得<script type="math/tex">10</script>分，因此只有当他确定下一轮他成为龙且必胜时，他才会选择攻击龙。</p>
<p>遇到这种博弈论问题，我们可以设计出<script type="math/tex">dp</script>。设<script type="math/tex">f(s,i)</script>表示勇士的集合为<script type="math/tex">s</script>，且当前龙是<script type="math/tex">i</script>，这一轮中龙能否获胜。</p>
<p>转移考虑枚举<script type="math/tex">s</script>中的每个元素<script type="math/tex">j</script>，如果<script type="math/tex">i,j</script>不是朋友关系，那么考虑<script type="math/tex">f(s-\{j\},j)</script>，如果它是<script type="math/tex">true</script>，即如果下一轮<script type="math/tex">j</script>成为龙能获胜，那么他就会选择攻击，<script type="math/tex">i</script>就会失败。</p>
<p>设朋友关系的图的补图为<script type="math/tex">G</script>，那么转移为</p>
<script type="math/tex; mode=display">
f(s,i)=\prod_{j\in S,(i,j)\in G}[f(s-\{j\},j)=false]</script><p>即这一轮中<script type="math/tex">i</script>能获胜当且仅当所有能攻击的勇士选择攻击之后都无法获胜。</p>
<p>考虑观察转移形式，可以发现这个转移式类似一个经典的博弈模型：</p>
<p>有一张图<script type="math/tex">G</script>，<script type="math/tex">Alice</script>和<script type="math/tex">Bob</script>轮流移动棋子。一开始棋子在某个节点<script type="math/tex">u</script>，每一步可以把棋子移向任意一个与<script type="math/tex">u</script>相邻的且没有经过的点<script type="math/tex">v</script>，不能移动者算输，<script type="math/tex">Alice</script>先手。对于每个<script type="math/tex">1\le u\le n</script>，求出一开始棋子在<script type="math/tex">u</script>时<script type="math/tex">Alice</script>能否获胜。</p>
<p>这个问题的转移为设<script type="math/tex">f(s,i)</script>表示目前没有到过的节点集合为<script type="math/tex">s</script>，当前在节点<script type="math/tex">i</script>，先手能否获胜。</p>
<p>那么有</p>
<script type="math/tex; mode=display">
f(s,i)=!(\prod_{j\in S,(i,j)\in G}[f(s-\{j\},j)=true])</script><p>其中<script type="math/tex">!</script>表示取反。可以发现，这个转移和我们原问题的转移方程差异仅在胜负的定义相反，即原问题的胜，在新问题中是负；原问题中的负，在新问题中是正。</p>
<p>那么，我们可以把原问题完全转化到这个新的问题上来。</p>
<p>这个经典问题的结论是：起点在<script type="math/tex">u</script>时先手能获胜当且仅当<script type="math/tex">u</script>出现在所有<script type="math/tex">G</script>的最大匹配中。换句话说，不存在某个<script type="math/tex">G</script>的最大匹配<script type="math/tex">M</script>，使得<script type="math/tex">u\notin M</script>。</p>
<p>为什么呢？</p>
<p>我们先证明，如果存在某个<script type="math/tex">G</script>的最大匹配<script type="math/tex">M</script>，使得<script type="math/tex">u\notin M</script>，那么先手必败。</p>
<p>考虑从<script type="math/tex">u</script>先随便走一条边到一个点<script type="math/tex">v</script>，那么一定有<script type="math/tex">v\in M</script>，否则<script type="math/tex">(u,v)</script>能构成一组新的匹配，原匹配不是最大匹配。那么后手只要沿着<script type="math/tex">v</script>的匹配边走即可。即<script type="math/tex">Alice</script>每次都会走一条非匹配边，<script type="math/tex">Bob</script>每次都会走一条匹配边。这样走下去，<script type="math/tex">Bob</script>必胜。因为假设某一次<script type="math/tex">Alice</script>走完一条非匹配边后，<script type="math/tex">Bob</script>没法走一条匹配边。那么回顾走过的路，是一条开头和结尾都是非匹配边的交错轨，那么如果我们把这条路上的边全部取反（即非匹配边变为匹配边，匹配边变为非匹配边），那么会获得一个更大的匹配，与最大匹配矛盾。</p>
<p>接下来我们要证明如果<script type="math/tex">u</script>出现在<script type="math/tex">G</script>的所有最大匹配中，先手必胜。</p>
<p>随便选择某个最大匹配<script type="math/tex">M</script>。<script type="math/tex">Alice</script>走的策略即每次走匹配边，<script type="math/tex">Bob</script>每次只能走非匹配边。如果存在某一步<script type="math/tex">Bob</script>走完后<script type="math/tex">Alice</script>走不了了，那么回顾走过的这条路径，一定是开头为匹配边，结尾为非匹配边的交错轨，那么我们把这条路径上的边取反，会得到一个新的最大匹配，且起点不被包含在这个最大匹配中，与假设矛盾。</p>
<p>那么，我们现在的问题就是对于每个点，我们要判断它是否出现在所有的最大匹配中。</p>
<p>先考虑如何求出一般图的最大匹配。可以考虑带花树，但是那个比较复杂。</p>
<p>考虑定义<script type="math/tex">tutte</script>矩阵<script type="math/tex">T</script>。对于<script type="math/tex">\forall (i,j)\in G</script>，<script type="math/tex">A_{i,j}=val_{i,j}</script>，<script type="math/tex">A_{j,i}=-val_{i,j}</script>。其中<script type="math/tex">val_{i,j}</script>是对这条边设的一个随机权值。而对于<script type="math/tex">\forall (i,j)\notin G</script>，<script type="math/tex">A_{i,j}=0</script>。</p>
<p>结论是：矩阵<script type="math/tex">T</script>的秩的<script type="math/tex">\frac{1}{2}</script>就是<script type="math/tex">G</script>的最大匹配数（可以证明，<script type="math/tex">T</script>的秩一定是偶数）。</p>
<p>具体证明和理论可以参考<script type="math/tex">2017</script>国家集训队论文：《基于线性代数的一般图匹配》（杨家齐）。此处略去。</p>
<p>这样，我们可以通过高斯消元在<script type="math/tex">O(n^3)</script>的时间复杂度内算出最大匹配数。</p>
<p>回到判定点是否在最大匹配中的问题。</p>
<p>一个想法是考虑删掉这个点，看剩下的图的最大匹配是否和原图最大匹配相等。如果相等，那么这个点就不会出现在所有最大匹配中。但这样时间复杂度是<script type="math/tex">O(n^4)</script>，无法接受。</p>
<p>假设我们考虑的点为<script type="math/tex">s</script>。</p>
<p>考虑新加一个点<script type="math/tex">ns</script>，并将这个点向<script type="math/tex">s</script>连一条边，那么我们只需要判断新图的最大匹配是否增加即可。因为如果存在一个最大匹配，使得<script type="math/tex">s</script>不在最大匹配中，那么<script type="math/tex">s</script>和<script type="math/tex">ns</script>能构成一组新的匹配，换句话说，会使最大匹配增加<script type="math/tex">1</script>。否则，如果对于所有的最大匹配<script type="math/tex">s</script>都在其中，因为<script type="math/tex">ns</script>只与<script type="math/tex">s</script>连边，因此最大匹配不会变化。</p>
<p>现在的问题就是每次考虑在原矩阵右边和下边新增一行一列，问新的矩阵的秩是否增加。每次暴力做显然无法接受，但是我们可以考虑优化。</p>
<p>首先考虑高斯消元是行变换，因此我们可以把新增的那一列看成原矩阵的增广矩阵，即把原矩阵扩充为<script type="math/tex">n</script>行<script type="math/tex">2n</script>列的矩阵，其中第<script type="math/tex">n+i</script>列表示的是当我们考虑第<script type="math/tex">i</script>个点为起点时向右边新增的一列，那么我们可以在对原矩阵进行高斯消元的同时对右边增广的列也做同样的变换，就可以在<script type="math/tex">O(n^3)</script>的时间复杂度内算出高斯消元后右边的列。</p>
<p>现在对于每个点<script type="math/tex">s</script>，先考虑如果除了以<script type="math/tex">1,2,\dots,n</script>为主元的行向量外存在某个行向量的第<script type="math/tex">n+1</script>位非零，那么就多了以<script type="math/tex">n+1</script>为主元的行向量，使得秩增加<script type="math/tex">1</script>，可以直接返回。</p>
<p>接下来考虑加入的一行。高斯消元是支持加入一个行向量的，具体可以考虑线性基的构造过程，我们让<script type="math/tex">i</script>从<script type="math/tex">1</script>到<script type="math/tex">n+1</script>来扫，如果加入的行向量第<script type="math/tex">i</script>个元素非零，考虑矩阵中，如果存在以这个位置为主元的向量，那么我们用这个向量去消加入的行向量，再继续往下做。否则，我们就使矩阵的秩增加了<script type="math/tex">1</script>，即可返回。</p>
<p>这样时间复杂度为<script type="math/tex">O(n^3)</script>，可以通过本题。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">rnd</span><span class="params">( time(<span class="literal">NULL</span>) )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">510</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ct;</span><br><span class="line"><span class="keyword">int</span> a[maxN + <span class="number">1</span>][maxN * <span class="number">2</span> + <span class="number">1</span>], id[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> b[maxN + <span class="number">1</span>][maxN + <span class="number">1</span>], v[maxN + <span class="number">1</span>], val[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">char</span> s[maxN + <span class="number">1</span>][maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123; x = x + y &gt;= mod ? x + y - mod : x + y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>) ans = <span class="number">1ll</span> * ans * a % mod;</span><br><span class="line">        a = <span class="number">1ll</span> * a * a % mod;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>	j = ct + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(a[j][i]) &#123; p = j; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span>(!p) <span class="keyword">continue</span>;</span><br><span class="line">        id[i] = ++ ct;</span><br><span class="line">        <span class="keyword">if</span>(p != ct) <span class="built_in">swap</span>(a[p], a[ct]);</span><br><span class="line">        <span class="keyword">int</span> INV = <span class="built_in">mpow</span>(a[ct][i], mod - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = ct + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">1ll</span> * INV * a[j][i] % mod;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= <span class="number">2</span> * n; k++)</span><br><span class="line">                <span class="built_in">update</span>(a[j][k], mod - <span class="number">1ll</span> * a[ct][k] * t % mod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = ct + <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(b[i][n + <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!v[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!id[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">1ll</span> * v[i] * <span class="built_in">mpow</span>(b[ id[i] ][i], mod - <span class="number">2</span>) % mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= n + <span class="number">1</span>; j++)</span><br><span class="line">            <span class="built_in">update</span>(v[j], mod - <span class="number">1ll</span> * b[ id[i] ][j] * t % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[i] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(s[i][j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x = <span class="built_in">rnd</span>() % (mod - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">                a[i][j] = x; a[j][i] = mod - x;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        a[i][n + i] = val[i] = <span class="built_in">rnd</span>() % (mod - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Gauss</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            b[i][j] = a[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= n; s++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            b[i][n + <span class="number">1</span>] = a[i][n + s];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(i == s) v[i] = mod - val[s];</span><br><span class="line">            <span class="keyword">else</span> v[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="built_in">check</span>() ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>);	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>线性代数</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>可持久化并查集</title>
    <url>/2019/01/30/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<p>可持久化并查集是建立在可持久化数组的基础上的，而可持久化数组是用主席树来实现的，所以，我们主要通过主席树来实现可持久化并查集；</p>
<span id="more"></span>
<p>首先，我们考虑合并问题，由于每次合并只改变一个点的父亲，我们可以看做这个点的值，这样，就和可持久化数组差不多了：每次，我们修改一个点的值（父亲），就只会修改logn个节点，因此，只要开一个n + mlogn的数组就可以了。由于要保持并查集的高效，而又不能进行路径压缩（至少我不会），因此，我们只能进行启发式合并，把时间保持在严格的logn以内，我们用dep来记录这个节点的深度，每次合并的时候，从深度小的向深度大的合并。我们定义这样一个树：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,num,dep;</span><br><span class="line">&#125;tree[maxN*<span class="number">40</span>+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>再讲查询，其实查询并不难，如果我们要找x的所在的集合的根节点，只要我们每次在这个副本中找到x的父亲，再递归查找x的父亲的父亲，直到这个东西的值等于自己就返回（找到根节点了），还是看代码吧。</p>
<h4 id="查询操作："><a href="#查询操作：" class="headerlink" title="查询操作："></a>查询操作：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find_pa</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> node=<span class="built_in">query</span>(root[now],<span class="number">1</span>,n,x);<span class="comment">//查找x的下标</span></span><br><span class="line">    <span class="keyword">if</span>(tree[node].num==x) <span class="keyword">return</span> node;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find_pa</span>(now,tree[node].num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="合并操作"><a href="#合并操作" class="headerlink" title="合并操作:"></a>合并操作:</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//root[now]指当前的根的版本</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="built_in">find_pa</span>(x); y=<span class="built_in">find_pa</span>(y);<span class="comment">//这个x,y指的是原来传过来的x,y在tree中节点的下标</span></span><br><span class="line">    <span class="keyword">if</span>(tree[x].dep&gt;tree[y].dep) <span class="built_in">swap</span>(x,y);<span class="comment">//启发式合并，小的并向大的</span></span><br><span class="line">    root[now]=<span class="built_in">change</span>(root[now<span class="number">-1</span>],<span class="number">1</span>,n,tree[x].num,tree[y].num);<span class="comment">//把x的num改为y的num，创建一个新的副本</span></span><br><span class="line">    <span class="keyword">if</span>(tree[x].dep==tree[y].dep) <span class="built_in">update</span>(root[now],<span class="number">1</span>,n,tree[y].num);<span class="comment">//更新深度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有像query，change，build这些函数都是主席树的基本操作了，就不介绍了，change中每次修改到叶子节点的时候，不仅num要改，dep也要复制过来。</p>
<p><strong>PS:每次不要忘记把root从上一个复制过来哦~~</strong></p>
<p>由于每次查询父亲都要logn次，又有logn次查询，所以复杂度为<script type="math/tex">O(mlog^2n)</script></p>
<p>例题？</p>
<p><a href="https://www.luogu.org/problemnew/show/P3402">可持久化并查集</a></p>
<p>这就是模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN=<span class="number">2e6</span> + <span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> dep,num,l,r;</span><br><span class="line">&#125;tree[maxN*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,root[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) num=(num&lt;&lt;<span class="number">3</span>)+(num&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> num*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> node=++cnt;</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;tree[node].num=l; tree[node].dep=<span class="number">1</span>; <span class="keyword">return</span> node;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    tree[node].l=<span class="built_in">build</span>(l,mid);</span><br><span class="line">    tree[node].r=<span class="built_in">build</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> pre,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> node=++cnt;</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;tree[node].num=y; tree[node].dep=tree[pre].dep; <span class="keyword">return</span> node;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    tree[node].l=tree[pre].l; tree[node].r=tree[pre].r;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) tree[node].l=<span class="built_in">change</span>(tree[pre].l,l,mid,x,y);</span><br><span class="line">    <span class="keyword">else</span> tree[node].r=<span class="built_in">change</span>(tree[pre].r,mid+<span class="number">1</span>,r,x,y);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> node;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="keyword">return</span> <span class="built_in">query</span>(tree[node].l,l,mid,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(tree[node].r,mid+<span class="number">1</span>,r,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find_pa</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> node=<span class="built_in">query</span>(root[now],<span class="number">1</span>,n,x);</span><br><span class="line">    <span class="keyword">if</span>(tree[node].num==x) <span class="keyword">return</span> node;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find_pa</span>(now,tree[node].num); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;tree[node].dep++; <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">update</span>(tree[node].l,l,mid,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(tree[node].r,mid+<span class="number">1</span>,r,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="built_in">find_pa</span>(now,x); y=<span class="built_in">find_pa</span>(now,y);</span><br><span class="line">    <span class="keyword">if</span>(tree[x].num==tree[y].num) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[x].dep&gt;tree[y].dep) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    root[now]=<span class="built_in">change</span>(root[now<span class="number">-1</span>],<span class="number">1</span>,n,tree[x].num,tree[y].num);</span><br><span class="line">    <span class="keyword">if</span>(tree[x].dep==tree[y].dep) <span class="built_in">update</span>(root[now],<span class="number">1</span>,n,tree[y].num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    root[<span class="number">0</span>]=<span class="built_in">build</span>(<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        root[i]=root[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> op=<span class="built_in">read</span>(),x=<span class="built_in">read</span>(),y;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>) y=<span class="built_in">read</span>(),<span class="built_in">merge</span>(i,x,y);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">2</span>) root[i]=root[x];</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">3</span>) y=<span class="built_in">read</span>(),<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tree[<span class="built_in">find_pa</span>(i,x)].num==tree[<span class="built_in">find_pa</span>(i,y)].num?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有？听说NOI2018D1T1归程可以用可持久化并查集耶，也可以做做那题吧：</p>
<p><a href="https://www.luogu.org/problemnew/show/P4768">归程</a></p>
<p>如果我心情好的话，也许会写个题解呢~~</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>可持久化</tag>
      </tags>
  </entry>
  <entry>
    <title>得到1</title>
    <url>/2019/01/27/%E5%BE%97%E5%88%B01/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给一个正整数<script type="math/tex">N</script>，每次可以在不超过<script type="math/tex">N</script>的素数中随机选择一个<script type="math/tex">P</script>，如果<script type="math/tex">P</script>是<script type="math/tex">N</script>的约数，则把<script type="math/tex">N</script>变成<script type="math/tex">N/p</script>,否则<script type="math/tex">N</script>不变，问平均情况下需要多少次随机选择，才能把<script type="math/tex">N</script>变成<script type="math/tex">1</script>？</p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>设<script type="math/tex">f(i)</script>为当前数为<script type="math/tex">i</script>是所用的平均步数（期望步数），则根据期望的线性和全期望公式可得：</p>
<script type="math/tex; mode=display">
f(6)=1+f(6)*\frac{1}{3}+f(2)*\frac{1}{3}+f(3)*\frac{1}{3};</script><p>其中，最前面的1指执行这一步，后面则是后面转移的可能；</p>
<p>我们设p(x)为不超过x的素数个数，g(x)为素数中为x的约数的个数；</p>
<p>则：</p>
<script type="math/tex; mode=display">
f(x)=1+f(x)*(1-\frac{g(x)}{p(x)})+\sum_{y|x,y\in prime}f(x/y)*\frac{1}{p(x)}</script><p>整理可得：</p>
<script type="math/tex; mode=display">
f(x)=\frac{(\sum_{y|x,y\in prime}f(x/y)) +p(x)}{g(x)}</script><p>由此，我们可以对f(x)进行记忆化搜索，时间复杂度为<script type="math/tex">O(maxnum)</script>;</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN=<span class="number">1e6</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">double</span> f[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> t,cnt,x;</span><br><span class="line"><span class="keyword">int</span> prime[maxN+<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">bool</span> flag[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(f[x]) <span class="keyword">return</span> f[x];</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>,g=<span class="number">0</span>;<span class="comment">//p:不超过x的素数个数，g:其中x的因子个数 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot&amp;&amp;prime[i]&lt;=x;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p++;</span><br><span class="line">        <span class="keyword">if</span>(x%prime[i]==<span class="number">0</span>) g++,f[x]+=<span class="built_in">dfs</span>(x/prime[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x]=(f[x]+p)/g;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxN;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag[i]) prime[++tot]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot&amp;&amp;i*prime[j]&lt;maxN;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            flag[i*prime[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %.8lf\n&quot;</span>,++cnt,<span class="built_in">dfs</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>dp</tag>
        <tag>概率期望</tag>
      </tags>
  </entry>
  <entry>
    <title>整体二分略解</title>
    <url>/2019/09/13/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86%E7%95%A5%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="整体二分"><a href="#整体二分" class="headerlink" title="整体二分"></a>整体二分</h1><p>什么是整体二分？</p>
<p>如果你有一个操作序列（包括修改和查询），每次询问可以通过二分来解决，但是如果每次都二分的话时间复杂度就爆掉了，这个时候，也许就能使用——整体二分。</p>
<span id="more"></span>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>整体二分的函数一般都写成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br></pre></td></tr></table></figure>
<p>其中，<script type="math/tex">l,r</script>是答案区间，而<script type="math/tex">x,y</script>是操作区间。其中的含义就是操作<script type="math/tex">[x,y]</script>中询问的答案或修改的数的权值都在<script type="math/tex">[l,r]</script>之间。这个时候，有人会问了：你怎么知道答案或修改的值属于<script type="math/tex">[l,r]</script>的操作都是连续的呢？这个，我们后面再解决。</p>
<p>先考虑怎么分治：</p>
<p>像普通二分一样，先计算出<script type="math/tex">mid=(l+r)>>1</script>，然后，对于修改操作，按照<script type="math/tex"><=mid</script>或<script type="math/tex">>mid</script>分成左右两边，如果修改的数<script type="math/tex"><=mid</script>，就在树状数组上加以修改，这个主要是为了询问的分类做准备。对于询问操作，先通过树状数组计算出现在的贡献<script type="math/tex">tmp</script>。如果<script type="math/tex">tmp>=num</script>（<script type="math/tex">num</script>指需要的权值），就分为左边一组，否则，就让询问的权值<script type="math/tex">num</script>减掉<script type="math/tex">tmp</script>，再分到右边那一组。</p>
<p>最后把分类的结果<script type="math/tex">copy</script>到原来的数组中即可。</p>
<p>经过这么一通分类操作，就可以保证<script type="math/tex">[l,r]</script>之间的操作是连续的了。</p>
<p>接下来，我们就递归</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">solve</span>(l, mid, x, x + t1 - <span class="number">1</span>); <span class="built_in">solve</span>(mid + <span class="number">1</span>, r, x + t1, r);</span><br><span class="line"><span class="comment">//t1:分类到左边的操作的个数</span></span><br></pre></td></tr></table></figure>
<p>其实过程很像<script type="math/tex">cdq</script>分治，但是<script type="math/tex">cdq</script>分治是在操作之前递归，然后统计前面区间对后面区间的贡献，本质上还是区别挺大的，但是写法上却差不多。。。</p>
<p>边界条件？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(l &gt; r || x &gt; y) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= y; i++) ans[ q[i].id ] = l;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完结撒花。</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>搜索标签即可。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title>本质不同的子串数量</title>
    <url>/2019/03/11/%E6%9C%AC%E8%B4%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E4%B8%B2%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给你一个长为<script type="math/tex">N</script>的字符串，求不同的子串的个数</p>
<p>我们定义两个子串不同，当且仅当有这两个子串长度不一样 或者长度一样且有任意一位不一样。</p>
<p>子串的定义：原字符串中连续的一段字符组成的字符串</p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>这是<script type="math/tex">height</script>数组的有一大神奇操作。</p>
<p>我们考虑每一个子串必然是某一个后缀的一个前缀，那么，我们直接用以<script type="math/tex">sa[i]</script>开头的后缀的子串个数（为<script type="math/tex">n-sa[i]+1</script>）减掉与前一个后缀相同的最长公共前缀就好了，即：</p>
<script type="math/tex; mode=display">
ans=\sum_{i=1}^n n-sa[i]+1-height[i]</script><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">1e5</span> + <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, p, sa[maxN + <span class="number">1</span>], rk[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> bin[maxN + <span class="number">1</span>], tp[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> height[maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Qsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) bin[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) bin[ rk[i] ] ++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) bin[i] += bin[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) sa[ bin[ rk[ tp[i] ] ] -- ] = tp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) tp[i] = i, rk[i] = s[i];</span><br><span class="line">    <span class="built_in">Qsort</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">1</span>; p &lt; n; m = p, w &lt;&lt;= <span class="number">1LL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - w + <span class="number">1</span>; i &lt;= n; i++) tp[ ++ p ] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(sa[i] - w &gt; <span class="number">0</span>) tp[ ++ p ] = sa[i] - w;</span><br><span class="line">        <span class="built_in">Qsort</span>();</span><br><span class="line">        <span class="built_in">memcpy</span>(tp, rk, <span class="built_in"><span class="keyword">sizeof</span></span>(rk));</span><br><span class="line">        rk[ sa[<span class="number">1</span>] ] = p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">            rk[ sa[i] ] = (tp[ sa[i] ] == tp[ sa[i - <span class="number">1</span>] ] &amp;&amp; tp[ sa[i] + w] == tp[ sa[i - <span class="number">1</span>] + w]) ? p : ++p; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k) k --;</span><br><span class="line">        <span class="keyword">int</span> j = sa[ rk[i] - <span class="number">1</span> ];</span><br><span class="line">        <span class="keyword">while</span>(s[i + k] == s[j + k]) k ++;</span><br><span class="line">        height[ rk[i] ] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> int</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %s&quot;</span>, &amp;n, s + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">work</span>();</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            ans += n - sa[i] + <span class="number">1</span> - height[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title>最小路径覆盖问题</title>
    <url>/2019/01/20/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>在一个有向图中，找出最少的路径，使得这些路径经过了所有的点。</p>
<p>最小路径覆盖分为最小不相交路径覆盖和最小可相交路径覆盖。</p>
<p>最小不相交路径覆盖：每一条路径经过的顶点各不相同。</p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先，把每个点拆成xi,yi两个点，就成为了一个二分图； </p>
<p>这时，每个点就相当于一条长度为0的路径， <strong>而每次给xi,yj连一条边就是合并一条路径，即使路径条数减一</strong>；</p>
<p>所以，我们找这个二分图的最大匹配（用<script type="math/tex">dinic</script>），就是可以减少的路径数，所以答案就是</p>
<p><strong>最小路径覆盖 = 原图节点数 - 最大匹配数 </strong></p>
<p>至于输出路径：</p>
<p>考虑在dfs时，记录一下流出去的<script type="math/tex">edge[i].to</script>，就可以快乐地输出了；</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN=<span class="number">1e6</span> + <span class="number">100</span>,inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,value,next;</span><br><span class="line">    <span class="built_in">Node</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> to,<span class="keyword">int</span> value,<span class="keyword">int</span> next) : <span class="built_in">to</span>(to),<span class="built_in">value</span>(value),<span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;edge[maxN*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> tot=<span class="number">1</span>,head[maxN+<span class="number">1</span>],n,m;</span><br><span class="line"><span class="keyword">int</span> s,t,dep[maxN+<span class="number">1</span>],ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> to[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> flag[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) num=(num&lt;&lt;<span class="number">3</span>)+(num&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> num*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++tot]=<span class="built_in">Node</span>(y,t,head[x]); head[x]=tot;</span><br><span class="line">    edge[++tot]=<span class="built_in">Node</span>(x,<span class="number">0</span>,head[y]); head[y]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dep));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    dep[s]=<span class="number">1</span>; q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)</span><br><span class="line">           <span class="keyword">if</span>(!dep[edge[i].to]&amp;&amp;edge[i].value)</span><br><span class="line">           &#123;</span><br><span class="line">               dep[edge[i].to]=dep[x]+<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">if</span>(edge[i].to==t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">               q.<span class="built_in">push</span>(edge[i].to);</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==t) <span class="keyword">return</span> num;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)</span><br><span class="line">       <span class="keyword">if</span>(dep[edge[i].to]==dep[x]+<span class="number">1</span>&amp;&amp;edge[i].value)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> tmp=<span class="built_in">dfs</span>(edge[i].to,<span class="built_in">min</span>(edge[i].value,num));</span><br><span class="line">           <span class="keyword">if</span>(tmp) </span><br><span class="line">           &#123;</span><br><span class="line">               to[x]=edge[i].to;</span><br><span class="line">               <span class="keyword">if</span>(x!=s&amp;&amp;edge[i].to&gt;=n) flag[edge[i].to-n]=<span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           num-=tmp; sum+=tmp;</span><br><span class="line">           edge[i].value-=tmp; edge[i^<span class="number">1</span>].value+=tmp;</span><br><span class="line">           <span class="keyword">if</span>(!num) <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    s=<span class="number">0</span>,t=maxN<span class="number">-100</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">add</span>(s,i,<span class="number">1</span>),<span class="built_in">add</span>(i+n,t,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(x,y+n,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>()) ans+=<span class="built_in">dfs</span>(s,inf);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">       <span class="keyword">if</span>(!flag[i])</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> now=i;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,now);</span><br><span class="line">           <span class="keyword">while</span>(to[now]!=t&amp;&amp;to[now]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,to[now]-n),now=to[now]-n;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n-ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈AC自动机</title>
    <url>/2020/03/28/%E6%B5%85%E8%B0%88AC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h1><p>所谓<script type="math/tex">AC</script>自动机，实际上就是在<script type="math/tex">Trie</script>树上建立<script type="math/tex">KMP</script>，在多串匹配时有重要的作用。</p>
<span id="more"></span>
<h1 id="Fail指针"><a href="#Fail指针" class="headerlink" title="Fail指针"></a>Fail指针</h1><p><script type="math/tex">AC</script>自动机最重要的，就是这个<script type="math/tex">fail</script>指针了。这个<script type="math/tex">fail</script>指针类似于<script type="math/tex">KMP</script>的<script type="math/tex">nxt</script>数组，只不过因为会有多个串，所以<script type="math/tex">fail</script>指针指的位置可能不是当前这个串的前缀，而是别的某个字符串的前缀。</p>
<p>一个节点的<script type="math/tex">fail</script>指针的定义，即整个<script type="math/tex">Trie</script>树上所有节点代表的字符串中（都是给定的那些串的前缀），<strong>是当前节点接受的字符串后缀，且是所有符合这个条件的节点中长度最长的那个串的节点。</strong></p>
<p>类比一下<script type="math/tex">nxt</script>数组，含义就非常清晰了。</p>
<p>在做匹配的时候，如果这个点没有<script type="math/tex">ch[c]</script>这个孩子，那么就不断地跳<script type="math/tex">fail</script>指针，直到有一个<script type="math/tex">ch[c]</script>的节点停下。类似于<script type="math/tex">KMP</script>时跳<script type="math/tex">nxt</script>的过程，非常清晰。</p>
<p>但实际上，在<script type="math/tex">Trie</script>树上如果暴力跳<script type="math/tex">fail</script>，时间复杂度是不对的，然而我们在构建<script type="math/tex">AC</script>自动机时有一种非常巧妙的方法，既能完美地构建出自动机，又能巧妙地解决时间问题。</p>
<p>我们想到，既然每次如果找不到<script type="math/tex">ch[c]</script>就要暴力往上跳找到第一个有<script type="math/tex">ch[c]</script>的节点，那么我们何不直接将当前节点的<script type="math/tex">ch[c]</script>直接指向按照<script type="math/tex">fail</script>往上跳时第一个由<script type="math/tex">ch[c]</script>的节点的<script type="math/tex">ch[c]</script>呢（如果没有这样的<script type="math/tex">ch[c]</script>就直接指向根节点）？这样一来，每次就不用暴力往上跳了。而此时，这个东西显然不是一棵树，而是一张有向图。</p>
<p>但是，怎么构建这张图呢？这就是<script type="math/tex">AC</script>自动机的妙处。</p>
<h1 id="构建AC自动机"><a href="#构建AC自动机" class="headerlink" title="构建AC自动机"></a>构建AC自动机</h1><p>一个显然的性质时，在<script type="math/tex">Trie</script>树上，所有节点的<script type="math/tex">fail</script>指针指的节点的深度一定比当前节点要小。</p>
<p>那么，我们考虑用<script type="math/tex">bfs</script>来构建<script type="math/tex">AC</script>自动机。</p>
<p>初始情况自然是</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">    <span class="keyword">if</span>(st[root].ch[i]) st[ st[root].ch[i] ].fail = root, q.<span class="built_in">push</span>(st[root].ch[i]);</span><br></pre></td></tr></table></figure>
<p>然后我们开始<script type="math/tex">bfs</script>，考虑如果我们当前出队的节点是<script type="math/tex">x</script>，那么所有深度小于<script type="math/tex">x</script>的节点一定全部处理完了，所谓处理完了，就是已经求出了<script type="math/tex">fail</script>指针，且<script type="math/tex">ch[c]</script>已经指向了往上跳<script type="math/tex">fail</script>时遇到的第一个<script type="math/tex">ch[c]</script>。</p>
<p>那么，我们考虑扩展到所有的<script type="math/tex">ch[x][c]</script>，<script type="math/tex">ch[x][c]</script>存在的话，那么就计算它的<script type="math/tex">fail</script>，显然<script type="math/tex">fail[ch[x][c]]=ch[fail[x]][c]</script>，然后将<script type="math/tex">ch[x][c]</script>压入队中。否则，如果不存在的话，那么直接将其设为<script type="math/tex">ch[x][c]=ch[fail[x]][c]</script>。因为此时<script type="math/tex">fail[x]</script>的深度一定小于<script type="math/tex">x</script>，所以<script type="math/tex">fail[x]</script>的所有信息都已经计算完了，所以这样做一定是对的。</p>
<p>那么构建<script type="math/tex">AC</script>自动机的代码就很简单了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_fail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(st[root].ch[i]) st[ st[root].ch[i] ].fail = root, q.<span class="built_in">push</span>(st[root].ch[i]);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(st[x].ch[i]) st[ st[x].ch[i] ].fail = st[ st[x].fail ].ch[i], q.<span class="built_in">push</span>(st[x].ch[i]);</span><br><span class="line">        	<span class="keyword">else</span> st[x].ch[i] = st[ st[x].fail ].ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="AC自动机用法"><a href="#AC自动机用法" class="headerlink" title="AC自动机用法"></a>AC自动机用法</h1><h2 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h2><p>多模式串匹配自然不用多说了，直接每次在<script type="math/tex">Trie</script>图上跑即可。</p>
<h2 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h2><p>如果统计每个模式串在文本串出现的次数，怎么做呢？</p>
<p>考虑我们构建出来的<script type="math/tex">fail</script>指针和所有节点，显然构成了一棵树（每个节点都由且仅有唯一一个<script type="math/tex">fail</script>指针），我们把这棵树给建出来，观察性质。</p>
<p><strong>我们发现每个节点代表的字符串都是其所有子树代表字符串的后缀，也可以说，一个节点所有祖先代表的字符串都是这个节点代表字符串的后缀。</strong></p>
<p>那么，我们用文本串在<script type="math/tex">Trie</script>图上跑的时候，如果经过了某个节点，实际上的贡献应该是这个节点所有祖先的权值之和（我们让每个<script type="math/tex">Trie</script>树上的字符串在它成为文本串的某个前缀的后缀时产生贡献，请读者仔细理解）。那么利用树上差分，我们将经过的所有节点计数器加一，最后遍历整棵树统计一下答案即可。</p>
<p>这个<script type="math/tex">fail</script>树的性质非常重要，可以说是精髓所在，请读者仔细理解其中含义。</p>
<p>实际上，对于<script type="math/tex">KMP</script>我们也可以建立这样一棵类似的树（每个点的<script type="math/tex">nxt</script>都存在且唯一），也有类似的性质。</p>
<p>另外，在统计贡献的时候，统计所有当前节点后缀的节点的贡献，能做到不重不漏。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>概率相关知识</title>
    <url>/2019/01/27/%E6%A6%82%E7%8E%87%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h1><h2 id="全概率公式"><a href="#全概率公式" class="headerlink" title="全概率公式"></a>全概率公式</h2><p>把样本空间S分为若干个不相交的部分B1,B2…，则</p>
<script type="math/tex; mode=display">
P(A)=P(A|B1)*P(B1)+P(A|B2)*P(B2)+...</script><p>其中，P(A|B)表示在B已经发生的情况下A发生的概率。</p>
<h1 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h1><p>期望指一个随机变量的平均取值。</p>
<h2 id="数学期望的线性"><a href="#数学期望的线性" class="headerlink" title="数学期望的线性"></a>数学期望的线性</h2><p>有限个随机变量（互相影响也可以）之和的数学期望等于每个随机变量的数学期望之和：</p>
<script type="math/tex; mode=display">
E(X+Y)=E(X)+E(Y)</script><span id="more"></span>
<h2 id="全期望公式"><a href="#全期望公式" class="headerlink" title="全期望公式"></a>全期望公式</h2><p>类似全概率公式，把所有情况不重不漏地分为若干类，计算数学期望，再把这些数学期望按照每类的概率加权求和：</p>
<script type="math/tex; mode=display">
E(A)=E(A|B1)*P(B1)+E(A|B2)*P(B2)+...</script>]]></content>
      <tags>
        <tag>概率期望</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈BEST定理</title>
    <url>/2020/09/12/%E6%B5%85%E8%B0%88BEST%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h1 id="BEST定理"><a href="#BEST定理" class="headerlink" title="BEST定理"></a>BEST定理</h1><p>什么是<script type="math/tex">BEST</script>定理呢？</p>
<p>所谓<script type="math/tex">BEST</script>，是由发现这个定理的四个人缩写构成的。这个定理的作用，是求有向图欧拉回路的个数。</p>
<span id="more"></span>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>首先，如果存在某个点的入度和出度不相等，那么这张图不存在欧拉回路。</p>
<p>否则，我们设<script type="math/tex">T(x)</script>表示以<script type="math/tex">x</script>为根的内向树个数，<script type="math/tex">deg(x)</script>为<script type="math/tex">x</script>的出度（等于入度），那么有向图欧拉回路个数为</p>
<script type="math/tex; mode=display">
ans=T(rt)\prod_{v\in V}(deg(v)-1)!</script><p>其中，<script type="math/tex">rt\in V</script>，也就是说，以任何一个点作为根最后都可以得出一样的答案。</p>
<p>但是，如果规定欧拉回路起点的话答案有所不同，这个我们后面再说。</p>
<h1 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h1><p>我们来考虑一个内向树与一个欧拉回路的对应关系。</p>
<p>内向树中除了根节点<script type="math/tex">rt</script>，都有一个指向父亲的边，我们把它看成从这个点出发的最后一条边。另外，我们把每个点除了指向父亲的边以外的所有边按照一定顺序排序（随便什么顺序），特别地，对于根节点，因为我们统计的是欧拉回路，是一个环，因此为了避免算重，我们钦定根节点第一个出去的边是与根节点连接的编号最小的那条边，并对与根节点相连的剩下的边按照一定顺序排序。</p>
<p>现在我们来证明这个与一条欧拉回路一一对应。</p>
<p>首先考虑确定了内向树和每个点的出边顺序后能唯一对应一条欧拉回路。</p>
<p>我们从根节点开始，按照确定的出边顺序走，即如果我们到了一个节点<script type="math/tex">u</script>，那么我们现在会走按照已经确定的<script type="math/tex">u</script>的出边顺序还没走过的顺序最小的边。显然，最后会回到根节点，<strong>因为如果一个点走了内向树上连向父亲的那条边，那么说明这个点所有其他出边和入边都被走完了，反过来，对于任何一个不是根节点的节点，只要能到达这个节点，它与父亲的连边一定没有走过</strong>，因此不会成为终点。</p>
<p>那么我们走出了一条回路，那么这是不是欧拉回路呢？会不会有的边没有走到呢？</p>
<p>假设<script type="math/tex">u</script>的某条出边或入边没有被走，那么它与父亲的连边一定不会被走，它父亲与它父亲的父亲的连边也不会走……这样，从<script type="math/tex">u</script>到根节点这条链上的所有边都不会被走，也就是说根节点有一条入边没被走，根据入度等于出度，根节点有一条出边没被走，此时根节点不会成为路径的终点，矛盾。</p>
<p>下面我们来证明一条欧拉路径能反过来唯一对应。</p>
<p>考虑每个点（除了根节点）走出的最后一条边设为内向树上这个节点与父亲的连边。我们把所有树边拿出来，每个点只有一条出边，因此我们只需证明由这些树边组成的图中没有环即可。</p>
<p>这个很显然，如果有环，那么因为根节点没有选边，因此根节点不可能出现在环上。那么对于环上任意一点，我们走了它的树边以后还能回到这个点，根据入度等于出度，一定还有一条边没被走，那么显然这不符合“这条树边是最后一条出边”的定义，矛盾。</p>
<p>那么，我们就证明了对应关系。</p>
<p> 内向树的方案数是<script type="math/tex">T(rt)</script>，而我们要对每个点（包括根节点）的其他出边选一个顺序，是<script type="math/tex">\prod (deg(v)-1)!</script>，那么</p>
<script type="math/tex; mode=display">
ans=T(rt)\prod_{v\in V}(deg(v)-1)!</script><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>如果答案要求以某个点<script type="math/tex">s</script>为出发点的欧拉回路个数，那么答案是</p>
<script type="math/tex; mode=display">
ans=T(s)deg(s)\prod_{v\in V}(deg(v)-1)!</script><p>为什么呢？因为这个时候相当于将一条欧拉回路从<script type="math/tex">s</script>处断环成链，那么一条欧拉回路有<script type="math/tex">deg(s)</script>处可以断开，因此要在答案上乘以<script type="math/tex">deg(s)</script>。</p>
<p>另外，这个算法中，重边看作不同的边，因此如果重边看作相同的边，还要除以重边的排列数。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Berlekamp-Massey算法</title>
    <url>/2020/07/18/%E6%B5%85%E8%B0%88Berlekamp-Massey%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="BM算法"><a href="#BM算法" class="headerlink" title="BM算法"></a>BM算法</h1><p>如果我们已知一个数列是线性递推数列（或猜测一个数列是线性递推数列），但是我们并不知道它的线性递推式具体是多少，那么我们可以使用<script type="math/tex">Berlekamp-Massey</script>算法，简称<script type="math/tex">BM</script>算法，来计算最短线性递推式。</p>
<p>具体来说，如果已知数列可以写成</p>
<script type="math/tex; mode=display">
a[n]=\sum_{i=1}^mr[i]*a[n - i]\quad(n\ge m+1)</script><p>给定长度为<script type="math/tex">n</script>数列<script type="math/tex">a</script>，那么我们可以通过<script type="math/tex">BM</script>计算出这个数列最短的线性递推式（设长度为<script type="math/tex">m</script>），满足对于<script type="math/tex">m+1\le i\le n</script>，<script type="math/tex">a[i]</script>都满足这个规律。</p>
<span id="more"></span>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>考虑通过不断增加数来修改线性递推数列，设<script type="math/tex">R_i</script>为第<script type="math/tex">i</script>版线性递推数列。</p>
<p>假设我们现在已经求出<script type="math/tex">a_1,a_2,...a_{i-1}</script>的线性递推数列<script type="math/tex">r_1,r_2,...r_m</script>（记为<script type="math/tex">R_{cnt}</script>），现在我们要求<script type="math/tex">a_1,a_2,...,a_i</script>的线性递推数列。</p>
<p>设<script type="math/tex">delta_i=\sum_{j=1}^mr[j]*a[n-j]-a[i]</script>。</p>
<p>如果<script type="math/tex">delta_i=0</script>，那么说明<script type="math/tex">R_{cnt}</script>对<script type="math/tex">a_1,a_2,...,a_i</script>也成立。</p>
<p>否则，说明我们需要调整<script type="math/tex">R_{cnt}</script>为<script type="math/tex">R_{cnt+1}</script>。怎么调整呢？</p>
<p>首先，如果此时<script type="math/tex">cnt=0</script>，那么说明<script type="math/tex">a_i</script>是数列中第一个非零数，那么我们只需将<script type="math/tex">R_1</script>置为<script type="math/tex">\{0,0,..,0\}</script>（<script type="math/tex">i</script>个<script type="math/tex">0</script>）即可。</p>
<p>否则，如果我们能找到另一个线性递推数列，使得这个线性递推数列前<script type="math/tex">i-1</script>个数都是<script type="math/tex">0</script>，而第<script type="math/tex">i</script>个数是<script type="math/tex">delta_i</script>，那么我们只需将这个线性递推数列和<script type="math/tex">R_{cnt}</script>加起来就能得到一个合法的<script type="math/tex">R_{cnt+1}</script>。</p>
<p>其实要构造这样的线性递推数列很简单，我们只需找任意一个历史版本的<script type="math/tex">R_k(k<cnt)</script>。设<script type="math/tex">w=fail_k</script>为使得<script type="math/tex">R_k</script>变得不合法的第一个位置。那么我们设<script type="math/tex">mul=\frac{delta_i}{delta_w}</script>，并构造<script type="math/tex">\{0,0,...,0,mul,-mul*R_k\}</script>（前面有<script type="math/tex">i-w-1</script>个<script type="math/tex">0</script>）即可，设其长度为<script type="math/tex">m</script>。</p>
<p>这样，对于<script type="math/tex">\forall j<i</script>，<script type="math/tex">mul*a[j-(i-w)]</script>与最后的相抵消，结果为<script type="math/tex">0</script>。而当<script type="math/tex">j=i</script>时，结果是<script type="math/tex">delta_i</script>，因此满足我们所需的数列条件。</p>
<p>因此，<script type="math/tex">R_{cnt+1}=\{0,0,...,0,mul,-mul*R_k\}+R_{cnt}</script>，长度为<script type="math/tex">max(i-w+len_k,len_{cnt})</script>。</p>
<p>而我们要求最短，因此只需记录下当前<script type="math/tex">len_k-fail_k</script>最短的<script type="math/tex">R</script>即可。</p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>用<script type="math/tex">BM</script>得到的最短线性递推式最好要长度远小于<script type="math/tex">\frac{n}{2}</script>才结束，否则要再打表。因为如果长度为<script type="math/tex">\frac{n}{2}</script>，那么相当于<script type="math/tex">\frac{n}{2}</script>个未知数列<script type="math/tex">\frac{n}{2}</script>个方程，总能找到解。因此对于任何一个长度为<script type="math/tex">n</script>随机数列，它的线性递推数列也是<script type="math/tex">\frac{n}{2}</script>左右，所以只有当长度远小于<script type="math/tex">\frac{n}{2}</script>时才能大致确定是原数列的线性递推式。如果长度一直在<script type="math/tex">\frac{n}{2}</script>左右，那么很可能这个数列并不是线性递推数列。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">BM</span><span class="params">(<span class="keyword">int</span> *a, vector&lt;<span class="keyword">int</span>&gt; &amp;ans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans.<span class="built_in">clear</span>();</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; lst;</span><br><span class="line">    <span class="keyword">int</span> w = <span class="number">0</span>, delta = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ans.<span class="built_in">size</span>(); j++)</span><br><span class="line">            t = <span class="built_in">ADD</span>(t, <span class="number">1ll</span> * ans[j] * a[i - j - <span class="number">1</span>] % mod);</span><br><span class="line">        <span class="keyword">if</span>(t == a[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!w)</span><br><span class="line">        &#123;</span><br><span class="line">            w = i; delta = <span class="built_in">SUB</span>(a[i], t);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) ans.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; now = ans;</span><br><span class="line">        <span class="keyword">int</span> mul = <span class="number">1ll</span> * <span class="built_in">SUB</span>(a[i], t) * <span class="built_in">mpow</span>(delta, mod - <span class="number">2</span>) % mod;</span><br><span class="line">        <span class="keyword">if</span>(i - w + (<span class="keyword">int</span>)lst.<span class="built_in">size</span>() &gt; (<span class="keyword">int</span>)ans.<span class="built_in">size</span>()) ans.<span class="built_in">resize</span>(i - w + (<span class="keyword">int</span>)lst.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">        ans[i - w - <span class="number">1</span>] = <span class="built_in">ADD</span>(ans[i - w - <span class="number">1</span>], mul);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lst.<span class="built_in">size</span>(); j++) ans[i - w + j] = <span class="built_in">SUB</span>(ans[i - w + j], <span class="number">1ll</span> * mul * lst[j] % mod);</span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">int</span>)now.<span class="built_in">size</span>() - i &lt; (<span class="keyword">int</span>)lst.<span class="built_in">size</span>() - w) delta = <span class="built_in">SUB</span>(a[i], t), w = i, lst = now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Dilworth定理</title>
    <url>/2019/12/17/%E6%B5%85%E8%B0%88Dilworth%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h1 id="Dilworth定理"><a href="#Dilworth定理" class="headerlink" title="Dilworth定理"></a>Dilworth定理</h1><p>Dilworth定理是组合数学的一个重要定理，它是定义在偏序集上的，在解决实际问题时非常有效。比如经典的题目“导弹拦截”。现在，我们就来对它一探究竟。</p>
<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p><strong>偏序集上最小链划分中链的数量等于其反链长度的最大值。</strong></p>
<span id="more"></span>
<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><p>是不是一脸懵？</p>
<p>Dilworth定理是定义在偏序集上的，什么是偏序集？我们定义一种比较关系，使得两种元素之间进行比较，例如对于元素为二元组<script type="math/tex">(a,b),(c,d)</script>我们定义<script type="math/tex">(a,b)<=(c,d)</script>当且仅当<script type="math/tex">a<=c,b<=d</script>，那么这两个元素就可比了，但是如果<script type="math/tex">a>c,b<=d</script>，那么这两个元素就不可比了。</p>
<p>偏序集可以允许不可比的元素存在，但是整个偏序集<script type="math/tex">S</script>要满足一下几个性质：</p>
<script type="math/tex; mode=display">
1.自反性： \forall a \in S,a<=a\\
2.对称性： \forall a,b\in S,若a<=b,则b>=a\\
3.传递性： 若a<=b,b<=c,则a<=c</script><p>如果对于每个<script type="math/tex">a,b</script>，若<script type="math/tex">a<=b</script>，我们连一条<script type="math/tex">a->b</script>的边，那么显然，整个偏序集构成一个<script type="math/tex">DAG</script>。</p>
<p>我们现在来理解一下<script type="math/tex">Dilworth</script>定理的内容，什么叫最小链划分？</p>
<p>我们将<script type="math/tex">S</script>中的所有元素划分成若干条链，使每个元素都在且仅在唯一一条链中，叫链划分。</p>
<h2 id="链"><a href="#链" class="headerlink" title="链"></a>链</h2><p>什么是链？</p>
<p>我们假设在若干元素构成一个集合，那么，这个集合是链当且仅当这个集合的所有元素两两是可比的。换句话说，你可以看成是<script type="math/tex">DAG</script>上某条路径上的元素。</p>
<h2 id="反链"><a href="#反链" class="headerlink" title="反链"></a>反链</h2><p>那么，什么是反链？</p>
<p>正如名字一样，反链和链的定义恰好相反，对于一个集合，它是反链当且仅当这个集合里的元素两两都是<strong>不可比的</strong>。换句话说，这个集合里的任何两个元素无法联通。大家可以脑补一下。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>那么，了解了这两个知识以后，这个定理的内容就很清晰了，也就是说，我们将一个偏序集<script type="math/tex">S</script>划分为若干个小集合，使得每个小集合里的元素构成一条链，这个最小的划分数量，等于这个偏序集最长的反链的长度。</p>
<p>这个很有用，可以把一些看起来很不可做的题目转化为十分简单的题目。</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3997">TJOI2015 组合数学</a></p>
<p>看起来很不好做，对吧？</p>
<p>我们定义这样一个偏序，其实是定义一个<script type="math/tex">DAG</script>，对于每个点<script type="math/tex">(i,j)</script>，我们把它拆成<script type="math/tex">val[i][j]</script>个点。</p>
<p>这样就构成了一个新的点集。</p>
<p>然后对于新点集中每个点，向它所能到达的所有的点连一条有向边，这样，就构成了一个<script type="math/tex">DAG</script>，那么，每一条路径，就是一条链，题目所求即这个<script type="math/tex">DAG</script>的最小链划分，由<script type="math/tex">Dilworth</script>定理，这个就等于<script type="math/tex">DAG</script>的最长反链的长度。</p>
<p>回到题目所给的模型，什么是这个<script type="math/tex">DAG</script>的反链？</p>
<p>换句话说，就是网格图中两两不能到达的点。对于每个点，它右上角和左下角的矩形中的点都是两两无法到达的，我们就是要找到一条路径，选的点从右上到左下，使点权的和最大（因为这个时候，每个点所拆成的点都两两不可到达，所以直接全部加上就好了）。这个，就直接<script type="math/tex">DP</script>了。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, m, a[maxN + <span class="number">1</span>][maxN + <span class="number">1</span>];</span><br><span class="line">LL f[maxN + <span class="number">1</span>][maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>( !<span class="built_in">isdigit</span>( ch ) ) &#123; <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">isdigit</span>( ch ) ) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> num * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">        n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) a[i][j] = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= <span class="number">1</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j + <span class="number">1</span>] + a[i][j];</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i][j + <span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[n][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈CDQ分治</title>
    <url>/2019/01/13/%E6%B5%85%E8%B0%88CDQ%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<h1 id="CDQ分治"><a href="#CDQ分治" class="headerlink" title="CDQ分治"></a>CDQ分治</h1><p>这是来解决三维偏序的题的，那么什么是三维偏序呢？</p>
<p>具体来说，就是有n个三元组<script type="math/tex">(a,b,c)</script>,求</p>
<script type="math/tex; mode=display">
f(i)=(a_j<=a_i \&\&b_j<=b_i\&\&c_j<=c_i)</script><p>的<script type="math/tex">j</script>的个数。</p>
<span id="more"></span>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>首先，我们考虑先把a从小到大来排序，这样，在后面的操作中，就不用再考虑a的大小关系了；</p>
<p>然后呢？ 我们的CDQ分治就上场了</p>
<p>对于一个子序列<script type="math/tex">(l,r)</script>，我们把它分为<script type="math/tex">(l,mid)</script>和<script type="math/tex">(mid+1,r)</script>两个子序列分治，在每一个分治中把b从小到大排好序,就是这样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void cdq(int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">    if(l==r) ...(统计单点贡献) return;</span><br><span class="line">    int mid=(l+r)&gt;&gt;1;</span><br><span class="line">    cdq(l,mid); cdq(mid+1,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑此时，<script type="math/tex">(l,mid)</script>和<script type="math/tex">(mid+1,r)</script>都其内部的b已经是有序的了；</p>
<p>那么有人问：b是有序的，那a不就变成乱序的了吗？</p>
<p>对啊，a的确变成乱序的了，但这只是在<script type="math/tex">(l,mid)</script>和<script type="math/tex">(mid+1,r)</script>中是乱序的，但就现在要操作的序列<script type="math/tex">(l,r)</script>来看，<script type="math/tex">(l,mid)</script>中的所有的a都是小于<script type="math/tex">(mid+1,r)</script>中的a的；</p>
<p>而cdq的操作，就是来计算<script type="math/tex">(l,mid)</script>对<script type="math/tex">(mid+1,r)</script>的贡献，所以并不影响统计</p>
<p>下面，我们就对<script type="math/tex">(l,r)</script>进行统计：</p>
<p>考虑归并排序，一个指针 i 指向l,一个指针 j 指向mid+1，再用一个tmp数组来存临时；</p>
<p>当<script type="math/tex">b[i]<=b[j]</script>时，说明<script type="math/tex">i</script>对<script type="math/tex">j</script>可能有贡献（因为还不知道c的情况），就先把它放到一个树状数组里；</p>
<p>这个树状数组又是干什么的呢？</p>
<p>我们考虑二维偏序时,先将<script type="math/tex">a</script>排序，然后<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(auto b)</span><br><span class="line">    ans+=query(b),change(b,1);</span><br></pre></td></tr></table></figure></p>
<p>这样，每次动态维护这个树状数组，就能求出<script type="math/tex">b[i]<=b[j]</script>的个数了；</p>
<p>三维偏序也是一个想法，对于<script type="math/tex">(mid+1,r)</script>中的某一个<script type="math/tex">j(mid+1<=j<=r)</script>来说，由于<script type="math/tex">(l,mid)</script>中的b是排好序的，所以只要找到一个<script type="math/tex">b[i]>b[j]</script>的，那么对于后面的<script type="math/tex">i</script>都必定对<script type="math/tex">j</script>产生不了贡献；</p>
<p>这个时候就可以统计<script type="math/tex">(l,mid)</script>中对<script type="math/tex">j</script>的贡献了，并把<script type="math/tex">j</script>的指针下移了；</p>
<p>怎么统计贡献呢，很简单，树状数组里不是已经存了<script type="math/tex">(l,i-1)</script>中的c的值了吗，只要查询在树状数组里有多少个值<script type="math/tex"><=c[j]</script>的就可以了，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i=l,j=mid+1,tot=l;//tot:临时数组的指针</span><br><span class="line">while(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">    if(b[i]&lt;=b[j]) change(c[i],cnt[i]),...(copy),i++;//cnt[i]后面再解释</span><br><span class="line">    else ans[j]+=query(c[j]),...(copy),j++;</span><br></pre></td></tr></table></figure>
<p>最后像归并排序那样，但是要注意先移动<script type="math/tex">j</script>,因为有可能<script type="math/tex">j</script>还没有被统计完，要继续统计，再移动<script type="math/tex">i</script>，最后把原数组赋值成临时数组就好了；</p>
<p>注意，树状数组用完是要清空的，但是不能用<script type="math/tex">memset</script>,这样就T飞了，我是暴力一个个清空的。</p>
<p>大体的过程基本上就是这样，但是还是有很多细节要注意的：</p>
<p>首先，CDQ不能处理重复的三元组，所以在排序的时候要去重，再用<script type="math/tex">cnt[i]</script>来保存第i个三元组出现的次数，这就是上面留的坑，所以每次统计的时候要把<script type="math/tex">cnt[i]</script>加入树状数组；</p>
<p>同时，相同的对自己本身也有贡献，这就是当<script type="math/tex">l==r</script>时要统计一下自身贡献的原因；</p>
<p>还有，就是排序的时候要注意，不能只排<script type="math/tex">a</script>,要多关键字排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool comp(Node a,Node b)</span><br><span class="line">&#123;</span><br><span class="line">    return a.a&lt;b.a || (a.a==b.a&amp;&amp;a.b&lt;b.b) || (a.a==b.a&amp;&amp;a.b==b.b&amp;&amp;a.c&lt;b.c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，基本上就没什么了吧</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN=<span class="number">1e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,res;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,c,cnt,ans;</span><br><span class="line">&#125;num[maxN*<span class="number">2</span>+<span class="number">1</span>],tmp[maxN*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> C[maxN*<span class="number">4</span>+<span class="number">1</span>],ans[maxN*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) num=(num&lt;&lt;<span class="number">3</span>)+(num&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> num*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x&amp;(-x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=k;i+=<span class="built_in">lowbit</span>(i)) C[i]+=num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;<span class="number">0</span>;i^=<span class="built_in">lowbit</span>(i)) ans+=C[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(Node a,Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.a&lt;b.a || (a.a==b.a&amp;&amp;a.b&lt;b.b) || (a.a==b.a&amp;&amp;a.b==b.b&amp;&amp;a.c&lt;b.c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123; num[l].ans+=num[l].cnt<span class="number">-1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cdq</span>(l,mid); <span class="built_in">cdq</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">int</span> i=l,j=mid+<span class="number">1</span>,tot=l;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">        <span class="keyword">if</span>(num[i].b&lt;=num[j].b) <span class="built_in">change</span>(num[i].c,num[i].cnt),tmp[tot++]=num[i++];</span><br><span class="line">        <span class="keyword">else</span> num[j].ans+=<span class="built_in">query</span>(num[j].c),tmp[tot++]=num[j++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) num[j].ans+=<span class="built_in">query</span>(num[j].c),tmp[tot++]=num[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=l;k&lt;i;k++) <span class="built_in">change</span>(num[k].c,-num[k].cnt);</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) tmp[tot++]=num[i++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=l;k&lt;=r;k++) num[k]=tmp[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),k=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) num[i].a=<span class="built_in">read</span>(),num[i].b=<span class="built_in">read</span>(),num[i].c=<span class="built_in">read</span>(),num[i].cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">sort</span>(num+<span class="number">1</span>,num+n+<span class="number">1</span>,comp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span> || !(num[i].a==num[i<span class="number">-1</span>].a&amp;&amp;num[i].b==num[i<span class="number">-1</span>].b&amp;&amp;num[i].c==num[i<span class="number">-1</span>].c)) num[++res]=num[i];</span><br><span class="line">        <span class="keyword">else</span> num[res].cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cdq</span>(<span class="number">1</span>,res);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=res;i++) ans[num[i].ans]+=num[i].cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Z_Algorithm</title>
    <url>/2020/02/25/%E6%B5%85%E8%B0%88Z-Algorithm/</url>
    <content><![CDATA[<h1 id="Z-Algorithm（ex-kmp"><a href="#Z-Algorithm（ex-kmp" class="headerlink" title="Z_Algorithm（ex_kmp)"></a>Z_Algorithm（ex_kmp)</h1><p>什么是<script type="math/tex">Z</script>算法？</p>
<p>对于一个字符串<script type="math/tex">s</script>，我们构造出一个数组<script type="math/tex">z</script>，<script type="math/tex">z[i]</script>表示<script type="math/tex">s</script>以<script type="math/tex">i</script>为开头的后缀与<script type="math/tex">s</script>的最长公共前缀（<script type="math/tex">lcp</script>）。</p>
<p>构造这个<script type="math/tex">z</script>数组的过程，就称为<script type="math/tex">Z-Algorithm</script>。</p>
<p>另外，<script type="math/tex">Z-Algorithm</script>是国外的说法，国内把称为<script type="math/tex">exkmp</script>，两者实际完全等价。</p>
<span id="more"></span>
<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>首先，可以确定的是<script type="math/tex">z[1]=n</script>，因为这个情况比较特殊，所以我们后面不做考虑。</p>
<p>然后，我们假设我们处理到第<script type="math/tex">i</script>位，定义<script type="math/tex">r</script>表示之前所有处理的位数（不包括<script type="math/tex">1</script>）中<script type="math/tex">j+z[j]-1</script>最大的值，记录<script type="math/tex">l</script>为当<script type="math/tex">z[j]</script>为<script type="math/tex">r</script>时的<script type="math/tex">j</script>的值。</p>
<p>我们的目标，是像<script type="math/tex">kmp</script>一样，尽量地用上我们已经算出来的值。</p>
<p>首先，如果<script type="math/tex">i>r</script>，那么没有办法，只能从当前位置一个个暴力匹配，最后看<script type="math/tex">l,r</script>是否要更新即可。</p>
<p>如果<script type="math/tex">i<=r</script>，因为<script type="math/tex">s[l,r]</script>存在<script type="math/tex">s</script>的一个前缀与它相等，那么说明<script type="math/tex">s[i,r]</script>在之前出现过！那么，我们就可以利用之前的答案！考虑<script type="math/tex">s[i,r]</script>之前出现在哪，容易发现，就是<script type="math/tex">s[i-l+1,r-l+1]</script>（因为<script type="math/tex">s[l,i-1]</script>对应的是<script type="math/tex">s[1,i-l]</script>），那么我们就可以利用<script type="math/tex">z[i-l+1]</script>的信息！</p>
<p>那么，我们就可以令<script type="math/tex">z[i]=min(z[i-l+ 1],r-i+1)</script>，为什么要取<script type="math/tex">min</script>？因为我们只能保证<script type="math/tex">s[i,r]=s[i-l+1,r-l+1]</script>，但是再后面就无从得知了，所以，后面还要暴力匹配看<script type="math/tex">z[i]</script>能否扩大。</p>
<p>最后，我们再用现有的<script type="math/tex">i,z[i]</script>看能否更新<script type="math/tex">l,r</script>即可！</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_z</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    z[<span class="number">1</span>] = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>, l = <span class="number">0</span>, r = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span>(i &lt;= r) z[i] = <span class="built_in">min</span>(z[i - l + <span class="number">1</span>], r - i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(i + z[i] &lt;= n &amp;&amp; s[ i + z[i] ] == s[ z[i] + <span class="number">1</span> ]) z[i] ++;</span><br><span class="line">        <span class="keyword">if</span>(i + z[i] - <span class="number">1</span> &gt; r) l = i, r = i + z[i] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>时间复杂度，是<script type="math/tex">O(n)</script>的。</p>
<p>为什么呢？</p>
<p>证明：</p>
<p>我们只需要判断内层<script type="math/tex">while</script>循环的复杂度，因为别的都是常数。</p>
<p>我们来证明，每次只要运行内层<script type="math/tex">while</script>循环，必然会使<script type="math/tex">r</script>增加。</p>
<p>我们分情况讨论：</p>
<p>首先，如果<script type="math/tex">i>r</script>，那么显然，每次循环必然会使<script type="math/tex">r</script>增加，无需讨论。</p>
<p>如果<script type="math/tex">i<=r</script>，那么我们设一开始的<script type="math/tex">z[i]</script>值为<script type="math/tex">z_0</script>，那么有两种情况：</p>
<p>一、 <script type="math/tex">z_0=r-i+1</script>，那么我们每次循环，使得<script type="math/tex">z[i]</script>增加，必然也会使得<script type="math/tex">r</script>增加（因为<script type="math/tex">r=i+z[i]-1</script>）。</p>
<p>二、如果<script type="math/tex">z_0 < r-i+1</script>，那么<script type="math/tex">z_0=z[i-l+1]</script>，那么，我们来证明此时必然不会循环。</p>
<p>考虑反证法，如果有循环使得<script type="math/tex">z[i]>z_0</script>，那么就说明存在<script type="math/tex">z_0+1</script>使得<script type="math/tex">s[z_0+1]=s[i+z_0]</script>，而因为<script type="math/tex">i+z_0<r+1</script>（假设条件），可以得知<script type="math/tex">i+z_0<=r</script>，而这个位置还在<script type="math/tex">[i,r]</script>以内，也就是说以<script type="math/tex">i-l+1</script>为开头的后缀中也有这个字符，那么<script type="math/tex">z[i-l+1]</script>就不可能是<script type="math/tex">z_0</script>，矛盾！</p>
<p>所以此时循环不会进行。</p>
<p>综上，我们证明了每次循环都必定会让<script type="math/tex">r</script>增加，而<script type="math/tex">r</script>最多只会增长<script type="math/tex">n</script>次，所以时间复杂度是<script type="math/tex">O(n)</script>的。</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>我们只求出了对于一个字符串<script type="math/tex">s</script>的<script type="math/tex">z</script>是没有用的，我们要通过这个来求另一个字符串<script type="math/tex">t</script>的所有后缀与<script type="math/tex">s</script>的最长公共前缀。</p>
<p>方法很简单，就是我们对<script type="math/tex">s+a+t</script>（<script type="math/tex">a</script>是某个<script type="math/tex">s</script>和<script type="math/tex">t</script>都没有的字符）整个跑一遍<script type="math/tex">Z-Algorithm</script>，然后对<script type="math/tex">t</script>中每个位置直接访问其在新串中的位置的<script type="math/tex">z</script>数组就可以了。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈K-D Tree</title>
    <url>/2019/02/03/%E6%B5%85%E8%B0%88K-D-Tree/</url>
    <content><![CDATA[<h1 id="什么是K-D-Tree"><a href="#什么是K-D-Tree" class="headerlink" title="什么是K-D Tree?"></a>什么是K-D Tree?</h1><p>K-D Tree是一类玄学的暴力数据结构（有的时候复杂度玄学），但是，在随机情况下，它跑的非常快，是骗分的好方法（逃；</p>
<p>K-D Tree一般可以解决多维数点，最近点对，k近点对等问题，还是非常实用和高效的，它的单次查询时间复杂度为</p>
<script type="math/tex; mode=display">
O(kn^{1-\frac{1}{k}}+logn)</script><p>其中k是维数，如果是1维，就是logn（其实就是线段树），二维就是<script type="math/tex">n\sqrt{n}</script>。</p>
<span id="more"></span>
<h1 id="K-D-Tree的构造"><a href="#K-D-Tree的构造" class="headerlink" title="K-D Tree的构造"></a>K-D Tree的构造</h1><p>一个数据结构之所以高效，就在于它的构造，K-D Tree的高效，就在于<strong>把点按照某种特定的规则建成一种二叉树</strong></p>
<p>什么规则呢？</p>
<p>对于这棵树上的一个节点，相当于一个超平面，把空间分割成两块，其中一边，是这个节点的左儿子，另一边，则是它的右儿子，满足对于划分的依据维度第i维，使得左儿子的p[i]&lt;p[mid]&lt;右儿子的p[i]；</p>
<p>具体地说，对于当前区间[l,r]（这里的区间指点的序号区间，不是坐标区间），我们算出这些点每一维度的方差，取方差最大的那一维，设为d，作为我们的分裂方式，然后，我们将整个区间按照d维从小到大排序，取中间的那个点mid为分裂点，再以[l,mid-1]为左子树建树，[mid+1,r]为右子树建树。</p>
<p>这个建树过程，是严格的<script type="math/tex">O(nlogn)</script>。注意，我们每次找中位数的时候，可以不用排序，C++中的STL有一个叫nth_element的函数，具体用法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">如果我们要查[l,r]中第k大的数：</span><br><span class="line"><span class="built_in">nth_element</span>(a+l,a+k,a+r+<span class="number">1</span>,comp);<span class="comment">//comp:比较方式</span></span><br></pre></td></tr></table></figure>
<p>它可以保证第k大的数在a[k]的位置上，但是整个区间并不是有序的，可以保证k左边的都小于k，右边的都大于k，复杂度为<script type="math/tex">O(r-l+1)</script>；</p>
<p>这样，这棵K-D Tree就建好了。</p>
<h1 id="K-D-Tree的查询"><a href="#K-D-Tree的查询" class="headerlink" title="K-D Tree的查询"></a>K-D Tree的查询</h1><p>建好了树，我们怎么查询呢？其实，查询就是一个加了剪枝的暴力。</p>
<p>查询的时候，假设我们要查的点为op，查到了区间[l,r]，其根节点为mid，那么，我们先算出op到mid的距离，并更新答案，假设[l,r]是从d维划分的，那么，如果op的第d维的坐标小于mid第d维的坐标，就往mid的左子树找，但是，并不一定在左子树，找完以后还要判断一下，如果以op为圆心，当前的答案ans为半径的话，会不会与mid点的右半边有交，如果有，就还要往右边查询一下，因为有可能最近点在右子树，说白了，K-D Tree就是变化一下查询顺序，用当前的答案来剪枝，所以，只要出题人用点心，就可以轻松地把你卡到单次询问<script type="math/tex">O(n)</script>（在k近点对的时候），普通的最近点对最坏复杂度好像是<script type="math/tex">O(n\sqrt{n})</script>，但是，如果你想不到其他方法，这也是一个骗高分的好方法啊，查询的部分代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cur=split[mid];<span class="comment">//split[mid]为[l,r]的划分方式</span></span><br><span class="line"><span class="keyword">int</span> radius=(op.p[cur]-a[mid].p[cur])*(op.p[cur]-a[mid].p[cur]);</span><br><span class="line"><span class="keyword">if</span>(op.p[cur]&lt;a[mid].p[cur])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">query</span>(l,mid<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(radius&lt;=ans) <span class="built_in">query</span>(mid+<span class="number">1</span>,r);<span class="comment">//radius就是op到右半平面的距离</span></span><br><span class="line">&#125;<span class="keyword">else</span> ...<span class="comment">//同理</span></span><br></pre></td></tr></table></figure>
<p>以上，就是K-D Tree的基本内容。</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2966">hdu2966</a></p>
<p>平面最近点对的裸题，但是还是有要注意的地方，例如，它并不是给你一个点，让你找它的最近点，而是让你找这n个点中每个点的最近点，因此，必须要把本身给排除掉。</p>
<p>代码我就不给了，根据后面的模板随便改一下就可以了。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>具体的看注释吧:</p>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN=<span class="number">1e5</span> + <span class="number">100</span>,K=<span class="number">2</span>;<span class="comment">//K的值根据情况改动</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">10</span>],id;    </span><br><span class="line">&#125;a[maxN*<span class="number">2</span>+<span class="number">1</span>],op,point,tmp[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> now,split[maxN+<span class="number">1</span>],n;</span><br><span class="line"><span class="keyword">int</span> ans,k,t;</span><br><span class="line"><span class="keyword">bool</span> use[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">double</span> var[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) num=(num&lt;&lt;<span class="number">3</span>)+(num&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> num*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(Node a,Node b)</span> </span>&#123;<span class="keyword">return</span> a.p[now]&lt;b.p[now];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>; now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> pos=<span class="number">1</span>;pos&lt;=K;pos++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> ave=<span class="number">0.0</span>; var[pos]=<span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++) ave+=a[i].p[pos];</span><br><span class="line">        ave/=(r-l+<span class="number">1</span>);<span class="comment">//计算平均数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++) var[pos]+=(a[i].p[pos]-ave)*(a[i].p[pos]-ave);<span class="comment">//方差</span></span><br><span class="line">        <span class="keyword">if</span>(!now||var[pos]&gt;var[now]) now=pos;<span class="comment">//更新划分方案</span></span><br><span class="line">    &#125;</span><br><span class="line">    split[mid]=now;<span class="comment">//划分方案</span></span><br><span class="line">    <span class="built_in">nth_element</span>(a+l,a+mid,a+r+<span class="number">1</span>,comp);<span class="comment">//中位数</span></span><br><span class="line">    <span class="built_in">build</span>(l,mid<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">build</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> dis=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=K;i++) dis+=(op.p[i]-a[mid].p[i])*(op.p[i]-a[mid].p[i]);</span><br><span class="line">    <span class="keyword">if</span>(!use[a[mid].id]&amp;&amp;dis&lt;ans)<span class="comment">//更新答案</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans=dis; </span><br><span class="line">        point=a[mid];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cur=split[mid];</span><br><span class="line">    <span class="keyword">int</span> radius=(op.p[cur]-a[mid].p[cur])*(op.p[cur]-a[mid].p[cur]);<span class="comment">//计算op到分裂平面的距离</span></span><br><span class="line">    <span class="keyword">if</span>(op.p[cur]&lt;a[mid].p[cur])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">query</span>(l,mid<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(radius&lt;=ans) <span class="built_in">query</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">query</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">if</span>(radius&lt;=ans) <span class="built_in">query</span>(l,mid<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> int</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    k=<span class="number">1</span>;<span class="comment">//k指的是k近点</span></span><br><span class="line">    t=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        n=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=K;j++) a[i].p[j]=<span class="built_in">read</span>();<span class="comment">//K指的是维度大小</span></span><br><span class="line">            a[i].id=i; tmp[i]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(use,<span class="literal">false</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(use));<span class="comment">//判断k近点的时候，要把已经找到的标记，防止重复</span></span><br><span class="line">            op=tmp[i]; use[i]=<span class="number">1</span>;<span class="comment">//将自己设为1（仅限于hdu这一题）</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                ans=<span class="number">2e18</span>;</span><br><span class="line">                <span class="built_in">query</span>(<span class="number">1</span>,n);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans); use[point.id]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说，K-D Tree可以应用于多维数点中，在偏序类题目中也有很大的作用，虽然复杂度比较玄学，但仍是拿高分的好方法，比如去年的APIO，用K-D Tree固然复杂度不对，但是也能拿到80+的高分，也许就是金银牌线的差别呢~~还是学好它吧，也是掌握了一种思想呢</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>K-D Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈bitset</title>
    <url>/2019/01/30/%E6%B5%85%E8%B0%88bitset/</url>
    <content><![CDATA[<h1 id="什么是bitset"><a href="#什么是bitset" class="headerlink" title="什么是bitset?"></a>什么是bitset?</h1><p>bitset是一种bug般的STL，可以用于骗分，卡常等，它实际上是一个类似布尔数组一样的东西，但是它每个位置只占1bit，而且可以整体移动（类似于状压，但是空间要小很多），而且，它能把你的时间复杂度/32或/64（看计算机的位数）。</p>
<span id="more"></span>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>首先，我们要知道怎样定义它，它存在于bitset库中，如果要定义的话，直接在&lt;&gt;内定义大小即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bitset&lt;1000&gt; s;<span class="comment">//定义一个1000位的bitset</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h1><p>实际上，bitset支持所有的位运算，基本实现跟状压差不多，但是，这是有时间消耗的：</p>
<p>例如，我们定义一个bitset&lt; N &gt; s，那么s&lt;&lt;k会消耗的时间复杂度为<strong>O(N/w)</strong>(w为计算机位数)。</p>
<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><p>bitset中有很多内置的常用函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">bitset&lt;N&gt; s;</span><br><span class="line">s.<span class="built_in">size</span>()	返回大小（位数）</span><br><span class="line">s.<span class="built_in">count</span>()	返回<span class="number">1</span>的个数（复杂度为<span class="built_in">O</span>(N/w)）</span><br><span class="line">s.<span class="built_in">any</span>()		返回是否有<span class="number">1</span></span><br><span class="line">s.<span class="built_in">none</span>()	返回是否没有<span class="number">1</span></span><br><span class="line">s.<span class="built_in">set</span>()		全部变成<span class="number">1</span></span><br><span class="line">s.<span class="built_in">set</span>(p)	将p + <span class="number">1</span>位变成<span class="number">1</span>（记住，是p+<span class="number">1</span>为，因为bitset从<span class="number">0</span>位开始）</span><br><span class="line">s.<span class="built_in">set</span>(p,x)	将p + <span class="number">1</span>为变成x</span><br><span class="line">s.<span class="built_in">reset</span>()	全部变成<span class="number">0</span></span><br><span class="line">s.<span class="built_in">reset</span>(p)	将p + <span class="number">1</span>位变成<span class="number">0</span></span><br><span class="line">s.<span class="built_in">flip</span>()	全部取反</span><br><span class="line">s.<span class="built_in">flip</span>(p)	将第p + <span class="number">1</span>为取反</span><br><span class="line">s.<span class="built_in">to_ulong</span>()	返回它转换为 <span class="keyword">unsigned</span> <span class="keyword">long</span> 的结果，超出范围则报错</span><br><span class="line">s.<span class="built_in">to_ullong</span>()	同上，返回 <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span></span><br><span class="line">s.<span class="built_in">to_string</span>()	同上，返回 string</span><br></pre></td></tr></table></figure>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.luogu.org/problemnew/show/P3674"><strong>小清新人渣的本愿</strong></a></p>
<p>题面就无力吐槽了，但是的确是一道bitset+莫队的好题</p>
<p>首先，对于差：我们考虑，我们有这样一个bitset，它记录了[l,r]中所有数有或无的状态，那么</p>
<script type="math/tex; mode=display">
如果存在a,b使a-b=x,则a=b+x</script><p>也就是说,b，b+x得同时存在，那么，我们用bitset，我们只需要考虑s&amp;(s&gt;&gt;x)是否存在1就可以了；</p>
<p>对于和：我们考虑</p>
<script type="math/tex; mode=display">
如果存在a,b使a+b=x,我们设b'=n-b,则a-b'=a+b-n=x-n</script><script type="math/tex; mode=display">
则b'=a+n-x</script><p>这就是说，我们考虑再计一个bitset，s2，与原来的记录相反，是记录n-x的状况，那么，说明s1中的a与s2中的a+n-x同时存在，即我们只要判断s1&amp;(s2&gt;&gt;(n-x))是否存在1就可以了；</p>
<p>而更令我们高兴的是，bitset中正好有一个s.any()，专门判断是否存在1，那么，就大功告成了；</p>
<p>最后，对于积：这个比较好办，我们只要枚举x的因数i（不超过<script type="math/tex">\sqrt{x}</script>个），再判断i与x/i是否同时存在就可以了。</p>
<p>其中，我们用莫队来不断更新s1,s2的值，就可以在<script type="math/tex">O(\frac{nm}{w})</script>的时间复杂度内算出答案（其实时间还是很紧的，但能过就行啦）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// luogu-judger-enable-o2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN=<span class="number">1e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> op,l,r,x,id;</span><br><span class="line">&#125;q[maxN+<span class="number">1</span>];</span><br><span class="line">bitset&lt;maxN&gt; s1,s2;</span><br><span class="line"><span class="keyword">int</span> n,m,a[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> block,belong[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> res[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) num=(num&lt;&lt;<span class="number">3</span>)+(num&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> num*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(Node a,Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> belong[a.l]^belong[b.l] ? belong[a.l]&lt;belong[b.l] : belong[a.l]&amp;<span class="number">1</span> ? a.r&lt;b.r : a.r&gt;b.r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">if</span>(!cnt[x]) s1[x]=s2[maxN-x]=<span class="number">1</span>; cnt[x]++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;cnt[x]--; <span class="keyword">if</span>(!cnt[x]) s1[x]=s2[maxN-x]=<span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(l&gt;q[i].l) <span class="built_in">add</span>(a[--l]);</span><br><span class="line">        <span class="keyword">while</span>(r&lt;q[i].r) <span class="built_in">add</span>(a[++r]);</span><br><span class="line">        <span class="keyword">while</span>(l&lt;q[i].l) <span class="built_in">del</span>(a[l++]);</span><br><span class="line">        <span class="keyword">while</span>(r&gt;q[i].r) <span class="built_in">del</span>(a[r--]);</span><br><span class="line">        <span class="keyword">int</span> x=q[i].x;</span><br><span class="line">        <span class="keyword">if</span>(q[i].op==<span class="number">1</span>) res[q[i].id]=(s1&amp;(s1&gt;&gt;x)).<span class="built_in">any</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(q[i].op==<span class="number">2</span>) res[q[i].id]=(s1&amp;(s2&gt;&gt;(maxN-x))).<span class="built_in">any</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j*j&lt;=x;j++)</span><br><span class="line">                    <span class="keyword">if</span>(x%j==<span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">if</span>(s1[j]&amp;&amp;s1[x/j]) &#123;res[q[i].id]=<span class="literal">true</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) res[i]?<span class="built_in">puts</span>(<span class="string">&quot;hana&quot;</span>):<span class="built_in">puts</span>(<span class="string">&quot;bi&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    block=n/<span class="built_in">sqrt</span>(m*<span class="number">2</span>/<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=<span class="built_in">read</span>(),belong[i]=(i<span class="number">-1</span>)/block+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) q[i].op=<span class="built_in">read</span>(),q[i].l=<span class="built_in">read</span>(),q[i].r=<span class="built_in">read</span>(),q[i].x=<span class="built_in">read</span>(),q[i].id=i;</span><br><span class="line">    <span class="built_in">sort</span>(q+<span class="number">1</span>,q+m+<span class="number">1</span>,comp);</span><br><span class="line">    <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>bitset</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Matrix-Tree定理</title>
    <url>/2019/02/03/%E6%B5%85%E8%B0%88matrix-tree%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h1 id="行列式的定义"><a href="#行列式的定义" class="headerlink" title="行列式的定义"></a>行列式的定义</h1><p>行列式指一个<script type="math/tex">n</script>​阶方阵（行数和列数相等）的值，记为<script type="math/tex">\det(A)</script>​或<script type="math/tex">|A|</script>​。</p>
<p>求行列式的公式为:</p>
<script type="math/tex; mode=display">
\det(A)=\sum_P(-1)^{T(P)}A_{1,p1}...A_{n,pn}</script><p>其中，<script type="math/tex">P</script>为<script type="math/tex">1,..,N</script>任意的一个排列，<script type="math/tex">T(P)</script>表示排列<script type="math/tex">P</script>的逆序对数，那个求和式的每一项就是从矩阵中选出<script type="math/tex">n</script>个数，使他们的行列都不重合。</p>
<span id="more"></span>
<h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><ol>
<li><p>交换矩阵的两行（列），行列式变号</p>
</li>
<li><p>如果矩阵有两行（列）完全相同，则行列式为<script type="math/tex">0</script></p>
</li>
<li><p>如果某一行（列）都乘以同一个数<script type="math/tex">k</script>，那么新行列式的值等于原行列式的值乘<script type="math/tex">k</script></p>
</li>
<li><p>如果矩阵有两行（列）成比例（比例系数为<script type="math/tex">k</script>），那么行列式为<script type="math/tex">0</script></p>
</li>
<li><p>如果把矩阵某一行（列）加上另一行（列）的<script type="math/tex">k</script>倍，行列式的值不变</p>
</li>
</ol>
<h1 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h1><p>对于一个行列式，我们根据<strong>性质5</strong>，将它转化为一个上三角矩阵（左下半部分全是0），那么，<strong>其行列式的值就等于对角线上数的乘积</strong>（带入求行列式公式即证）。</p>
<p>这样，我们通过高斯消元的办法，把一个矩阵化成这个形式，再把对角线乘起来就可以了。</p>
<h1 id="Matrix-Tree定理无向图形式"><a href="#Matrix-Tree定理无向图形式" class="headerlink" title="Matrix-Tree定理无向图形式"></a>Matrix-Tree定理无向图形式</h1><p>这是一个计算一个无向图的生成树个数的定理，它的计算规则如下：</p>
<p>设<script type="math/tex">D</script>为度数矩阵，其中</p>
<script type="math/tex; mode=display">
D[i][j]=0(i\ne j),D[i][i]=deg[i]</script><p>设<script type="math/tex">A</script>为邻接矩阵。</p>
<p>定义<strong>基尔霍夫矩阵</strong><script type="math/tex">K=D-A</script></p>
<p>那么，最后的答案就是<script type="math/tex">K</script>在<script type="math/tex">(i,i)</script>处的余子式。</p>
<p>实际上，Matrix-Tree定理本质上是在求</p>
<script type="math/tex; mode=display">
\sum_{T}\prod_{e\in T}val_e</script><p>其中，<script type="math/tex">T</script>是生成树，<script type="math/tex">e</script>是边。换句话说，这个定理本质上是求这张图中所有生成树边权乘积之和，如果我们只是想求生成树的个数，只需要把每条边边权设成<script type="math/tex">1</script>即可。</p>
<p>否则，邻接矩阵<script type="math/tex">(i,j)</script>存的是所有<script type="math/tex">(i,j)</script>边的边权和，度数矩阵<script type="math/tex">(i,i)</script>存的是所有与<script type="math/tex">i</script>相邻的边的边权和。</p>
<h1 id="Matrix-Tree定理有向图形式"><a href="#Matrix-Tree定理有向图形式" class="headerlink" title="Matrix-Tree定理有向图形式"></a>Matrix-Tree定理有向图形式</h1><p>有向图的生成树分为两种：内向树和外向树。</p>
<p>内向树指树上所有的边都是孩子指向父亲，外向树则是所有边都是父亲指向儿子。</p>
<p>那么，设<script type="math/tex">D_{out}</script>表示所有点的出度矩阵，<script type="math/tex">D_{in}</script>表示所有点的入度矩阵，换句话说</p>
<script type="math/tex; mode=display">
D_{out}[i][i]=\sum_{(u,v)\in E,u=i}val[u][v]\\
D_{in}[i][i]=\sum_{(u,v)\in E,v=i}val[u][v]</script><p>此时，内向树的基尔霍夫矩阵为<script type="math/tex">K_{out}=D_{out}-A</script>，外向树为<script type="math/tex">K_{in}=D_{in}-A</script>。如果我们想要求出以<script type="math/tex">rt</script>为根的内向树（外向树）个数，那么只需要求<script type="math/tex">K_{out}</script>（<script type="math/tex">K_{in}</script>）在<script type="math/tex">(rt,rt)</script>​处的余子式即可。</p>
<h1 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h1><p>那么，如何证明Matrix-Tree定理呢？</p>
<p>内向树，外向树都差不多，而无向图也只是把无向边看成两条有向边，计算内向树（外向树）得到的。因此，我们只讨论内向树的情况。</p>
<p>我们先不讨论自环的情况，实际上在讲完证明后我们可以发现即使出现了自环也没有关系。</p>
<p>首先，考虑对角线上每个点出度的乘积，它的意义在于给每个点找一条到父亲的边作为树边。但是显然这样构造出来的可能会出现若干环，因此我们的目标是通过容斥把存在环的方案去掉。</p>
<p>考虑通过行列式算出来的是什么，它枚举了一个排列，而我们知道，每个排列都对应着一个环分解，因此，枚举排列，本质上是枚举了一个环的集合，相当于容斥中钦定一个环的集合，然后对于所有<script type="math/tex">p_i=i</script>的点，即乘上的是出度，即我们把他们随便选父亲的出边。那么，考虑每个排列的贡献系数是什么？行列式前面这个排列的贡献系数是<script type="math/tex">-1</script>的逆序对数次方，实际上逆序对数只是一种表达方式，它表示的是这个排列的奇偶性。</p>
<p>可以证明，对于任意一个排列，不管怎么对换（即交换两个元素）使其最终成为单位排列，交换次数的奇偶性是相同的，因此排列也被分为奇排列和偶排列，而逆序对数，即每次可以交换相邻两个元素而成为单位排列的操作次数。</p>
<p>而排列的奇偶性我们还可以通过另外的一种计算方式，即对于环分解的每个环考虑，那么一个大小为<script type="math/tex">k</script>​​​的环需要进行<script type="math/tex">k-1</script>​​​​次对换拆掉，假设排列中有<script type="math/tex">k</script>​​​个<strong>大小大于<script type="math/tex">1</script>​​​的环</strong>，这些环的大小和为<script type="math/tex">s</script>​​，那么行列式中一个排列前面的系数应该是<script type="math/tex">(-1)^{s-k}</script>​，而注意到矩阵中每条边前面的系数都是<script type="math/tex">-1</script>​​，而这些环中显然有<script type="math/tex">s</script>​条边，因此系数前面还会乘上<script type="math/tex">(-1)^s</script>​​，因此对于一种方案，系数为<script type="math/tex">(-1)^{2s-k}=(-1)^k</script>​，即<script type="math/tex">-1</script>​​的<strong>钦定的环集合大小</strong>次方。</p>
<p>那么，对于一种有<script type="math/tex">k</script>个环的方案，它的系数是<script type="math/tex">\sum_{i=0}^k(-1)^i\binom{k}{i}</script>，这个值在<script type="math/tex">k=0</script>时为<script type="math/tex">1</script>，而当<script type="math/tex">k>0</script>时为<script type="math/tex">0</script>。因此，只有当方案中没有环的时候才会被计算到贡献。</p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>注意内向树，外向树的度数矩阵到底是出度还是入度，其实如果会了证明那么就很好理解，因为第一步是给每个点选一个父亲边，而内向树只能在出边中选，外向树只能在入边中选。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Min-max容斥</title>
    <url>/2019/07/25/%E6%B5%85%E8%B0%88min-max%E5%AE%B9%E6%96%A5/</url>
    <content><![CDATA[<h1 id="Min-max容斥"><a href="#Min-max容斥" class="headerlink" title="Min-max容斥"></a>Min-max容斥</h1><p>早就听闻Min-max容斥的大名，今天学习了一下，感觉妙不可言。</p>
<p>给定集合<script type="math/tex">S</script>，设<script type="math/tex">max(S)</script>为<script type="math/tex">S</script>中的最大值，<script type="math/tex">min(S)</script>为<script type="math/tex">S</script>中的最小值，那么我们可以得到：</p>
<script type="math/tex; mode=display">
max(S)=\sum_{T\subset S}(-1)^{|T|-1}min(T)</script><span id="more"></span>
<p>举个例子：</p>
<script type="math/tex; mode=display">
max(a,b)=min(a)+min(b)-min(a,b)\\
max(a,b,c)=min(a)+min(b)+min(c)-min(a,b)-min(b,c)-min(a,c)+min(a,b,c)</script><p>我们来看一下，假设<script type="math/tex">a<=b<=c</script>，则后面那个式子右边等于</p>
<script type="math/tex; mode=display">
a+b+c-a-b-a+a=c=max(a,b,c)</script><p>是不是感觉很神奇？</p>
<p><strong>证明：</strong></p>
<p>我们考虑化简右边。</p>
<p>我们将集合中所有元素从小到大排好序，然后考虑每个元素的贡献。</p>
<p>首先，最大的那个元素贡献显然为<script type="math/tex">1</script>，因为只有只存在它本身的集合的<script type="math/tex">min</script>才是它。</p>
<p>那么，其他的元素的贡献是什么呢？</p>
<p>是它在排好序的序列中右边的数构成的所有子集（因为这样的话最小值才是它）。</p>
<p>当<script type="math/tex">n</script>为奇数时，我们考虑每个子集的贡献，对于任意一个子集，我们考虑它的补集，这个补集大小的奇偶性必然与这个子集相反，且每个子集和它的补集时一一对应的，所以只要有一个子集对答案有贡献，它的子集就立刻会产生相反的贡献，相互抵消，显然等式成立。</p>
<p>当<script type="math/tex">n</script>为偶数时（不为<script type="math/tex">0</script>），我们考虑集合中的一个数<script type="math/tex">x</script>，如果我们选的子集不包括<script type="math/tex">x</script>，剩下的数为奇数个，贡献为<script type="math/tex">0</script>，如果选了<script type="math/tex">x</script>，剩下的数还是为奇数，贡献也是<script type="math/tex">0</script>，所以等式仍然成立。</p>
<p>我们考虑对偶数的讨论中，我们必须要选出一个数再对剩下的数进行讨论，所以<script type="math/tex">0</script>不适用于这个证明，只有<script type="math/tex">0</script>是例外。</p>
<p>这样，我们就证明了结论。</p>
<p>其实，我们还证明了对于<script type="math/tex">\forall n>0</script>，有<script type="math/tex">C(n,0)+C(n,2)+...=C(n,1)+C(n,3)+...</script>。</p>
<h1 id="K-th-Min-max容斥"><a href="#K-th-Min-max容斥" class="headerlink" title="K-th Min-max容斥"></a>K-th Min-max容斥</h1><p>我们计<script type="math/tex">max_k(S)</script>表示<script type="math/tex">S</script>中第<script type="math/tex">k</script>大的元素，那么我们有：</p>
<script type="math/tex; mode=display">
max_k(S)=\sum_{T\subset S}(-1)^{|T|-k}C(|T|-1,k-1)min(T)</script><h1 id="期望的Min-max容斥"><a href="#期望的Min-max容斥" class="headerlink" title="期望的Min-max容斥"></a>期望的Min-max容斥</h1><p>由于期望的线性性，<script type="math/tex">min-max</script>容斥适用于期望。</p>
<script type="math/tex; mode=display">
E(max(S))=\sum_{T\subset S}(-1)^{|T|-1}E(min(T))\\
E(max_k(S))=\sum_{T\subset S}(-1)^{|T|-k}C(|T|-1,k-1)E(min(T))</script><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://cmwqf.github.io/2019/07/25/%E6%8C%89%E4%BD%8D%E6%88%96/">HAOI2015按位或</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈上下界网络流</title>
    <url>/2020/05/27/%E6%B5%85%E8%B0%88%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%BD%91%E7%BB%9C%E6%B5%81/</url>
    <content><![CDATA[<h1 id="上下界网络流"><a href="#上下界网络流" class="headerlink" title="上下界网络流"></a>上下界网络流</h1><p>在一类网络流问题中，我们对每条边的流量，不仅有上界限制，还有下界限制，即第<script type="math/tex">i</script>条边流量要在<script type="math/tex">[l_i,r_i]</script>中，由此引申出来的一些问题（可行流，最大流），我们可以用上下界网络流来解决。</p>
<p>实际上，一个可行的网络流满足以下条件：</p>
<ol>
<li><p>每条边的流量在流量限制内。</p>
</li>
<li><p>对于<script type="math/tex">\forall u\neq s,t</script>，都有<script type="math/tex">\sum w(v,u)=\sum w(u,v)</script>，即每个点的流入流量等于流出流量，称为流量守恒，这个思想是我们讨论的核心。</p>
</li>
</ol>
<p>接下来，我们来逐步探索上下界网络流的几种形式。</p>
<span id="more"></span>
<h1 id="无源汇上下界可行流"><a href="#无源汇上下界可行流" class="headerlink" title="无源汇上下界可行流"></a>无源汇上下界可行流</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>一个网络，我们要求出一个流，使得第<script type="math/tex">i</script>条边的流量必须在<script type="math/tex">[l_i,r_i]</script>中，且对于每个点，都有总流入量等于总流出量（注意这个流没有源汇，因此循环往复，无始无终）。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>这个算法是整个上下界网络流的基础，所以需要理解掌握。</p>
<p>我们的思想是调整：我们忽视掉第二个流量守恒的条件，只满足第一个条件，构成一组初始流。然后，我们在残量网络上进行调整，构造一组附加流，使得初始流加上附加流满足第二个条件，即流量守恒，最后每条边的流量为其在初始流中流量与在附加流中流量之和。</p>
<p>首先我们钦定每条边的流量是<script type="math/tex">l_i</script>，然后，我们构建出残量网络，在残量网络上每条边的限制为<script type="math/tex">r_i-l_i</script>，因为初始流不一定满足流量守恒，因此附加流也不一定满足流量守恒。具体地，如果在初始流中点<script type="math/tex">u</script>的<strong>流入流量</strong>比<strong>流出流量</strong>多<script type="math/tex">w</script>，那么为了最终流量守恒，在附加流中其<strong>流出流量</strong>要比<strong>流入流量</strong>多<script type="math/tex">w</script>，反之亦然。</p>
<p>但是一般求解网络流的方法都是要求流量守恒，怎么办呢？</p>
<p>我们新建两个虚拟节点<script type="math/tex">ss</script>，<script type="math/tex">tt</script>，分别用作补给和分流。具体地，如果在<strong>附加流</strong>中要求<script type="math/tex">u</script>的<strong>流入流量</strong>比<strong>流出流量</strong>多<script type="math/tex">w</script>，那么多的流就要分担，因此我们连一条<script type="math/tex">(u,tt,w)</script>的边。如果<script type="math/tex">u</script>的<strong>流入流量</strong>比<strong>流出流量</strong>少<script type="math/tex">w</script>，那么少的流需要补充，因此我们连一条<script type="math/tex">(ss,u,w)</script>的边。最后，我们跑一边最大流即可。</p>
<p>在实际的实现中，我们只需记录<script type="math/tex">w[u]</script>为所有流入<script type="math/tex">u</script>的边的下界减所有流出<script type="math/tex">u</script>边的下界。如果<script type="math/tex">w[u]>0</script>，则说明<strong>初始流</strong>中流入流量多于流出流量，那么在<strong>附加流</strong>中必须流入流量少于流出流量，因此建一条<script type="math/tex">(ss,u,w[u])</script>的边；如果<script type="math/tex">w[u]<0</script>，则建一条<script type="math/tex">(u,tt,-w[u])</script>的边。</p>
<p>跑完最大流之后，如果最大流等于我们所需要的流，即<script type="math/tex">ss</script>连出去的边的流量之和（等于连向<script type="math/tex">tt</script>的边的流量之和），那么就存在可行流，此时附加流中每条边的流量就是每条边反向边的<script type="math/tex">val</script>值。</p>
<h1 id="有源汇上下界可行流"><a href="#有源汇上下界可行流" class="headerlink" title="有源汇上下界可行流"></a>有源汇上下界可行流</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p>有一个有源汇的网络，第<script type="math/tex">i</script>条边流量要求在<script type="math/tex">[l_i,r_i]</script>之间，问是否存在可行流（对于<script type="math/tex">\forall u\neq s,t</script>，都满足流量守恒）。</p>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><p>这个模型和前者区别仅在于它有一个源点<script type="math/tex">s</script>和一个汇点<script type="math/tex">t</script>，而这两个点是不满足流量守恒的。</p>
<p>那么，我们想办法让这两个点也满足流量守恒，这样就可以转化为无源汇的问题了。</p>
<p>为了使<script type="math/tex">s</script>和<script type="math/tex">t</script>满足流量守恒，我们需有边流入<script type="math/tex">s</script>，且有边流出<script type="math/tex">t</script>。注意到<script type="math/tex">s</script>流出的流量等于流入<script type="math/tex">t</script>的流量，因此我们只需连一条从<script type="math/tex">t</script>到<script type="math/tex">s</script>，下界为<script type="math/tex">0</script>上界为<script type="math/tex">+\infty</script>的边即可。最后我们只需拆掉加入的<script type="math/tex">(t,s)</script>边，剩下的就是一个可行的有源汇网络流了。</p>
<p>最后网络流的流量是多少呢？应该是<script type="math/tex">s</script>连出去的边（不包括连向<script type="math/tex">tt</script>的边）上的流量加上它们的下界之和。但是我们有一个更简单的做法，注意到<script type="math/tex">s</script>会向<script type="math/tex">tt</script>连一条限制为<script type="math/tex">w</script>的边，而<script type="math/tex">w</script>正是<script type="math/tex">s</script>连出去的边的下界之和，而如果可行，这条边最后一定是满流，所以我们只需要统计<script type="math/tex">s</script>连出去的所有边的流量和即可，那么根据流量守恒，它等于连向<script type="math/tex">s</script>所有边的流量之和。而连向<script type="math/tex">s</script>的边只有<script type="math/tex">(t,s)</script>一条，因此答案就是<script type="math/tex">(t,s)</script>这条边上的流量，也就是其反向边最后的<script type="math/tex">val</script>。</p>
<h1 id="有源汇上下界最大流"><a href="#有源汇上下界最大流" class="headerlink" title="有源汇上下界最大流"></a>有源汇上下界最大流</h1><h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h2><p>有一个有源汇的网络，在第<script type="math/tex">i</script>条边流量要求在<script type="math/tex">[l_i,r_i]</script>之间，且流量守恒的前提下，要求流量最大。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><p>首先我们先用上面的方法跑出一个可行流。但是可行流不一定是最大流。</p>
<p>然后，我们只需在去掉<script type="math/tex">(t,s)</script>这条边的残量网络上跑一遍从<script type="math/tex">s</script>到<script type="math/tex">t</script>的最大流再加上原来可行流即可（注意<script type="math/tex">s,t</script>和<script type="math/tex">ss,tt</script>的区别）。</p>
<p>为什么这样就对了呢？</p>
<p>这样做的结果肯定是最大，下面我们来考虑这个结果的可行性。</p>
<p>首先这样一定是满足第一个条件的，即每条边都在<script type="math/tex">[l_i,r_i]</script>中间，因为我们已经把<script type="math/tex">l_i</script>的流量拿出来了，所以这张图不管怎么跑都不会突破流量下界。</p>
<p>考虑第二个条件，我们考虑求解最大流的过程，可以发现每次找增广路的时候，任意一个点（除了<script type="math/tex">s,t</script>）流入流量与流出流量的差永远不会改变（当然在普通求最大流的时候这个差就是<script type="math/tex">0</script>）。那么，我们在除去<script type="math/tex">ss,tt</script>及相邻的边的网络上跑完最大流之后，每个点流入流量和流出流量的差与之前相同，因此再加上<script type="math/tex">ss</script>和<script type="math/tex">tt</script>相关的流量，仍然是守恒的。</p>
<p>为什么差不变呢？对于一个<script type="math/tex">u\neq s,t</script>，记这个点当前的流入流量减流出流量为<script type="math/tex">w[u]</script>，每次增广到这个点，我们从一条边进来并从一条边出去。进来的时候，有两种可能：退回一个原本出去的流或者新增一个进来的流，不管怎么样，设流量为<script type="math/tex">v</script>，都会使<script type="math/tex">w[u]</script>增加<script type="math/tex">v</script>。而出去的时候，也有两种可能：退回一个原本进来的流或者新增一个出去的流，同理，不管怎么样，都会使<script type="math/tex">w[u]</script>减少<script type="math/tex">v</script>，因此，<script type="math/tex">w[u]</script>始终不变。</p>
<p>具体实现的时候，跑完可行流后不需要去除<script type="math/tex">ss,tt</script>，也不用去除相关的边，<script type="math/tex">t</script>到<script type="math/tex">s</script>的边也不用去除，直接跑<script type="math/tex">s->t</script>的最大流就是答案。因为<script type="math/tex">ss</script>的出边和<script type="math/tex">tt</script>的入边已经满流，所以不会被增广，<script type="math/tex">t</script>到<script type="math/tex">s</script>的反向边会把<script type="math/tex">t</script>到<script type="math/tex">s</script>上原有的流量（即原来可行流流量）加上，所以就是最后的答案。</p>
<h1 id="有源汇上下界最小流"><a href="#有源汇上下界最小流" class="headerlink" title="有源汇上下界最小流"></a>有源汇上下界最小流</h1><h2 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h2><p>有一个有源汇的网络，在第<script type="math/tex">i</script>条边流量要求在<script type="math/tex">[l_i,r_i]</script>之间，且流量守恒的前提下，要求流量最小。</p>
<h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h2><p>同样地，我们先跑出一个可行流，但是可行流也不一定是最小流，所以我们要对它进行调整。</p>
<p>我们如果找一条从<script type="math/tex">s</script>到<script type="math/tex">t</script>的路径，去掉这条路径上的流量后仍然满足流量下限，那么我们就找到了一个更小的流。但是，并没有算法能够算出“去掉尽量多的流且仍满足条件”。</p>
<p>怎么办呢？考虑网络中的反向边，反向边流量增加相当于正向边退流，因此，我们的目标实际上是想让反向边的流量最大。那么，我们在除去所有附加边的残量网络上跑一遍<script type="math/tex">t->s</script>的最大流，并用可行流量减掉它即可。</p>
<p>为什么这是对的呢？考虑任何一条<script type="math/tex">t->s</script>的路径，它唯一对应了一条<script type="math/tex">s->t</script>的路径（路径上所有边的反向边构成的），我们选择了这条<script type="math/tex">t->s</script>的路径的流量，就相当于撤销了一条<script type="math/tex">s->t</script>的路径流量，而我们的目的是撤销一些<script type="math/tex">s->t</script>的路径使得撤销的流量最大，那么相当于选择一些<script type="math/tex">t->s</script>的路径使得选择的流量最大，即<script type="math/tex">t->s</script>的最大流。</p>
<p>注意这个算法在求完可行流后要把附加边（即有关<script type="math/tex">ss,tt</script>的边和<script type="math/tex">t->s</script>的边）都删掉再跑<script type="math/tex">t->s</script>的最大流。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈prufer序列</title>
    <url>/2019/06/19/%E6%B5%85%E8%B0%88prufer%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="什么是prufer序列"><a href="#什么是prufer序列" class="headerlink" title="什么是prufer序列"></a>什么是prufer序列</h1><p><script type="math/tex">prufer</script>序列是用来表示一棵无根树的，一个<script type="math/tex">prufer</script>序列与一个无根树一一对应，换句话说，一个无根树对应唯一一个<script type="math/tex">prufer</script>序列，一个<script type="math/tex">prufer</script>序列也可以还原出唯一的一个无根树。</p>
<span id="more"></span>
<h1 id="如何构造prufer序列"><a href="#如何构造prufer序列" class="headerlink" title="如何构造prufer序列"></a>如何构造prufer序列</h1><p>对于一棵无根树，我们首先每次找到当前编号最小的叶子节点（无根树中的叶子结点指度为1），然后将其从无根树中删掉，再将所有与这个节点相连的节点编号加入<script type="math/tex">prufer</script>序列末端，不断重复这个步骤，直到最后只剩下两个节点为止。</p>
<p>因此，<script type="math/tex">n</script>个点的<script type="math/tex">prufer</script>序列长度为<script type="math/tex">n-2</script>。</p>
<h1 id="如何还原无根树"><a href="#如何还原无根树" class="headerlink" title="如何还原无根树"></a>如何还原无根树</h1><p>如果已知一个<script type="math/tex">prufer</script>序列，我们是可以根据它还原无根树的，那么，怎么还原呢？</p>
<p>首先，我们把<script type="math/tex">prufer</script>序列中的每一个节点的度数设为1，然后加上每一个点在序列中出现的次数，作为这个点的度数。然后对于第i步：</p>
<p>先找出度数为1的所有的点中最小的那一个，设为<script type="math/tex">u</script>，将它与<script type="math/tex">prufer</script>序列中第i个节点<script type="math/tex">v</script>连边，然后将<script type="math/tex">u,v</script>的度数都减1。</p>
<p>最后，还剩下两个度数为1的点，将它们连边即可。</p>
<p>至于正确性，我也不会证明，知道就好了。。。</p>
<h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><p><script type="math/tex">prufer</script>序列还有一个重要的性质：</p>
<p>我们考虑一个节点怎样才会被放入<script type="math/tex">prufer</script>序列里：当与它相连的节点被删除时，就会把它加进去。直到它自己被删除。</p>
<p>因此，我们可以得到：</p>
<p><strong>无根树中一个点的度数=这个点在<script type="math/tex">prufer</script>序列中出现的次数+1</strong></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈中国剩余定理</title>
    <url>/2019/08/04/%E6%B5%85%E8%B0%88%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h1 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h1><p>中国剩余定理是解决这样一类问题：</p>
<script type="math/tex; mode=display">
\begin{cases}
x\equiv a_1\quad(mod\quad m_1)\\
x\equiv a_2\quad(mod\quad m_2)\\
...\\
x\equiv a_k\quad(mod\quad m_k)\\
\end{cases}</script><p>求<script type="math/tex">x</script>的最小整数解。</p>
<span id="more"></span>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>我们考虑先给出一种可行解，我们记<script type="math/tex">M=\prod m_i</script>，然后，我们考虑第<script type="math/tex">i</script>个式子，我们让只有这个式子有影响，而让别的式子都没有影响。即我们可以求出</p>
<script type="math/tex; mode=display">
\frac{M}{m_i}t_i\equiv 1\quad(mod\quad m_i)</script><p>其中<script type="math/tex">t_i</script>的一个可行值。考虑这个时候，其他的方程都是</p>
<script type="math/tex; mode=display">
\frac{M}{m_i}t_i\equiv 0\quad(mod\quad m_j)(j\neq i)</script><p>所以，其他的方程对于<script type="math/tex">t_i</script>的取值没有影响。然后，</p>
<script type="math/tex; mode=display">
a_i\frac{M}{m_i}t_i\equiv a_i\quad(mod\quad m_i)</script><p>所以，这就满足了这个方程的条件。</p>
<p>那么，最后的一个可行解就是<script type="math/tex">x=\sum_{i=1}^ka_i\frac{M}{m_i}t_i</script>。</p>
<p>我们考虑这个解配对到第<script type="math/tex">i</script>个方程，<script type="math/tex">x</script>中只有<script type="math/tex">a_i\frac{M}{m_i}t_i</script>是有效的，别的都是<script type="math/tex">0</script>，所以方程成立。这个思想，在拉格朗日插值中也有应用。</p>
<p>然后，至于要求最小的非负整数解，就是 </p>
<script type="math/tex; mode=display">
(x\quad mod\quad M+M)\quad mod\quad M</script><p>怎么求<script type="math/tex">t_i</script>呢？当然用<script type="math/tex">exgcd</script>了！</p>
<h1 id="Ex-gcd求逆元"><a href="#Ex-gcd求逆元" class="headerlink" title="Ex_gcd求逆元"></a>Ex_gcd求逆元</h1><p>其实这是很<script type="math/tex">noip</script>的知识了，只是我到现在还不会推，所以来写一下（我太弱了）。</p>
<p>我们考虑辗转相除法的过程<script type="math/tex">gcd(a,b)=gcd(b,a\quad mod\quad b)</script>。</p>
<p>我们到了最后一层，此时的<script type="math/tex">a</script>就是<script type="math/tex">gcd</script>，而<script type="math/tex">b</script>等于<script type="math/tex">0</script>，那么我们有</p>
<script type="math/tex; mode=display">
a*1+b*0=gcd</script><p>所以初始的时候<script type="math/tex">x0=1,y0=0</script>。</p>
<p>然后，我们考虑我们已经知道了</p>
<script type="math/tex; mode=display">
x0*b+y0*(a\%b)=gcd</script><p>如何求</p>
<script type="math/tex; mode=display">
a*x1+b*y1=gcd</script><p>的<script type="math/tex">x1,y1</script>呢？</p>
<script type="math/tex; mode=display">
x0*b+y0*(a-(a/b)*b)=gcd\\
y0*a+(x0-(a/b)*y0)*b=gcd</script><p>所以</p>
<script type="math/tex; mode=display">
x1=y0,y1=x0-(a/b)*y0</script><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ex_gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) &#123; x0 = <span class="number">1</span>, y0 = <span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="built_in">ex_gcd</span>(b, a % b);</span><br><span class="line">    <span class="keyword">int</span> tmp = x0;</span><br><span class="line">    x0 = y0;</span><br><span class="line">    y0 = tmp - a / b * y0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) M *= m[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ex_gcd</span>(M / m[i], m[i]);</span><br><span class="line">        x0 = (x0 % m[i] + m[i]) % m[i];</span><br><span class="line">        ans = (ans + a[i] * (M / m[i]) * x0) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈克鲁斯卡尔重构树</title>
    <url>/2019/03/04/%E6%B5%85%E8%B0%88%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E9%87%8D%E6%9E%84%E6%A0%91/</url>
    <content><![CDATA[<h1 id="什么是Kruskal重构树？"><a href="#什么是Kruskal重构树？" class="headerlink" title="什么是Kruskal重构树？"></a>什么是Kruskal重构树？</h1><p>Kruskal重构树，和Kruskal算法的思想差不多，就是在这个过程中建出一个有着非常优秀的性质的数据结构，这是一个非常少见和小众的算法，但是如果碰到了合适的题目，就会体现出其优越性。</p>
<span id="more"></span>
<h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><p>我们先将边权排序（排序的方式决定了这个Kruskal重构树的性质），我们依次遍历每条边，如果要连接的两个点<script type="math/tex">u,v</script>不在一个并查集内，我们就新建一个节点<script type="math/tex">node</script>，我们设u,v的并查集的根为rootu,rootv,于是我们连接<script type="math/tex">(rootu,node),(node,rootv)</script>，然后<script type="math/tex">fa[rootu] = node, fa[rootv] = node</script>，然后把这个点的点权变成这条边的长度。这样，不断地更新连边，我们建立的就是一棵<strong>Kruskal重构树</strong>；</p>
<p>代码<del>（随手瞎写的，也许编译都过不去）</del>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i] = i;</span><br><span class="line">    <span class="built_in">sort</span>(edge + <span class="number">1</span>, edge + m + <span class="number">1</span>, comp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> rootu = <span class="built_in">find</span>(edge[i].from), rootv = <span class="built_in">find</span>(edge[i].to);</span><br><span class="line">        <span class="keyword">if</span>(rootu != rootv)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> node = ++cnt;</span><br><span class="line">            fa[rootu] = fa[rootv] = fa[node] = node;</span><br><span class="line">            val[node] = edge[i].value;</span><br><span class="line">            <span class="built_in">add</span>(rootu, node); <span class="built_in">add</span>(node, rootv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><p>我们为什么要学习这样一个东西，就是因为它有很多优秀的性质。</p>
<p>首先，可以明确，这个Kruskal重构树是一个树（废话），而且是一棵二叉树。具体性质还是要分具体情况来看待。</p>
<h2 id="u-gt-v路径上的最大值最小"><a href="#u-gt-v路径上的最大值最小" class="headerlink" title="u-&gt;v路径上的最大值最小"></a>u-&gt;v路径上的最大值最小</h2><p>如果我们要在一张图上找到一条<script type="math/tex">u,v</script>的路径，使得这条路径上的最大值最小，那么，用Kruskal重构树很容易实现：</p>
<p>我们按照边权从小到大来排序，然后进行上面的建树过程，那么，最后的答案就是Kruskal重构树上<script type="math/tex">LCA(u,v)</script>的点权。</p>
<p>我们考虑，这是为什么？</p>
<p>由于从小到大排序，所以这棵树中每一个节点的子树的权值都必须小于等于这个点的权值，因此，权值越大的边深度越小。我们找<script type="math/tex">u,v</script>的<script type="math/tex">LCA</script>，可以发现这样走的边必然是尽量走较小的边，这样，<script type="math/tex">u,v</script>在树上的路径上的LCA就是这条路径上深度最小的点，也是权值最大的。</p>
<p><del>感性理解一下就好了</del></p>
<p>同理，我们将边权<strong>从大到小</strong>排，所求出来的LCA的权值，就是这条路径上的最小值最大的。</p>
<p>我们来看一道例题：</p>
<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3732">BZOJ3732Network</a></p>
<p>好像就是裸题啦，上代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">2e5</span> + <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, value, next;</span><br><span class="line">&#125;edge[maxN * <span class="number">2</span> + <span class="number">1</span>], E[maxN * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"><span class="keyword">int</span> tot, head[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> fa[maxN + <span class="number">1</span>][<span class="number">20</span>], dep[maxN + <span class="number">1</span>], lg[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> cnt, val[maxN + <span class="number">1</span>], pa[maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> num * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(Node a, Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.value &lt; b.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[ ++ tot] = (Node) &#123;x, y, <span class="number">0</span>, head[x]&#125;; head[x] = tot;</span><br><span class="line">    edge[ ++ tot] = (Node) &#123;y, x, <span class="number">0</span>, head[y]&#125;; head[y] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> pa[x] == x ? x : pa[x] = <span class="built_in">find</span>(pa[x]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[x] = dep[pa] + <span class="number">1</span>;</span><br><span class="line">    fa[x][<span class="number">0</span>] = pa;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span>&lt;&lt;i) &lt;= dep[x]; i++) fa[x][i] = fa[ fa[x][i - <span class="number">1</span>] ][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].next)</span><br><span class="line">       <span class="keyword">if</span>(edge[i].to != pa) <span class="built_in">dfs</span>(edge[i].to, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &lt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">while</span>(dep[x] != dep[y]) x = fa[x][ lg[ dep[x] - dep[y] ] - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = lg[ dep[x] ]; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">       <span class="keyword">if</span>(fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i];</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> int</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), q = <span class="built_in">read</span>(); </span><br><span class="line">    cnt = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) E[i].from = <span class="built_in">read</span>(), E[i].to = <span class="built_in">read</span>(), E[i].value = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">sort</span>(E + <span class="number">1</span>, E + m + <span class="number">1</span>, comp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) pa[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = E[i].from, v = E[i].to;</span><br><span class="line">        u = <span class="built_in">find</span>(u); v = <span class="built_in">find</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(u == v) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> node = ++cnt;</span><br><span class="line">        pa[u] = pa[v] = pa[node] = node;</span><br><span class="line">        val[node] = E[i].value;</span><br><span class="line">        <span class="built_in">add</span>(u, node); <span class="built_in">add</span>(v, node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) lg[i] = lg[i - <span class="number">1</span>] + ((<span class="number">1</span> &lt;&lt; lg[i - <span class="number">1</span>]) == i);</span><br><span class="line">    <span class="built_in">dfs</span>(cnt, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(q --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, val[ <span class="built_in">lca</span>(u, v) ]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Tips:可以发现，当边权从小到大排的时候，Kruskal重构树是一个大根堆，而从大到小排，则是一个小根堆</strong>。</p>
<h2 id="从u出发只经过边权不超过x的边能到达的节点"><a href="#从u出发只经过边权不超过x的边能到达的节点" class="headerlink" title="从u出发只经过边权不超过x的边能到达的节点"></a>从u出发只经过边权不超过x的边能到达的节点</h2><p>我们只要在边权升序的Kruskal重构树中找到<strong>深度最小的，点权不超过x的节点</strong>，这个一般用树上倍增来实现，那么这个节点的子树就是所求的答案。</p>
<p>那么，如何用倍增来找呢？</p>
<p>我们考虑当前我们找到的这个节点为x，然后我们倍增枚举它的祖先，由于是升序排序，所以它祖先的点的点权必然大于等于它的点权，于是，我们倍增的时候，只要判断如果它的祖先的点权<script type="math/tex"><=rule</script>，就直接<script type="math/tex">x=fa[x][i]</script>，就好了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = lg[ dep[x] ]; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span>(val[ fa[x][i] ] &lt;= rule) x = fa[x][i];</span><br><span class="line">   	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>口胡的，也许不太对，凑合着看就好了。</del></p>
<p>这个的例题嘛，直接看<script type="math/tex">NOI2018</script>归程即可。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>Kruskal重构树</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈卢卡斯定理及扩展</title>
    <url>/2020/04/26/%E6%B5%85%E8%B0%88%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86%E5%8F%8A%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h1 id="卢卡斯定理"><a href="#卢卡斯定理" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h1><p>卢卡斯定理是用来快速计算组合数的。在一些题目中，我们要求<script type="math/tex">\binom{n}{m}\bmod P</script>，但是<script type="math/tex">n,m</script>很大，<script type="math/tex">P</script>却很小（<script type="math/tex">P\le 10^5</script>），那么卢卡斯定理就是用来加速这个过程的。</p>
<p>普通的卢卡斯定理要求<script type="math/tex">P</script>为质数，而扩展卢卡斯中<script type="math/tex">P</script>可以是合数。</p>
<p>卢卡斯定理十分简洁：</p>
<script type="math/tex; mode=display">
\binom{n}{m}\bmod P=\binom{\lfloor\frac{n}{P}\rfloor}{\lfloor\frac{m}{P}\rfloor}*\binom{n\bmod P}{m\bmod P}\bmod P</script><span id="more"></span>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span> * fac[n] * inv[m] % P * inv[n - m] % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Lucas</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n || !m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span> * <span class="built_in">lucas</span>(n / P, m / P) * <span class="built_in">C</span>(n % P, m % P) % P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="扩展卢卡斯"><a href="#扩展卢卡斯" class="headerlink" title="扩展卢卡斯"></a>扩展卢卡斯</h1><p>实际上，扩展卢卡斯与卢卡斯定理似乎并无太大关联，只需掌握中国剩余定理与<script type="math/tex">exgcd</script>即可学习扩展卢卡斯定理。</p>
<p>如果<script type="math/tex">P</script>是合数，考虑设<script type="math/tex">P=p_1^{a_1}p_2^{a_2}...</script>，那么如果我们对于每个<script type="math/tex">i</script>，求出<script type="math/tex">\binom{n}{m}\equiv a_i\pmod{p_i^{a_i}}</script>，就可以用中国剩余定理来进行合并。</p>
<p>那么，问题就转变为了如何求<script type="math/tex">\binom{n}{m}\bmod p^x</script>。</p>
<p>考虑<script type="math/tex">\binom{n}{m}=\frac{n!}{m!(n-m)!}</script>，我们只需求出<script type="math/tex">n!\bmod p^x</script>即可。</p>
<p>我们把所有<script type="math/tex">p</script>的倍数全部提取出来，那么就有</p>
<script type="math/tex; mode=display">
n!=1*2*3...*n\\
=1*2*...*(p-1)*(p+1)*...*(2p-1)*(2p+1)...*(p*2p*3p*...)\\
=1*2*...*(p-1)*(p+1)...*p^t*t!</script><p>其中<script type="math/tex">t= \lfloor\frac{n}{p}\rfloor</script>，那么我们发现实际上我们成功转化为了一个类似卢卡斯定理的子问题。</p>
<p>因为求逆元的时候要求数与模数互质，所以我们可以把<script type="math/tex">\binom{n}{m}</script>中<script type="math/tex">p</script>的次数预处理出来，先乘上去，那么每次递归子问题的时候就不需要管分出来的<script type="math/tex">p</script>的次数了。</p>
<p>后面部分交给递归，现在我们观察前面的部分模<script type="math/tex">p^x</script>是循环的（当然还会有一些余项），那么我们可以计算出前面<script type="math/tex">p^x</script>以内的结果然后<script type="math/tex">\lfloor\frac{n}{p}\rfloor</script>次方一下，然后再暴力计算一下剩下的余项即可。</p>
<p>那么，对于每个<script type="math/tex">p^x</script>，时间复杂度为<script type="math/tex">O(p^xlog_pn)</script>。</p>
<p>所以整个算法的时间复杂度为<script type="math/tex">O(\sum p_i^{a_i}log_pn)</script>，所以当<script type="math/tex">\forall i,p_i\le 10^5</script>时可以使用扩展卢卡斯定理。</p>
<p>注意求逆元的时候，因为模数不是质数，所以应该用<script type="math/tex">exgcd</script>求逆元而不能用费马小定理。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line">LL n, m, P;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">mpow</span><span class="params">(LL a, LL x, LL p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>) ans = ans * a % p;</span><br><span class="line">        a = a * a % p;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(LL a, LL b, LL &amp;x, LL &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) &#123; x = <span class="number">1</span>; y = <span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">    LL tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp - a / b * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">inverse</span><span class="params">(LL a, LL p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">exgcd</span>(a, p, x, y);</span><br><span class="line">    <span class="keyword">return</span> (x % p + p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">getFac</span><span class="params">(LL n, LL x, LL p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    LL s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= p; i++)</span><br><span class="line">        <span class="keyword">if</span>(i % x) s = s * i % p;</span><br><span class="line">    s = <span class="built_in">mpow</span>(s, n / p, p);</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n % p; i++)</span><br><span class="line">        <span class="keyword">if</span>(i % x) s = s * i % p;</span><br><span class="line">    <span class="keyword">return</span> s * <span class="built_in">getFac</span>(n / x, x, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">C</span><span class="params">(LL n, LL m, LL x, LL p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL t = n; t; t /= x) s += t / x;</span><br><span class="line">    <span class="keyword">for</span>(LL t = m; t; t /= x) s -= t / x;</span><br><span class="line">    <span class="keyword">for</span>(LL t = n - m; t; t /= x) s -= t / x;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mpow</span>(x, s, p) * <span class="built_in">getFac</span>(n, x, p) % p * <span class="built_in">inverse</span>(<span class="built_in">getFac</span>(m, x, p), p) % p * <span class="built_in">inverse</span>(<span class="built_in">getFac</span>(n - m, x, p), p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">ExLucas</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>, T = P;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">2</span>; i * i &lt;= T; i++)</span><br><span class="line">        <span class="keyword">if</span>(T % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            LL p = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(T % i == <span class="number">0</span>) p *= i, T /= i;</span><br><span class="line">            ans = (ans + (P / p) * <span class="built_in">inverse</span>(P / p, p) % P * <span class="built_in">C</span>(n, m, i, p) % P) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(T &gt; <span class="number">1</span>) ans = (ans + (P / T) * <span class="built_in">inverse</span>(P / T, T) % P * <span class="built_in">C</span>(n, m, T, T) % P) % P;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>, &amp;n, &amp;m, &amp;P);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">ExLucas</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈原根及其应用</title>
    <url>/2020/01/08/%E6%B5%85%E8%B0%88%E5%8E%9F%E6%A0%B9%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h1><p>要想了解原根，先了解什么是阶。</p>
<p>数论中，阶一般定义为对于两个互质的整数<script type="math/tex">a,p</script>，使得<script type="math/tex">a^r\equiv 1\pmod {p}</script>的最小的正整数<script type="math/tex">r</script>，称为<script type="math/tex">a</script>模<script type="math/tex">p</script>的阶。</p>
<p>而原根，就是定义在阶的基础上的：</p>
<p>如果一个数<script type="math/tex">1<g<p</script>，且<script type="math/tex">g</script>模<script type="math/tex">p</script>的阶是<script type="math/tex">\phi(p)</script>，那么<script type="math/tex">g</script>就称为<script type="math/tex">p</script>的原根。</p>
<p>如果<script type="math/tex">p</script>是质数，那么就有<script type="math/tex">g</script>模<script type="math/tex">p</script>的阶为<script type="math/tex">p-1</script>。</p>
<span id="more"></span>
<h1 id="原根的性质"><a href="#原根的性质" class="headerlink" title="原根的性质"></a>原根的性质</h1><p>原根有什么性质？<br>以下我们都讨论<script type="math/tex">p</script>为质数的情况，合数则只要把<script type="math/tex">p-1</script>换成<script type="math/tex">\phi(p)</script>即可。</p>
<p><strong>对于<script type="math/tex">\forall 1 \le i,j \le p-1,i\neq j</script>，都有<script type="math/tex">g^i\not\equiv g^j \pmod{p}</script>。</strong></p>
<p>证明：</p>
<p>考虑反证法，如果存在<script type="math/tex">1\le i,j\le p-1,i\neq j</script>，有<script type="math/tex">g^i\equiv g^j\pmod{p}</script>，不妨设<script type="math/tex">i<j</script>，那么就有<script type="math/tex">g^{j-i}\equiv 1\pmod{p}</script>，而<script type="math/tex">0<j-i<p-1</script>，这与原根的定义矛盾，所以假设不成立。</p>
<p>证毕。</p>
<p>这是一个非常好的性质，为后面作为单位根做铺垫。</p>
<h1 id="原根的应用"><a href="#原根的应用" class="headerlink" title="原根的应用"></a>原根的应用</h1><p>单位根。</p>
<p>复数的单位根，指的是将<script type="math/tex">2\pi</script>平均分为<script type="math/tex">k</script>份，而复数<script type="math/tex">(cos(\frac{2\pi}{k}),sin(\frac{2\pi}{k}))</script>就是单位根，记为<script type="math/tex">w_k</script>。它有什么性质呢？</p>
<p>由其在复平面上的性质，我们可以发现<script type="math/tex">w_k^i,0\le i\le k-1</script>两两不同（考虑在单位圆中旋转，每次旋转<script type="math/tex">\frac{2\pi}{k}</script>，在此范围内不会重合）。而<script type="math/tex">FFT</script>也是利用了这个性质（将<script type="math/tex">n</script>个不同的数带入多项式，将多项式转为点值表示法）。</p>
<p>那么，在模意义下的单位根，原根就派上了用场。</p>
<p>记<script type="math/tex">w_k=g^{\frac{p-1}{k}}</script>，前提是<script type="math/tex">k|p-1</script>，这也是<script type="math/tex">NTT</script>模数必须是<script type="math/tex">2^mp+1</script>的形式的重要原因（也因此，<script type="math/tex">NTT</script>不能处理长度为<script type="math/tex">1e7</script>的数列，因为这样会使<script type="math/tex">k</script>过大而无法满足<script type="math/tex">k| p - 1</script>)。</p>
<p><strong>那么，我们依然有<script type="math/tex">0\le i\le k-1,w_k^i</script>两两不同。</strong></p>
<p>证明也很显然，因为<script type="math/tex">\frac{i(p-1)}{k}<p-1</script>，根据原根的性质，必然是两两不同的。</p>
<p>这也是<script type="math/tex">NTT</script>所依赖的性质。</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>如果我们要求某个值，给定<script type="math/tex">n,k,p</script>,且保证<script type="math/tex">k|p-1</script>，求</p>
<script type="math/tex; mode=display">
\sum_{i=0}^n[k|i]F(i)\mod{p}</script><p>怎么办？</p>
<p>意思就是说，当<script type="math/tex">k|i</script>时才对答案产生贡献，否则不产生贡献。</p>
<p>那么我们要构造一个函数，使得当<script type="math/tex">k|i</script>时，这个函数值为<script type="math/tex">1</script>，否则为<script type="math/tex">0</script>。</p>
<p>考虑单位根<script type="math/tex">w_k=g^{\frac{p-1}{k}}</script>，构造</p>
<script type="math/tex; mode=display">
\sum_{j=0}^{k-1}w_k^{ij}</script><p>可以发现，如果<script type="math/tex">k|i</script>，那么每一项都是<script type="math/tex">1</script>，这个数就等于<script type="math/tex">k</script>。</p>
<p>否则，根据等比数列求和，它等于</p>
<script type="math/tex; mode=display">
\frac{w_k^{ki}-1}{w^i-1}=\frac{1-1}{w^i-1}=0</script><p>这样，</p>
<script type="math/tex; mode=display">
\frac{1}{k}\sum_{j=0}^{k-1}w_k^{ij}</script><p>就能完美地满足我们的要求了。</p>
<p>是不是很巧妙呢？</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈后缀数组</title>
    <url>/2019/02/11/%E6%B5%85%E8%B0%88%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="后缀数组的基础"><a href="#后缀数组的基础" class="headerlink" title="后缀数组的基础"></a>后缀数组的基础</h1><h2 id="后缀定义"><a href="#后缀定义" class="headerlink" title="后缀定义"></a>后缀定义</h2><p>对于一个字符串为<script type="math/tex">s</script>，我们记<script type="math/tex">suf[i]</script>为<script type="math/tex">[i,n]</script>这一段字符串，称为后缀。</p>
<span id="more"></span>
<h2 id="后缀数组是什么"><a href="#后缀数组是什么" class="headerlink" title="后缀数组是什么"></a>后缀数组是什么</h2><p>就我个人的理解来看，后缀数组其实就两个方面，一个记为<script type="math/tex">sa</script>，一个记为<script type="math/tex">rk</script>，它们代表什么意思呢？</p>
<script type="math/tex; mode=display">
rk[i]:指s中第i项的后缀在所有后缀中的字典序排名\\
sa[i]:与rk[i]相对应的，指s所有后缀中第i名后缀所在的位置</script><p>当然，这两个数组都是为height数组服务的，但height数组是什么，我们后面再说。</p>
<p>这个算法想法离奇，主要就是为了求解<script type="math/tex">sa[i],rk[i]</script>服务的。</p>
<p>其实，<script type="math/tex">sa[i],rk[i]</script>只要求解一个就可以了，由定义可知：</p>
<script type="math/tex; mode=display">
sa[rk[i]]=i,rk[sa[i]]=i</script><h2 id="求解后缀数组"><a href="#求解后缀数组" class="headerlink" title="求解后缀数组"></a>求解后缀数组</h2><p>那么，怎么求这个东西呢？</p>
<p>首先，这个算法是基于“<strong>基数排序</strong>”之上的，那么基数排序是什么呢？</p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>后缀数组之中的基数排序指的是对于一个二元组(p,q)进行多关键字排序，而基数排序可以对两个进行分别处理，从而使时间复杂度降到<script type="math/tex">O(n)</script></p>
<h3 id="倍增法实现"><a href="#倍增法实现" class="headerlink" title="倍增法实现"></a>倍增法实现</h3><p>怎么用倍增法实现？</p>
<p>首先，我们考虑我们已经知道了每个后缀前w个字符的sa和rk，我们考虑怎样向前w*2个字符转移：</p>
<p>我们考虑基数排序，假设我们现在考虑到第i位为起点的长度为2*w后缀</p>
<p>我们以<strong>前w个字符的排名（就是当前的rk[i])</strong>为第一关键字，而<strong>后w个字符的排名（就是当前的rk[i+w])</strong>为第二关键字，进行基数排序。</p>
<p>我们来认识这几个数组：</p>
<script type="math/tex; mode=display">
tp[i]:指第二关键字排名为i的后缀位置\\
bin[i]:指排名第i的后缀出现的个数</script><p>我们来更新这个以i为开头长度为2*w的后缀的tp[i]：</p>
<p>因为当i+w&gt;n时，这些i是没有第二关键字的（i+w已经超出了），所以要把先塞进tp数组里。</p>
<p>剩下的，都是i+w&lt;=n的情况了，这个时候，我们不用i来更新，我们设j为排名，则这个排名第j的长为w的后缀可以作为以<script type="math/tex">sa[j]-w</script>开头的长为2*w的后缀的第二关键字，所以，我们就直接更新就好了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">p=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n-w+<span class="number">1</span>;i&lt;=n;i++) tp[++p]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(sa[i]&gt;w) tp[++p]=sa[i]-w;</span><br></pre></td></tr></table></figure>
<p>此时，tp中便是有序的第二关键字了，下面，就要用基数排序，来进行最终的排序。。。</p>
<h3 id="排序过程"><a href="#排序过程" class="headerlink" title="排序过程"></a>排序过程</h3><p>还记得之前的那个bin数组吗，其中，bin[i]记录的是排名为i的后缀有多少个。</p>
<p>先把代码上一下，有助于理解：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Qsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++) bin[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) bin[rk[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) bin[i]+=bin[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--) sa[bin[rk[tp[i]]]--]=tp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们用bin[i]统计个数，然后，我们做一次前缀和，这样，我们就可以算出排名为i的后缀的真正的排名（因为会有重复的）。</p>
<p>最后，i从n-&gt;1，tp[i]指的是第二关键字排名第i的位置（这样保证了第二关键字的有序），再取一个rk，算出这个位置第一关键字的排名，最后再取一个bin，求出其真正的排名，并将它赋值为tp[i]，bin要—，以便计算下一个。</p>
<h3 id="更新rk"><a href="#更新rk" class="headerlink" title="更新rk"></a>更新rk</h3><p>一样的，先上代码以便理解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(tp,rk,<span class="built_in"><span class="keyword">sizeof</span></span>(rk));</span><br><span class="line">rk[sa[<span class="number">1</span>]]=p=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">   	rk[sa[i]]=(tp[sa[i<span class="number">-1</span>]]==tp[sa[i]]&amp;&amp;tp[sa[i<span class="number">-1</span>]+w]==tp[sa[i]+w]) ? p : ++p;</span><br></pre></td></tr></table></figure>
<p>首先，第一名是没有什么可比较的，设为1。</p>
<p>因为现在tp已经没有用了，而rk又要用于更新，不能直接用，就要用一个临时数组存起来，所以就用tp代替旧的rk。</p>
<p>p就是一个计数器，也可以更新m的值（后面再说）。那一大坨东西是什么？</p>
<p>它指的是，如果目前以sa[i]为开头的长度为<script type="math/tex">2*w</script>的后缀等于以sa[i-1]为开头的长度为<script type="math/tex">2*w</script>的后缀，那么p就不用再加了，可以减少循环数量。</p>
<p>至此，基本上就结束了，还有一些小细节，体现在代码中：</p>
<p>题目：<a href="https://www.luogu.org/problemnew/show/P3809">后缀排序</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN=<span class="number">1e6</span> + <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> tp[maxN+<span class="number">1</span>],rk[maxN+<span class="number">1</span>],sa[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> bin[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,p;</span><br><span class="line"><span class="keyword">char</span> s[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Qsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++) bin[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) bin[rk[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) bin[i]+=bin[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--) sa[bin[rk[tp[i]]]--]=tp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m=<span class="string">&#x27;Z&#x27;</span>;<span class="comment">//字符从&#x27;0&#x27;~&#x27;Z&#x27;，映射成ASCLL码表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) tp[i]=i,rk[i]=s[i]-<span class="string">&#x27;0&#x27;</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Qsort</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">1</span>; p &lt; n; m = p,w &lt;&lt;= <span class="number">1</span>)<span class="comment">//不断更新m的值，另外，如果排名数==n，就不用再找了</span></span><br><span class="line">    &#123;</span><br><span class="line">        p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-w+<span class="number">1</span>;i&lt;=n;i++) tp[++p]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(sa[i]&gt;w) tp[++p]=sa[i]-w;</span><br><span class="line">        <span class="built_in">Qsort</span>();</span><br><span class="line">        <span class="built_in">memcpy</span>(tp, rk, <span class="built_in"><span class="keyword">sizeof</span></span>(rk));</span><br><span class="line">        rk[ sa[<span class="number">1</span>] ] = p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">           rk[ sa[i] ] = (tp[ sa[i - <span class="number">1</span>] ] == tp[ sa[i] ] &amp;&amp; tp[ sa[i - <span class="number">1</span>] + w ] == tp[ sa[i] + w ]) ? p : ++p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,sa[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="后缀数组的进阶"><a href="#后缀数组的进阶" class="headerlink" title="后缀数组的进阶"></a>后缀数组的进阶</h1><h2 id="height数组"><a href="#height数组" class="headerlink" title="height数组"></a>height数组</h2><p>大家一定会想，就计算这两个数组，有什么用处呢?</p>
<p>其实，就是为了<script type="math/tex">height和h</script>数组做铺垫的。</p>
<p>我们定义：<script type="math/tex">i</script>号后缀为以第<script type="math/tex">i</script>个字符开头的后缀。</p>
<p>我们设<script type="math/tex">lcp(x,y)</script>为以第<script type="math/tex">x</script>号后缀和第<script type="math/tex">y</script>号后缀的最长公共前缀，那么</p>
<script type="math/tex; mode=display">
height[i]=lcp(sa[i],sa[i-1])，即排名为i的后缀和其排名前一位的后缀的最长公共前缀\\
h[i]=height[rk[i]]，即第i号后缀与它排名的前一名的后缀的公共前缀</script><p>这个一定要搞清楚。</p>
<p>我们有一个很重要的性质：</p>
<script type="math/tex; mode=display">
h[i]>=h[i-1]-1</script><p>证明（<del>口胡</del>）：</p>
<p>如果<script type="math/tex">h[i-1]>1</script>，假设第<script type="math/tex">i-1</script>号后缀与第<script type="math/tex">k</script>号后缀的最长公共前缀为<script type="math/tex">h[i-1]</script>，且不止是第一个字符相同，则第<script type="math/tex">k+1</script>号后缀与第<script type="math/tex">i</script>号后缀有<script type="math/tex">h[i-1]-1</script>的公共前缀（除去<script type="math/tex">k,i-1</script>后就是<script type="math/tex">h[i-1]-1</script>），而第<script type="math/tex">k+1</script>号后缀会排在第<script type="math/tex">i</script>号后缀前面。为什么呢？因为此时，第<script type="math/tex">i-1</script>号后缀和第<script type="math/tex">k</script>号后缀第一个字符必然相同，那么，第<script type="math/tex">i</script>号后缀和第<script type="math/tex">k-1</script>号后缀仅仅是去掉了一个相同的字符，所以<script type="math/tex">k-1</script>号后缀必然在<script type="math/tex">i</script>号后缀前面，否则就与之前矛盾了。</p>
<p>如果<script type="math/tex">h[i-1]<=1</script>，那么<script type="math/tex">h[i-1]-1<=0</script>，即<script type="math/tex">h[i]>=0</script>，这显然正确。</p>
<p>有了这个结论，求解<script type="math/tex">h</script>数组也就很简单了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k) k --;</span><br><span class="line">        <span class="keyword">int</span> j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(s[i + k] == s[j + k]) k ++;</span><br><span class="line">        h[i] = height[rk[i]] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="height数组的重要应用"><a href="#height数组的重要应用" class="headerlink" title="height数组的重要应用"></a>height数组的重要应用</h2><p>1.<a href="https://cmwqf.github.io/2019/03/11/%E6%9C%AC%E8%B4%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E4%B8%B2%E6%95%B0%E9%87%8F/#more">本质不同的子串数量</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈带权二分</title>
    <url>/2020/07/05/%E6%B5%85%E8%B0%88%E5%B8%A6%E6%9D%83%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<h1 id="带权二分"><a href="#带权二分" class="headerlink" title="带权二分"></a>带权二分</h1><p>带权二分，又称为<script type="math/tex">wqs</script>二分或凸优化，它适用于一类<script type="math/tex">dp</script>的优化，可以将一个二维的状态转化为一维，从而达到优化时间复杂度的效果。</p>
<p>具体地，带权二分一般适用于这样一类问题：有<script type="math/tex">n</script>个物品，要求从里面选恰好<script type="math/tex">m</script>个（可能有若干限制），使得价值总和最优。但是，并不是所有这一类问题都可以使用<script type="math/tex">wqs</script>二分。</p>
<p>那么，具体什么情况可以使用带权二分呢？带权二分又是运用了什么思想呢？</p>
<span id="more"></span>
<h1 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h1><p>什么情况下，我们可以使用带权二分呢？注意我们上面提出的这一类问题，一般我们会设计状态为设<script type="math/tex">f[i][j]</script>表示前<script type="math/tex">i</script>个物品，选了<script type="math/tex">j</script>个的最优结果是什么。显然最后的答案是<script type="math/tex">f[n][m]</script>。</p>
<p>如果我们把<script type="math/tex">f[n]</script>画成图像：即我们画一张图像，每个点为<script type="math/tex">(i,f[n][i])</script>，并顺次连接。如果这个图像是凸的（不管是上凸还是下凸），我们就可以使用带权二分。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>我们的思想是去掉选择个数的条件，即我们去掉“恰好选<script type="math/tex">m</script>个”，下面我们不妨设问题让我们求最大值，<script type="math/tex">f[n]</script>的图像为上凸函数。</p>
<p>设<script type="math/tex">g[i]</script>表示<script type="math/tex">f[i][j]</script>的最大值，然后我们来<script type="math/tex">dp</script>出<script type="math/tex">g</script>，这个的时间复杂度显然就要优秀的多。但是，我们最后并不能通过<script type="math/tex">g</script>知道<script type="math/tex">f[n][m]</script>，因为<script type="math/tex">g[n]</script>代表的只是<script type="math/tex">f[n][i]</script>的最大值。</p>
<p>这个时候，我们考虑<script type="math/tex">f[n]</script>图像的导函数，由于是上凸函数，其导函数一定是递减的。其导函数与<script type="math/tex">x</script>轴的交点横坐标就是<script type="math/tex">f[n]</script>取最大值时的横坐标。</p>
<p>我们考虑给<script type="math/tex">f[n]</script>加上一个正比例函数<script type="math/tex">y=kx</script>，那么，这个时候其导函数会加上<script type="math/tex">k</script>，那么其与<script type="math/tex">x</script>轴的交点会往右移，换句话说，<script type="math/tex">f[n]</script>的最值点会往右移。那么，我们可以通过加上正比例函数，使得<script type="math/tex">f</script>的最值点位置调整。因为<script type="math/tex">g[n]</script>求的是<script type="math/tex">f[n][i]</script>的最值点，那么我们只需要调整<script type="math/tex">k</script>使得<script type="math/tex">f[n]</script>的最值点变到<script type="math/tex">x=m</script>上，那么此时的<script type="math/tex">g[n]-mk</script>就是答案。</p>
<p>怎样使得整个函数加上<script type="math/tex">kx</script>呢？注意<script type="math/tex">kx</script>的实际意义是每多选一个物品，我们就多获得<script type="math/tex">k</script>的价值，所以我们只需在<script type="math/tex">dp</script>的时候修改一下价值即可。</p>
<p>那么，我们怎么调整<script type="math/tex">k</script>呢？注意到<script type="math/tex">k</script>显然是可二分的，因此我们只需二分<script type="math/tex">k</script>（<script type="math/tex">k</script>的值域为<script type="math/tex">f[n]</script>导函数的值域），然后我们在<script type="math/tex">dp</script>的时候很容易记录<script type="math/tex">g[i]</script>取这个最优值时最少要选多少个物品（只需转移时稍微记录一下即可），设为<script type="math/tex">s[i]</script>，那么如果最后<script type="math/tex">s[n]>m</script>那么说明<script type="math/tex">k</script>要调小，否则说明<script type="math/tex">k</script>要调大。</p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>最后二分出来的<script type="math/tex">k</script>会是小数吗？</p>
<p>不会，我们只需在整数上进行二分即可。因为<script type="math/tex">k</script>的值域是<script type="math/tex">f[n]</script>导函数的值域。实际上<script type="math/tex">f[n]</script>是由一些折线构成的，相邻两个点的斜率为<script type="math/tex">f[n][i]-f[n][i-1]</script>，故只要<script type="math/tex">f[n]</script>中不存在小数，那么其导函数（即斜率的值）不可能会是小数。</p>
<p>如果最后二分出来的<script type="math/tex">k</script>中<script type="math/tex">s[n]\neq m</script>怎么办？</p>
<p>由上文所述，<script type="math/tex">k</script>不会是小数，因此如果最后<script type="math/tex">s[n]\neq m</script>，一定是因为<script type="math/tex">f[n]</script>导函数中<script type="math/tex">m</script>周围点的导函数与<script type="math/tex">m</script>相同，那么，注意<script type="math/tex">s[i]</script>的定义是当<script type="math/tex">g[i]</script>取最优值时<strong>最少</strong>要选多少物品，因此我们只需保留<script type="math/tex">s[n]\le m</script>中<script type="math/tex">s[n]</script>最大的所对应的<script type="math/tex">k</script>即可。</p>
<p>如果读者无法理解，可以想象导函数图像，是一些递减的水平线段，最后的<script type="math/tex">s[n]</script>即<script type="math/tex">x=m</script>时导函数上那个点所在线段的左端点的横坐标。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>那么，在考试的时候，我们怎样才能想到带权二分？</p>
<p>首先，明确带权二分是<script type="math/tex">dp</script>的优化，所以我们要先想到朴素的<script type="math/tex">dp</script>，然后如果发现这个<script type="math/tex">dp</script>无法获得满分，我们尝试把<script type="math/tex">f[n][i]</script>的表打出来，观察是否是凸的。如果是，尝试通过归纳法证明，实在无法证明可以进行大胆猜想，写完以后对拍验证。不放心的话，最后还是和前面的暴力<script type="math/tex">dp</script>数据分治一下。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈多项式操作的暴力实现</title>
    <url>/2020/07/27/%E6%B5%85%E8%B0%88%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%9A%84%E6%9A%B4%E5%8A%9B%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="多项式操作的暴力实现"><a href="#多项式操作的暴力实现" class="headerlink" title="多项式操作的暴力实现"></a>多项式操作的暴力实现</h1><p>对于有些题目，数据范围很小或者模数不是<script type="math/tex">998244353</script>，这个时候用<script type="math/tex">NTT</script>就不适用了，比如对于<script type="math/tex">n\le 1000</script>做多项式<script type="math/tex">\exp</script>，那么显然不如暴力<script type="math/tex">O(n^2)</script>常数小。另外，在考场上如果能用暴力写多项式操作尽量用暴力，因为码量小，好调试。</p>
<p>因此，我们不仅要掌握如何用<script type="math/tex">NTT</script>求多项式，还要了解暴力求解多项式的各种方法。</p>
<p>注意，暴力求解的复杂度都是<script type="math/tex">O(n^2)</script>。</p>
<span id="more"></span>
<h1 id="多项式乘法"><a href="#多项式乘法" class="headerlink" title="多项式乘法"></a>多项式乘法</h1><p>这个不用多说，根据定义直接类似背包实现即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        ans[i + j] += f[i] * g[j];</span><br></pre></td></tr></table></figure>
<h1 id="多项式除法"><a href="#多项式除法" class="headerlink" title="多项式除法"></a>多项式除法</h1><p>如果多项式能整除且我们要求除后的商，那么我们将背包操作倒过来实现即可。</p>
<p>如果我们要求除后的余数（比如线性递推），可以用类似数学的方法，每次提取因式消去最高项即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= m; i--)</span><br><span class="line">    <span class="keyword">if</span>(g[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">1ll</span> * g[i] * <span class="built_in">mpow</span>(f[m], mod - <span class="number">2</span>) % mod; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            g[i - j] -= <span class="number">1ll</span> * f[j] * t % mod;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="多项式求逆"><a href="#多项式求逆" class="headerlink" title="多项式求逆"></a>多项式求逆</h1><p>我们已知<script type="math/tex">F(x)</script>，我们现在要求一个<script type="math/tex">G(x)</script>，使得<script type="math/tex">F(x)G(x)\equiv1\pmod{x^m}</script>。</p>
<p>那么根据定义，我们有</p>
<script type="math/tex; mode=display">
[x^n]F(x)G(x)=\sum_{i=0}^nf_ig_{n-i}=[n=0]</script><p>那么</p>
<script type="math/tex; mode=display">
g_nf_0=[n=0]-\sum_{i=1}^{n}f_ig_{n-i}</script><p>直接递推即可。</p>
<h1 id="多项式ln"><a href="#多项式ln" class="headerlink" title="多项式ln"></a>多项式ln</h1><p>我们已知<script type="math/tex">F(x)</script>，要求<script type="math/tex">G(x)\equiv\ln F(x)\pmod{x^m}</script>。</p>
<p>首先，我们两边求导</p>
<script type="math/tex; mode=display">
G'(x)\equiv\frac{F'(x)}{F(x)}\pmod{x^m}\\
G'(x)F(x)\equiv F'(x)\pmod{x^m}</script><p>那么</p>
<script type="math/tex; mode=display">
[x^{n-1}]G'(x)F(x)=\sum_{i=0}^{n-1}f_ig_{n-i}(n-i)=f_nn</script><p>即</p>
<script type="math/tex; mode=display">
f_0g_nn=f_nn-\sum_{i=1}^{n-1}f_ig_{n-i}(n-i)</script><p>根据定义，边界条件为<script type="math/tex">g_0=0</script>，递推即可。</p>
<h1 id="多项式exp"><a href="#多项式exp" class="headerlink" title="多项式exp"></a>多项式exp</h1><p>我们已知<script type="math/tex">F(x)</script>，要求<script type="math/tex">G(x)\equiv \exp F(x) \pmod{x^m}</script>。实际上，我们要求</p>
<script type="math/tex; mode=display">
G(x)\equiv \sum_{i\ge 0}\frac{F^i}{i!}\pmod{x^m}</script><p>首先我们两边求导，有</p>
<script type="math/tex; mode=display">
G'(x)\equiv G(x)F'(x)\pmod{x^m}</script><p>那么</p>
<script type="math/tex; mode=display">
[x^{n-1}]G'(x)=g_nn=\sum_{i=0}^{n-1}f_{i+1}(i+1)g_{n-1-i}</script><p>即</p>
<script type="math/tex; mode=display">
g_nn=\sum_{i=1}^{n}f_iig_{n-i}</script><p>根据定义，<script type="math/tex">g_0=1</script>，依然直接递推即可。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈快速傅里叶变换FFT</title>
    <url>/2020/03/08/%E6%B5%85%E8%B0%88%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2FFT/</url>
    <content><![CDATA[<h1 id="快速傅里叶变换-FFT"><a href="#快速傅里叶变换-FFT" class="headerlink" title="快速傅里叶变换(FFT)"></a>快速傅里叶变换(FFT)</h1><p>在<script type="math/tex">OI</script>中，快速傅里叶变换一般是用来解决多项式乘法（卷积）问题的，什么是卷积？</p>
<p>设有两个函数<script type="math/tex">F(x),G(x)</script>，那么</p>
<script type="math/tex; mode=display">
H[n]=(F*G)[n]=\sum_{i=0}^n F[i]*G[n-i]</script><p>一般来说，暴力计算这个<script type="math/tex">H</script>是<script type="math/tex">O(n^2)</script>的，快速傅里叶变换可以将这个过程复杂度降低为<script type="math/tex">O(n\log_2n)</script>。</p>
<p>本文将通过单位根反演来详细介绍快速傅里叶变换的原理，并讲解<script type="math/tex">FFT</script>的两个组成部分<script type="math/tex">DFT,IDFT</script>的推导。</p>
<span id="more"></span>
<h1 id="多项式点值表示法"><a href="#多项式点值表示法" class="headerlink" title="多项式点值表示法"></a>多项式点值表示法</h1><p>我们一般见到的多项式是系数表示法，即</p>
<script type="math/tex; mode=display">
F(x)=a_0+a_1x+a_2x^2+...</script><p>我们知道，一个<script type="math/tex">n</script>次多项式可以由<script type="math/tex">n+1</script>个不同点唯一确定，那么我们将这<script type="math/tex">n+1</script>个点<script type="math/tex">(x_i,F(x_i))</script>看成这个多项式的点值表示法。</p>
<p>而对于点值表示法进行多项式乘法却异常地简单，只需将两个多项式点值表示法中横坐标相同的点的纵坐标相乘即可，复杂度线性。</p>
<p>但是，一般题目中给我们的都是系数表示法，暴力转化成点值表示法依然是<script type="math/tex">O(n^2)</script>的。实际上，快速傅里叶变换就是加速将多项式<strong>系数表示法</strong>转化为<strong>点值表示法</strong>的过程，将其的复杂度降为<script type="math/tex">O(nlog_2n)</script>。</p>
<h1 id="复数相关"><a href="#复数相关" class="headerlink" title="复数相关"></a>复数相关</h1><p>因为多项式点值表示法并不唯一，我们假设多项式次数为<script type="math/tex">n-1</script>，那么带入任意的<script type="math/tex">n</script>个<script type="math/tex">x</script>都可以得到一组点，那么，我们考虑将<script type="math/tex">n</script>个单位根<script type="math/tex">w_n^0,w_n^1...w_n^{n-1}</script>带入，得到不同的点值。</p>
<p>那么，单位根是什么？我们从头讲起。</p>
<h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>单位根是定义在复数意义上的，复数是形如<script type="math/tex">a+bi(a,b\in R,i=\sqrt{-1})</script>的形式的数，对应复平面上的<script type="math/tex">(a,b)</script>的向量。</p>
<p>模长：复数的模长定义为<script type="math/tex">\sqrt{a^2+b^2}</script>，即该复数在复平面上对应向量到原点的距离。</p>
<h2 id="复数基本运算"><a href="#复数基本运算" class="headerlink" title="复数基本运算"></a>复数基本运算</h2><p>复数加减：<script type="math/tex">(a+bi)+(c+di)=(a+c)+(b+d)i</script>。</p>
<p>复数乘法：<script type="math/tex">(a+bi)(c+di)=(ac-bd)+(ad+bc)i</script>（可以暴力展开，将<script type="math/tex">i^2</script>看成<script type="math/tex">-1</script>即可）。</p>
<p>复数相乘，在复平面上的意义为<strong>模长相乘，辅角相加</strong>。</p>
<h2 id="共轭复数"><a href="#共轭复数" class="headerlink" title="共轭复数"></a>共轭复数</h2><p>我们称<script type="math/tex">a+bi</script>和<script type="math/tex">a-bi</script>为共轭复数，在复平面上，可以看成关于<script type="math/tex">x</script>轴对称的两个向量。</p>
<h2 id="单位根"><a href="#单位根" class="headerlink" title="单位根"></a>单位根</h2><p>单位根，就是满足<script type="math/tex">z^n=1</script>的复数（可以看作将复平面上单位圆平均分为<script type="math/tex">n</script>个部分的单位复数），记为<script type="math/tex">w_n</script>。</p>
<p>所谓<script type="math/tex">n</script>次单位根，就是将单位圆平分为<script type="math/tex">n</script>个部分的<script type="math/tex">n</script>个向量对应的复数。依次记为<script type="math/tex">w_n^0,w_n^1,w_n^2...w_n^{n-1}</script>。</p>
<p>我们记<script type="math/tex">w_n</script>的辅角为<script type="math/tex">\theta=\frac{2\pi}{n}</script>，那么每次<script type="math/tex">w_n^k->w_n^{k+1}</script>在图像上的意义就是<script type="math/tex">w_n^k</script>逆时针旋转<script type="math/tex">\theta</script>得到的向量。</p>
<p>考虑单位根的时候，一般放在复平面中考虑，更容易理解。</p>
<h2 id="单位根性质"><a href="#单位根性质" class="headerlink" title="单位根性质"></a>单位根性质</h2><p>性质<script type="math/tex">1</script>：<script type="math/tex">w_{2n}^{2k}=w_n^k</script>，这个根据复平面上的平分单位圆的概念很直观，不作解释。</p>
<p>性质<script type="math/tex">2</script>：<script type="math/tex">w_n^{k+\frac{n}{2}}=-w_n^k</script>，相当于将<script type="math/tex">w_n^k</script>逆时针转<script type="math/tex">\pi</script>得到<script type="math/tex">w_n^{k+\frac{n}{2}}</script>，自然横纵坐标都取反。</p>
<p>实际上，<script type="math/tex">FFT</script>就是根据这两个简单的性质进行的。</p>
<h1 id="离散傅里叶变换-DFT"><a href="#离散傅里叶变换-DFT" class="headerlink" title="离散傅里叶变换(DFT)"></a>离散傅里叶变换(DFT)</h1><p>我们现在要把<script type="math/tex">w_n^0,w_n^1,...w_n^{n-1}</script>带入多项式，计算其点值。</p>
<p>我们令<script type="math/tex">m=\frac{n}{2}</script>，因为<script type="math/tex">n</script>是<script type="math/tex">2</script>的整数次幂，所以<script type="math/tex">m</script>也一定是整数。</p>
<p>我们设</p>
<script type="math/tex; mode=display">
A(w_n^k)=\sum_{i=0}^{n-1}a[i](w_n^k)^i</script><p>注意，这里的<script type="math/tex">a[i]</script>和原来多项式中的<script type="math/tex">a[i]</script>不同，只是由上一层递归下来得到的<script type="math/tex">n</script>个数，后面我们会知道是什么。</p>
<p>那么，对于<script type="math/tex">k<\frac{n}{2}</script>，即<script type="math/tex">k<m</script>，我们有</p>
<script type="math/tex; mode=display">
A(w_n^k)=\sum_{i=0}^{n-1}a[i](w_n^{k})^i\\
=\sum_{i=0}^{m-1}a[2i](w_n^k)^{2i}+\sum_{i=0}^{m-1}a[2i+1](w_n^k)^{2i+1}\\
=\sum_{i=0}^{m-1}a[2i]w_n^{2ki}+\sum_{i=0}^{m-1}a[2i+1]w_n^{2ki+k}\\
=\sum_{i=0}^{m-1}a[2i]w_{2m}^{2ki}+w_n^k\sum_{i=0}^{m-1}a[2i+1]w_{2m}^{2ki}</script><p>根据上面所说的性质一，<script type="math/tex">w_{2n}^{2i}=w_n^i</script>可知</p>
<script type="math/tex; mode=display">
A(w_n^k)=\sum_{i=0}^{m-1}a[2i]w_m^{ki}+w_n^k\sum_{i=0}^{m-1}a[2i+1]w_m^{ki}</script><p>又由性质三，我们可以知道：</p>
<script type="math/tex; mode=display">
A(w_n^{k+\frac{n}{2}})=(-1)^{\frac{n}{2}}\sum_{i=0}^{m-1}a[2i]w_m^{ki}+(-1)^{\frac{n}{2}}w_n^{k+\frac{n}{2}}\sum_{i=0}^{m-1}a[2i+1]w_m^{ki}\\
=\sum_{i=0}^{m-1}a[2i]w_m^{ki}-w_n^k\sum_{i=0}^{m-1}a[2i+1]w_m^{ki}</script><p>我们递归到下一层的时候分别<strong>分治偶数项和奇数项</strong>计算对应的点值，设为<script type="math/tex">A_0,A_1</script>，那么显然有</p>
<script type="math/tex; mode=display">
A(w_n^k)=A_0(w_\frac{n}{2}^k)+w_n^kA_1(w_{\frac{n}{2}}^k)\\
A(w_n^{k+\frac{n}{2}})=A_0(w_\frac{n}{2}^k)-w_n^kA_1(w_{\frac{n}{2}}^k)</script><p>那么，实际上我们每次递归到的一层的<script type="math/tex">a</script>是上一层<script type="math/tex">a</script>的奇数项或偶数项。</p>
<p>这样，时间复杂度是<script type="math/tex">O(n\log_2n)</script>。</p>
<p>由于递归效率不高，所以一般采用迭代的方式来实现这个过程，即注意到多项式的<script type="math/tex">i</script>次项到分治边界时的下标为<script type="math/tex">r[i]</script>，<script type="math/tex">r[i]</script>是<script type="math/tex">i</script>二进制翻转后的数，所以我们每次从下往上迭代即可。</p>
<h1 id="FFT的原理"><a href="#FFT的原理" class="headerlink" title="FFT的原理"></a>FFT的原理</h1><p>知道了这些前置知识，我们就可以来学习<script type="math/tex">FFT</script>的原理了。</p>
<p>我们可以用单位根反演来理解<script type="math/tex">FFT</script>的原理。</p>
<p>我们要明确，<script type="math/tex">FFT</script>本质上求的是<strong>循环卷积</strong>，也就是说，我们实际上求的是</p>
<script type="math/tex; mode=display">
C_r=\sum_{(i+j)\bmod n=r}A_i*B_j</script><p>而在平时的应用中，如果我们只是单纯地要求卷积，只需让<script type="math/tex">n</script>变为一个比较大的数，从而使<script type="math/tex">(i+j)\bmod n=(i+j)</script>，从而形成卷积的效果。但是要明确，<script type="math/tex">FFT</script>实际上是用来求循环卷积的。</p>
<p>而<script type="math/tex">FFT</script>的推导，也是基于循环卷积的性质。我们可以把式子写为</p>
<script type="math/tex; mode=display">
C_r=\sum_{i,j}[(i+j)\bmod n=r]A_i*B_j</script><p>中间这个取模的形式让我们想到<strong>单位根反演</strong>，如果读者不是很了解，可以先阅读<a href="https://cmwqf.github.io/2020/01/08/%E6%B5%85%E8%B0%88%E5%8E%9F%E6%A0%B9%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/">单位根反演</a>。</p>
<p>上面的式子可以变换为</p>
<script type="math/tex; mode=display">
C_r=\sum_{i,j}[(i+j-r)\bmod n=0]A_i*B_j</script><p>那么根据单位根反演，有</p>
<script type="math/tex; mode=display">
C_r=\sum_{i,j}A_i*B_j*\frac{1}{n}\sum_{k=0}^{n-1}w_n^{(i+j-r)k}</script><p>这样，我们就完美地去掉了<script type="math/tex">(i+j)\bmod n=r</script>的限制。</p>
<p>进一步地，</p>
<script type="math/tex; mode=display">
C_r=\frac{1}{n}\sum_{k=0}^{n-1}(w_n^{-r})^k*\sum_{i}A_i(w_n^k)^i*\sum_{j}B_j(w_n^k)^j</script><p>现在，我们发现之前求的点值派上了用场，记</p>
<script type="math/tex; mode=display">
DFT(A)_k=\sum_{i}A_i(w_n^k)^i\\
DFT(B)_k=\sum_iB_i(w_n^k)^i</script><p>那么应用我们之前的方法，我们可以在<script type="math/tex">O(n\log_2n)</script>的时间复杂度内求出<script type="math/tex">DFT(A)</script>和<script type="math/tex">DFT(B)</script>。</p>
<p>我们记</p>
<script type="math/tex; mode=display">
T_k=DFT(A)_k*DFT(B)_k</script><p>那么问题便转化为求</p>
<script type="math/tex; mode=display">
C_r=\frac{1}{n}\sum_{k=0}^{n-1}(w_n^{-r})^kT_k</script><p>前面的<script type="math/tex">\frac{1}{n}</script>可以忽略，最后再乘上去，对于剩下的部分，容易发现，这个式子和求点值的式子几乎一模一样，只是原本里面单位根的上标变成负的了。</p>
<p>注意到<script type="math/tex">w_n^{-r}=w_n^{n-r}</script>，因此我们可以把<script type="math/tex">T</script>直接进行<script type="math/tex">DFT</script>，然后对于<script type="math/tex">1</script>到<script type="math/tex">n-1</script>的点值直接<script type="math/tex">reverse</script>一下，最后乘上<script type="math/tex">\frac{1}{n}</script>即可得到<script type="math/tex">C</script>。</p>
<p>其实这个过程，就是<script type="math/tex">IDFT</script>。</p>
<p>综上，我们可以在<script type="math/tex">O(n\log_2n)</script>的时间复杂度内解决多项式乘法。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex *a, <span class="keyword">int</span> type, <span class="keyword">int</span> lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; r[i]) <span class="built_in">swap</span>(a[i], a[ r[i] ]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i += (mid &lt;&lt; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                Complex x = a[i + j], y = a[i + mid + j] * wn[mid + j];</span><br><span class="line">                a[i + j] = x + y; a[i + mid + j] = x - y;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">if</span>(type == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++) a[i] /= lim;</span><br><span class="line">        <span class="built_in">reverse</span>(a + <span class="number">1</span>, a + lim);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈常系数齐次线性递推</title>
    <url>/2020/12/20/%E6%B5%85%E8%B0%88%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/</url>
    <content><![CDATA[<h1 id="常系数齐次线性递推"><a href="#常系数齐次线性递推" class="headerlink" title="常系数齐次线性递推"></a>常系数齐次线性递推</h1><p>给定<script type="math/tex">a_1,a_2,...,a_m</script>以及<script type="math/tex">f_1,f_2,...,f_m</script>，对于<script type="math/tex">\forall n>m</script>，满足</p>
<script type="math/tex; mode=display">
f_n=\sum_{i=1}^ma_if_{n-i}</script><p>每次给定<script type="math/tex">n</script>，求<script type="math/tex">f_n</script>。<script type="math/tex">n\le 10^{18}</script>。</p>
<p>这个显然可以矩阵乘法，然而有所不同的是，这回<script type="math/tex">m</script>比较大，可能有<script type="math/tex">m\le 500</script>甚至<script type="math/tex">m\le 30000</script>，那么，普通的矩阵乘法就无法解决了。</p>
<p>这个时候，我们就可以使用一些技巧来加速这个过程。</p>
<span id="more"></span>
<h1 id="特征多项式"><a href="#特征多项式" class="headerlink" title="特征多项式"></a>特征多项式</h1><p>设<script type="math/tex">A</script>是<script type="math/tex">n</script>阶矩阵，那么如果数<script type="math/tex">\lambda</script>和非零向量<script type="math/tex">v</script>满足</p>
<script type="math/tex; mode=display">
\lambda v=Av</script><p>那么称<script type="math/tex">\lambda</script>为矩阵<script type="math/tex">A</script>的特征值，<script type="math/tex">v</script>为矩阵<script type="math/tex">A</script>的特征向量。</p>
<p>上式可以写成</p>
<script type="math/tex; mode=display">
(\lambda I - A)v=0</script><p>对于某个特定的<script type="math/tex">\lambda</script>，这个式子有非零<script type="math/tex">v</script>解当且仅当</p>
<script type="math/tex; mode=display">
\det(\lambda I-A)=0</script><p>把<script type="math/tex">\lambda</script>看成未知量，那么<script type="math/tex">\det(\lambda I-A)</script>可以看成关于<script type="math/tex">\lambda</script>的一个多项式，记为<script type="math/tex">p_A(\lambda)</script>，称为<script type="math/tex">A</script>的特征多项式。</p>
<p>显然，这个多项式应该是一个关于<script type="math/tex">\lambda</script>的<script type="math/tex">n</script>次多项式。</p>
<h1 id="Cayley-Hamilton定理"><a href="#Cayley-Hamilton定理" class="headerlink" title="Cayley-Hamilton定理"></a>Cayley-Hamilton定理</h1><p>为什么要引入特征多项式的定义呢？其实就是为了这个定理做准备。</p>
<p>这个定理的内容很简洁：</p>
<script type="math/tex; mode=display">
p_A(A)=O</script><p>其中<script type="math/tex">O</script>是零矩阵。</p>
<p>如果读者感兴趣，可以自行查阅证明，此处略去。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>现在，我们就可以讲述常系数齐次线性递推的原理了。</p>
<p>我们想要加速矩阵快速幂的过程，那么我们的目标：对于一个矩阵<script type="math/tex">A</script>，快速算出<script type="math/tex">A^n</script>。</p>
<p>假设这个<script type="math/tex">m</script>阶矩阵<script type="math/tex">A</script>的特征多项式为</p>
<script type="math/tex; mode=display">
p_A(\lambda)=\sum_{i=0}^mc_i\lambda^i</script><p>由<script type="math/tex">Cayley-Hamilton</script>定理可知，</p>
<script type="math/tex; mode=display">
p_A(A)=\sum_{i=0}^mc_iA^i=0</script><p>那么我们只需要求出<script type="math/tex">G(x)=x^n\bmod p_A(x)</script>，最终的答案就是<script type="math/tex">A^n=G(A)</script>。</p>
<p>对于特征多项式的求法，我们可以用拉格朗日插值，但是由于常系数齐次线性递推的矩阵比较特殊，我们可以直接计算，这个我们后面再说。</p>
<p>假设我们已经求出了<script type="math/tex">p_A(x)</script>，那么我们只需要求出<script type="math/tex">G(x)</script>即可解决问题，因为<script type="math/tex">G(x)</script>必然是一个不超过<script type="math/tex">m-1</script>次的多项式，那么有</p>
<script type="math/tex; mode=display">
G(x)=\sum_{i=0}^{m-1}g_ix^i\\
G(A)=\sum_{i=0}^{m-1}g_iA^i\\
f_n=\sum_{i=0}^{m-1}g_if_{m+i}</script><p>因此我们可以根据<script type="math/tex">f_m,f_{m+1},...,f_{2m-1}</script>来推出<script type="math/tex">f_n</script>。</p>
<h1 id="多项式取模"><a href="#多项式取模" class="headerlink" title="多项式取模"></a>多项式取模</h1><p>首先我们注意到要求出<script type="math/tex">G(x)</script>，我们要进行多项式取模。有<script type="math/tex">FFT</script>版的多项式取模+快速幂做法，时间复杂度<script type="math/tex">O(m\log m\log n)</script>，但是那个非常难写，考场上几乎不可能写出来。我们来介绍暴力方法。</p>
<p>在<a href="https://cmwqf.github.io/2020/07/27/%E6%B5%85%E8%B0%88%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%9A%84%E6%9A%B4%E5%8A%9B%E5%AE%9E%E7%8E%B0/">多项式操作的暴力实现</a>中，我介绍了如何暴力进行多项式取模，但是在此处，我们不能直接对<script type="math/tex">x^n</script>进行多项式取模，这样时间复杂度<script type="math/tex">O(n)</script>，无法接受。</p>
<p>我们可以考虑快速幂的思想，只不过变成在<script type="math/tex">\bmod p_A(x)</script>的情况下进行。</p>
<p>考虑快速幂的过程，我们把数换成多项式，并且每次让多项式先平方，再取模，这样时间复杂度为<script type="math/tex">O(m^2\log n)</script>。</p>
<h1 id="特征多项式求法"><a href="#特征多项式求法" class="headerlink" title="特征多项式求法"></a>特征多项式求法</h1><p>现在，唯一的问题是如何求特征多项式。</p>
<p>考虑<script type="math/tex">A</script>长什么样子？</p>
<script type="math/tex; mode=display">
A=
\begin{bmatrix}
a_1 & a_2 & a_3 & ... & a_{m-1} & a_m\\
1 & 0 & 0 & ... & 0 & 0\\
0 & 1 & 0 & ... & 0 & 0\\
... & ... & ... & ... & ... & ...\\
0 & 0 & 0 & ... & 1 & 0
\end{bmatrix}</script><p>那么</p>
<script type="math/tex; mode=display">
p_A(\lambda)=\det(\lambda I-A)=|
\begin{bmatrix}
\lambda - a_1 & -a_2 & -a_3 & ... & -a_{m-1} & -a_m\\
-1 & \lambda & 0 & ... & 0 & 0\\
0 & -1 & \lambda & ... & 0 & 0\\
... & ... & ... & ... & ... & ...\\
0 & 0 & 0 & ... & -1 & \lambda
\end{bmatrix}
|</script><p>假设<script type="math/tex">B=\lambda I - A</script>，那么根据第一行展开，有</p>
<script type="math/tex; mode=display">
\det(B)=(\lambda-a_1)B_{1,1}-a_2B_{1,2}-...-a_mB_{1,m}</script><p>其中<script type="math/tex">B_{i,j}</script>表示代数余子式。</p>
<p>注意到<script type="math/tex">1,i</script>余子式的行列式就是其对角线上数的乘积，即<script type="math/tex">(-1)^{i-1}\lambda^{m-i}</script>，则</p>
<script type="math/tex; mode=display">
B_{1,i}=(-1)^{1+i}(-1)^{i-1}\lambda^{m-i}=\lambda^{m-i}</script><p>那么我们有</p>
<script type="math/tex; mode=display">
\det(B)=\lambda^m-\sum_{i=1}^ma_i\lambda^{m-i}</script>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈后缀自动机</title>
    <url>/2019/03/16/%E6%B5%85%E8%B0%88%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>强烈推荐<a href="http://hihocoder.com/problemset/problem/1441">hihocoder后缀自动机</a>，里面有详细的后缀自动机的基础知识，我们来看里面所说的几个重要的概念：</p>
<h2 id="Endpos"><a href="#Endpos" class="headerlink" title="Endpos"></a>Endpos</h2><p><script type="math/tex">endpos(s)</script>指的是<script type="math/tex">s</script>在原串中的所有出现的位置中最后一个字符所在的位置集合；</p>
<p>如原串<script type="math/tex">aabab</script>，则<script type="math/tex">endpos(ab)=\{3,5\}</script>。</p>
<p>而后缀自动机的每一个状态，就是由有着相同的<script type="math/tex">endpos</script>的子串构成的。</p>
<span id="more"></span>
<h2 id="重要性质"><a href="#重要性质" class="headerlink" title="重要性质"></a>重要性质</h2><p>我们记<script type="math/tex">SAM</script>(后缀自动机)的一个状态<script type="math/tex">st</script>所有的子串为<script type="math/tex">substring(st)</script>，然后记<script type="math/tex">longest(st)</script>为状态为<script type="math/tex">st</script>的所有子串中最长的一个，可以证明（这个刚刚链接里面有，就不再赘述），状态为<script type="math/tex">st</script>的所有子串都是<script type="math/tex">longest(st)</script>的长度为连续的后缀。</p>
<p>为什么不是所有的后缀，而是只有一段连续的后缀呢？</p>
<p>因为随着子串长度的减小，它有可能还会出现在其他的地方，于是它的<script type="math/tex">endpos</script>就会多一些，就会分到其他的状态里。</p>
<h1 id="如何构建SAM"><a href="#如何构建SAM" class="headerlink" title="如何构建SAM"></a>如何构建SAM</h1><h2 id="Len"><a href="#Len" class="headerlink" title="Len"></a>Len</h2><p><strong>len[i]表示SAM中i这个状态的所有字符串的最长的那一个的长度，minlen则相反。</strong></p>
<p>我们考虑这样一个性质：我们记<script type="math/tex">shortest(i)</script>为状态为<script type="math/tex">i</script>最短的那个字符串，<script type="math/tex">longest(i)</script>为最长的，而<script type="math/tex">shortest(i)</script>减去它的第一个字符，必然是另一个状态<script type="math/tex">j</script>的<script type="math/tex">longest(j)</script>，即必然存在且仅存在一个<script type="math/tex">j</script>，使得<script type="math/tex">minlen[i]=len[j]+1</script>。</p>
<p>为什么呢？</p>
<p>我们用反证法（<del>是我口胡的</del>），假设<script type="math/tex">shortest(i)</script>减去其第一个字符后为<script type="math/tex">s</script>，在另一个状态<script type="math/tex">j</script>中并不是最长的，那么由之前我们所说的性质可得，它必然是<script type="math/tex">longest(j)</script>的一个后缀，那么，<script type="math/tex">len(j)>=minlen(i)</script>，且<script type="math/tex">endpos(s)\supset endpos(shortest(i))</script>，又<script type="math/tex">endpos(s)=endpos(longest(j))</script>，则有<script type="math/tex">endpos(longest(j))\supset endpos(shortest(i))</script>，也就是说，以<script type="math/tex">shortest(i)</script>的最后一个字符为结尾的还有<script type="math/tex">longest(j)</script>，那么由两种可能：</p>
<p>1.<script type="math/tex">shortest(i)是longest(j)</script>的子串，那么显然矛盾，此时<script type="math/tex">longest(j)</script>应该在状态<script type="math/tex">i</script>里面；</p>
<p>2.<script type="math/tex">shortest(i)</script>不是<script type="math/tex">longest(j)</script>的子串，而它们又以同一个位置结尾，而且<script type="math/tex">len(j)>=minlen(i)</script>，显然矛盾。</p>
<p>综上所述，结论成立。</p>
<h2 id="Parent树"><a href="#Parent树" class="headerlink" title="Parent树"></a>Parent树</h2><p>我们设<script type="math/tex">link(i)</script>为<script type="math/tex">i</script>在<script type="math/tex">parent</script>树上的父亲（或称为后缀链接）</p>
<p>那么上文所述的<script type="math/tex">i</script>对应另一个节点<script type="math/tex">j</script>，使得<script type="math/tex">minlen(i)=len(j)+1</script>在<script type="math/tex">parent</script>树中就是<script type="math/tex">link(i)=j</script>。</p>
<p>换句话说，<script type="math/tex">link(i)</script>就是<script type="math/tex">longest(i)</script>（换成<script type="math/tex">shortest(i)</script>也可以）的后缀中与其不属于同一个状态的最长的后缀所属的状态。</p>
<p><strong>因此，<script type="math/tex">Parent</script>树和<script type="math/tex">SAM</script>的节点都是一样的，只是边不同而已。</strong></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>我们定义一个状态，它有这么几条信息：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len, link;<span class="comment">//len:最长的长度,link:即上文所述的link</span></span><br><span class="line">    <span class="keyword">int</span> trans[S];<span class="comment">//S:字符集大小,这个就是转移函数,看能转移到哪个状态的,如果节省空间,也可以用map</span></span><br><span class="line">&#125;st[maxN * <span class="number">2</span> + <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p><strong>注意：为了方便，下文就直接用<script type="math/tex">len[i], link[i], trans[i][s]</script>来表示了</strong></p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>一开始，后缀自动机只包含一个节点<script type="math/tex">t0</script>，编号为0（其他状态编号为1，2，…)，为了方便，我们分配给它<script type="math/tex">len[0]=0,link[0]=-1</script>（<script type="math/tex">-1</script>表示一个虚拟的不存在的状态）。</p>
<h2 id="添加一个字符"><a href="#添加一个字符" class="headerlink" title="添加一个字符"></a>添加一个字符</h2><p><strong>注：以下文字大多来源于俄文后缀自动机那篇文章的中文翻译</strong></p>
<ol>
<li><p>我们令加入这个字符<script type="math/tex">c</script>前的字符串状态为<script type="math/tex">last</script>，（一开始<script type="math/tex">last=0</script>且我们会不断修改<script type="math/tex">last</script>）；</p>
</li>
<li><p>我们创建一个新的状态<script type="math/tex">cur</script>，并且<script type="math/tex">len[cur]=len[last]+1</script>，此时<script type="math/tex">link[cur]</script>的值还未知。</p>
</li>
<li><p>我们的流程：</p>
<ol>
<li><p>我们从状态<script type="math/tex">last</script>开始遍历<script type="math/tex">parent</script>树，如果当前状态还没有到<script type="math/tex">c</script>的转移，我们就添加一个到<script type="math/tex">cur</script>的转移，如果我们找到某一个节点<script type="math/tex">p</script>存在字符<script type="math/tex">c</script>的转移，即<script type="math/tex">trans[p][c]!=0</script>，我们就停下来。</p>
</li>
<li><p>如果我们没有找到<script type="math/tex">p</script>，我们就会达到虚拟状态<script type="math/tex">-1</script>，于是，我们直接对于所有路径上的<script type="math/tex">v</script>，<script type="math/tex">trans[v][c]=cur</script>，然后<script type="math/tex">link[cur]=-1</script>并退出就好了。</p>
</li>
<li><p>如果我们找到了某个<script type="math/tex">p</script>使得<script type="math/tex">trans[p][c]=q</script>，这个时候我们就要分情况讨论了：</p>
<ol>
<li><p>如果<script type="math/tex">longest(q)</script>就是<script type="math/tex">longest(p)</script>在末尾加上<script type="math/tex">c</script>这个字符，等价于<script type="math/tex">len[q]=len[p]+1</script>，这个时候，我们只要增加<script type="math/tex">link[cur]=q</script>就好了。</p>
<p>为什么呢？</p>
<p>我们考虑现在我们要新弄出来一个后缀为<script type="math/tex">longest(p)+c</script>，又因为<script type="math/tex">longest(p)+c==longest(q)</script>，而又因为<script type="math/tex">q</script>中的串都是<script type="math/tex">longest(q)</script>的后缀，所以所有到达<script type="math/tex">q</script>的串都是新串后缀，而它们的<script type="math/tex">endpos</script>都会增加<script type="math/tex">n</script>(<script type="math/tex">n</script>为<script type="math/tex">c</script>所在的位置)这个数，所以仍然是在同一个状态，符合<script type="math/tex">SAM</script>，又这个<script type="math/tex">q</script>是<script type="math/tex">p</script>到达的第一个后缀，所以直接<script type="math/tex">link[cur]=q</script>就好了。</p>
</li>
<li><p>这就是最麻烦的一个部分了，如果<script type="math/tex">len[q]!=len[p]+1</script>，即<script type="math/tex">len[q]>len[p]+1</script>，说明至少还有一个串是比<script type="math/tex">longest(p)+c</script>的串属于<script type="math/tex">q</script>，且这个串必然不是<script type="math/tex">cur</script>的后缀。</p>
<p>如果这个串是<script type="math/tex">cur</script>的后缀，那么这个串去掉<script type="math/tex">c</script>必然是原串的后缀，且长度比<script type="math/tex">longest(p)</script>还长，那么它会被先访问到。矛盾，所以，这个串必然不是<script type="math/tex">cur</script>的后缀。</p>
<p>也就是说，现在的<script type="math/tex">q</script>被分为了两类，一类是不大于<script type="math/tex">len[p]+1</script>的，它们是<script type="math/tex">cur</script>的后缀，还有一类是大于<script type="math/tex">len[p]+1</script>的，它们不是。也就是说，现在我们要更新的<script type="math/tex">q</script>中一类的<script type="math/tex">endpos</script>比另一类多了一个<script type="math/tex">n</script>，这时，<script type="math/tex">q</script>的这两类实际上不能再被分在一个类里面了（否则就违背了<script type="math/tex">SAM</script>)。</p>
<p>怎么办呢？</p>
<p>我们考虑把<script type="math/tex">endpos</script>含有<script type="math/tex">n</script>的那一类提出来，显然，旧的<script type="math/tex">SAM</script>没有与之相同的状态。</p>
<p>所以，我们考虑新建一个节点<script type="math/tex">nq</script>，将<script type="math/tex">endpos</script>中含有<script type="math/tex">n</script>的那一类转移到这个节点上来，<script type="math/tex">q</script>中只保留剩下的点，然后，我们考虑它们的连边。</p>
<p>首先，显然地，<script type="math/tex">len[nq]=len[p]+1</script>。</p>
<p>然后，对于它的<script type="math/tex">trans</script>，可以直接用原来<script type="math/tex">q</script>的<script type="math/tex">trans</script>，也就是说，<script type="math/tex">nq</script>中的字符串和<script type="math/tex">q</script>中的字符串在后面都加一个字符后，仍是一个状态。<del>感性理解一下就好了。</del></p>
<p>最后，我们考虑<script type="math/tex">nq</script>的<script type="math/tex">link</script>，原来的<script type="math/tex">q</script>被拆成了两个点<script type="math/tex">q,nq</script>，<script type="math/tex">len(link(nq))<len(nq)<len(q)</script>，又因为<script type="math/tex">link(nq)</script>必然等于原串中的<script type="math/tex">link(q)</script>，我们就相当于要在这个链表一样的东西里插入<script type="math/tex">nq</script>，我们像修改链表一样，让<script type="math/tex">link(nq)=link(q),link(q)=nq</script>。</p>
<p>现在，我们再考虑<script type="math/tex">cur</script>的<script type="math/tex">link</script>，这个<script type="math/tex">link[cur]</script>必然是<script type="math/tex">q</script>和<script type="math/tex">nq</script>之一，而<script type="math/tex">q</script>中都不是<script type="math/tex">cur</script>的后缀，所以显然，<script type="math/tex">link[cur]=nq</script>。</p>
<p>不仅如此，我们还要把沿着这条链往上跳<script type="math/tex">parent</script>树中所有<script type="math/tex">trans[i][c]=q</script>的变成<script type="math/tex">trans[i][c]=nq</script>，</p>
<p>为什么呢？</p>
<p>这些点本来是<script type="math/tex">last</script>的后缀，加了一个<script type="math/tex">c</script>后，即<script type="math/tex">trans[c]</script>应该是<script type="math/tex">cur</script>的后缀，由于<script type="math/tex">q</script>中的<script type="math/tex">endpos</script>不包含<script type="math/tex">n</script>，即<script type="math/tex">q</script>中字符串不是<script type="math/tex">cur</script>的后缀，所以不符合后缀自动机的性质，要把它们的<script type="math/tex">trans</script>变为<script type="math/tex">nq</script>。</p>
<p>到这里，算法大致就讲完了，我们来看代码吧！！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cur = ++ cnt; </span><br><span class="line">    st[cur].len = st[last].len + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p = last;</span><br><span class="line">    <span class="keyword">for</span>(; p &amp;&amp; !st[p].trans[c]; p = st[p].link) st[p].trans[c] = cur; </span><br><span class="line">    <span class="keyword">if</span>(!p) st[cur].link = <span class="number">1</span>;  <span class="comment">//case 1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q = st[p].trans[c];</span><br><span class="line">        <span class="keyword">if</span>(st[q].len == st[p].len + <span class="number">1</span>) st[cur].link = q; <span class="comment">// case 2</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> nq = ++ cnt;</span><br><span class="line">            st[nq] = st[q];</span><br><span class="line">            st[nq].len = st[p].len + <span class="number">1</span>;</span><br><span class="line">            st[q].link = st[cur].link = nq;</span><br><span class="line">            <span class="keyword">for</span>(; p &amp;&amp; st[p].trans[c] == q; p = st[p].link) st[p].trans[c] = nq;</span><br><span class="line">        &#125; <span class="comment">// case 3   </span></span><br><span class="line">    &#125;</span><br><span class="line">    last = cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.luogu.org/problemnew/show/P3804">后缀自动机模板</a></p>
<p>虽说是模板题，但是也是有一定难度的。我们要知道的是：</p>
<p>一个子串出现的次数等于其所在状态的<script type="math/tex">endpos</script>的大小，而其<script type="math/tex">endpos</script>的大小等于其在<script type="math/tex">parent</script>树中子树的作为<script type="math/tex">np</script>结点的个数。</p>
<p>就是在加入新的节点的时候<script type="math/tex">size[cur]=1</script>就好了</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">3e6</span> + <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len, link;</span><br><span class="line">    <span class="keyword">int</span> trans[<span class="number">30</span>];</span><br><span class="line">&#125;st[maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125;edge[maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>, n, last = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxN + <span class="number">1</span>], tot;</span><br><span class="line">LL ans, f[maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cur = ++ cnt; </span><br><span class="line">    f[cur] = <span class="number">1</span>;</span><br><span class="line">    st[cur].len = st[last].len + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p = last;</span><br><span class="line">    <span class="keyword">for</span>(; p &amp;&amp; !st[p].trans[c]; p = st[p].link) st[p].trans[c] = cur; </span><br><span class="line">    <span class="keyword">if</span>(!p) st[cur].link = <span class="number">1</span>;  <span class="comment">//case 1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q = st[p].trans[c];</span><br><span class="line">        <span class="keyword">if</span>(st[q].len == st[p].len + <span class="number">1</span>) st[cur].link = q; <span class="comment">// case 2</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> nq = ++ cnt;</span><br><span class="line">            st[nq] = st[q];</span><br><span class="line">            st[nq].len = st[p].len + <span class="number">1</span>;</span><br><span class="line">            st[q].link = st[cur].link = nq;</span><br><span class="line">            <span class="keyword">for</span>(; p &amp;&amp; st[p].trans[c] == q; p = st[p].link) st[p].trans[c] = nq;</span><br><span class="line">        &#125; <span class="comment">// case 3   </span></span><br><span class="line">    &#125;</span><br><span class="line">    last = cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot ++;</span><br><span class="line">    edge[tot].to = y;</span><br><span class="line">    edge[tot].next = head[x];</span><br><span class="line">    head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(edge[i].to);</span><br><span class="line">        f[x] += f[ edge[i].to ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[x] != <span class="number">1</span>) ans = <span class="built_in">max</span>(ans, f[x] * st[x].len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">extend</span>(s[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt; i++) <span class="built_in">add</span>(st[i].link, i);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈悬线法</title>
    <url>/2019/08/20/%E6%B5%85%E8%B0%88%E6%82%AC%E7%BA%BF%E6%B3%95/</url>
    <content><![CDATA[<h1 id="悬线法"><a href="#悬线法" class="headerlink" title="悬线法"></a>悬线法</h1><p>什么是悬线法？</p>
<p>悬线法是用来解决最大子矩形问题的有力武器，它的思想很简单，代码也很好写。</p>
<span id="more"></span>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>一般地，我们有一张<script type="math/tex">n*m</script>的图，里面有一些障碍，我们想要求出一个最大的子矩形，使得它里面没有任何障碍（或者说，使它满足某个条件）。</p>
<p>我们考虑从每个点向上作一条射线，这条线如果遇到一个障碍或者是矩形的上边界就停下。这条线，就叫做悬线。我们把这条线尽可能地往左右移动（尽可能指的是不遇到障碍），就可以围成一个极大子矩形，这个子矩形是这条悬线所能构成的最大的子矩形。</p>
<p>显然，最大子矩形是属于所有悬线能构成的极大子矩形的集合里的。</p>
<p>于是，我们只要枚举每个悬线，<script type="math/tex">O(1)</script>地算出每个极大子矩形的面积，然后取一个<script type="math/tex">max</script>就行了。</p>
<p>考虑每一个点和每一条悬线一一对应，且一共有<script type="math/tex">n*m</script>个点，所以复杂度就是<script type="math/tex">O(nm)</script>。</p>
<p>那么，问题就转化为如何<script type="math/tex">O(1)</script>地算出每个极大子矩形的面积。</p>
<p>举个例子，我们假设我们要求矩形里都是相同的数。</p>
<p>我们考虑递推，设<script type="math/tex">H[i][j]</script>表示<script type="math/tex">(i,j)</script>的悬线长度。</p>
<p>则有</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a[i][j] == a[i - <span class="number">1</span>][j]) H[i][j] = H[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> H[i][j] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>然后我们再考虑左右边界，记为<script type="math/tex">L[i][j],R[i][j]</script>，这也是可以递推的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a[i][j] == a[i - <span class="number">1</span>][j]) </span><br><span class="line">    L[i][j] = <span class="built_in">max</span>(L[i - <span class="number">1</span>][j], Lx[i][j]), R[i][j] = <span class="built_in">min</span>(R[i - <span class="number">1</span>][j], Rx[i][j])</span><br><span class="line"><span class="comment">//Lx, Rx表示在这一行中(i,j)能达到最左边和最右边的位置</span></span><br></pre></td></tr></table></figure>
<p>当然，意思是这个意思，实现起来会有一些不一样的地方。</p>
<p>最后，我们枚举每个点，统计一下答案就好了。</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.luogu.org/problem/P1169">棋盘制作</a></p>
<p>模板题了吧！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">2000</span> + <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxN + <span class="number">1</span>][maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> H[maxN + <span class="number">1</span>][maxN + <span class="number">1</span>], L[maxN + <span class="number">1</span>][maxN + <span class="number">1</span>], R[maxN + <span class="number">1</span>][maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> ans1, ans2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>( !<span class="built_in">isdigit</span>( ch ) ) &#123; <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">isdigit</span>( ch ) ) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> num * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) a[i][j] = <span class="built_in">read</span>(), L[i][j] = R[i][j] = j, H[i][j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= m; j++)</span><br><span class="line">           L[i][j] = a[i][j] == a[i][j - <span class="number">1</span>] ? j : L[i][j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">1</span>; j--)</span><br><span class="line">           R[i][j] = a[i][j] == a[i][j + <span class="number">1</span>] ? j : R[i][j + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">          <span class="keyword">if</span>(i &gt; <span class="number">1</span> &amp;&amp; a[i][j] != a[i - <span class="number">1</span>][j])</span><br><span class="line">             H[i][j] = H[i - <span class="number">1</span>][j] + <span class="number">1</span>, </span><br><span class="line">             L[i][j] = <span class="built_in">max</span>(L[i][j], L[i - <span class="number">1</span>][j]), R[i][j] = <span class="built_in">min</span>(R[i][j], R[i - <span class="number">1</span>][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> a = H[i][j], b = R[i][j] - L[i][j] + <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">if</span>(a &gt; b) <span class="built_in">swap</span>(a, b);</span><br><span class="line">           ans1 = <span class="built_in">max</span>(ans1, a * a);</span><br><span class="line">           ans2 = <span class="built_in">max</span>(ans2, a * b);</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%d&quot;</span>, ans1, ans2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈快速沃尔什变换FWT</title>
    <url>/2019/07/06/%E6%B5%85%E8%B0%88%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2FWT/</url>
    <content><![CDATA[<h1 id="快速沃尔什变换"><a href="#快速沃尔什变换" class="headerlink" title="快速沃尔什变换"></a>快速沃尔什变换</h1><p>其实<script type="math/tex">FWT</script>与<script type="math/tex">FFT</script>类似，只不过是进行集合卷积的计算，如：</p>
<script type="math/tex; mode=display">
C_k=\sum_{i\oplus j = k} A_i*B_j\\
其中\oplus是位运算,可以是与,或,异或等</script><span id="more"></span>
<p>之前看到一个形象的比喻，所谓这些变换，就是相当于你要过一条马路，但是直接过不好走，那么我们要上一个天桥（正变换），然后从天桥上走过去，最后再走下来（逆变换）。</p>
<h1 id="或-or-运算的FWT"><a href="#或-or-运算的FWT" class="headerlink" title="或(or)运算的FWT"></a>或(or)运算的FWT</h1><p>我们考虑或的<script type="math/tex">FWT</script>，如果我们有一个集合<script type="math/tex">A_i</script>，设<script type="math/tex">FWT(A)=A'</script>那么<script type="math/tex">A'_i</script>的意义就是这个集合所有子集的贡献之和。</p>
<script type="math/tex; mode=display">
A'_i=\sum_{i|j=i}A_j</script><p>这样，因为<script type="math/tex">k|(i|j)=k</script>可以推出<script type="math/tex">k|i=k,k|j=k</script>我们可以得到一个结论：</p>
<script type="math/tex; mode=display">
C'_k=\sum_{k|t=k}C_t=\sum_{k|t=k}\sum_{i|j=t}A_i*B_j=\sum_{k|(i|j)=k}A_i*B_j\\
=(\sum_{k|i=k}A_i)*(\sum_{k|j=k}B_j)=A'_k*B'_k</script><p>这样我们来看<script type="math/tex">A'</script>是怎么求的。</p>
<p>我们考虑吧<script type="math/tex">A</script>长度补为<script type="math/tex">2^k</script>，分为两半，<script type="math/tex">A0</script>是前面一半，表示第一位是0，<script type="math/tex">A1</script>是后面一半，表示第一位是1。</p>
<p>然后，我们也把<script type="math/tex">A'</script>分为两半来考虑，前面一半是第一位是0，那么它的子集就是<script type="math/tex">A0'</script>（它本身），后面一半第一位是1，它的子集既有<script type="math/tex">A1'</script>(它本身)，还有<script type="math/tex">A0’</script>。</p>
<p>所以</p>
<script type="math/tex; mode=display">
A'=merge(A0',A0'+A1')\\
即FWT(A)=merge(FWT(A_0),FWT(A_0)+FWT(A_1))</script><p>其中，<script type="math/tex">merge</script>就是将两个数组拼接在一起，<script type="math/tex">+</script>表示对应下标的数相加。</p>
<p>这样我们就能在<script type="math/tex">O(nlogn)</script>的复杂度内求出了<script type="math/tex">FWT(A)</script>。</p>
<p>这样，我们就可以算出<script type="math/tex">FWT(C)</script>，那么，我们怎么把<script type="math/tex">FWT(C)</script>转回来呢？</p>
<script type="math/tex; mode=display">
FWT(A)_0:FWT(A)的前半部分,FWT(A_0):A的前半部分的FWT\\
\because FWT(A)_0=FWT(A_0)\\
\therefore A_0 = IFWT(FWT(A_0))=IFWT(FWT(A)_0)\\
\because FWT(A)_1=FWT(A_0)+FWT(A_1)\\
\therefore A_1=IFWT(FWT(A_1))=IFWT(FWT(A)_1-FWT(A)_0)</script><p>实际上，写那么多式子令人烦躁，考虑因为是<script type="math/tex">or</script>运算，所以递归每一位的时候，只有当前这一位是<script type="math/tex">0</script>的对后面相对应的这一位是<script type="math/tex">1</script>的产生贡献，然后逆变换就是反过来。</p>
<p>但是这个时候就会有个疑惑，正变换是先处理左右两边再算贡献，那么逆变换要把过程反过来，不应该先算贡献再递归左右两边吗，为什么还是一个函数？</p>
<p>实际上，因为考虑正变换时每一位的顺序是无所谓的，我们按位正着算和倒着算是等价的。</p>
<p>所以我们逆变换便假设正变换是倒着枚举每一位来计算的，那么先递归左右两边再计算贡献就是合理的了，这个要仔细思考。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><script type="math/tex; mode=display">
FWT(A)=
\begin{cases}
(FWT(A_0),FWT(A_0+A_1))\quad(n\neq 1)\\
A\quad(n=1)
\end{cases}</script><p>下面写<script type="math/tex">IFWT</script>，注意，此时大括号后面的<script type="math/tex">A</script>是已经<script type="math/tex">FWT</script>过后的<script type="math/tex">A</script></p>
<script type="math/tex; mode=display">
IFWT(A)=
\begin{cases}
(IFWT(A_0),IFWT(A_1-A_0))\quad(n \neq 1)\\
A\quad(n = 1)
\end{cases}</script><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FWT</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i += (mid &lt;&lt; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; j++)</span><br><span class="line">                a[i + mid + j] += a[i + j] * type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="与-and-运算的FWT"><a href="#与-and-运算的FWT" class="headerlink" title="与(and)运算的FWT"></a>与(and)运算的FWT</h1><p>证明太麻烦了，直接上结论吧，这个和上面或的差不多，与的话就是正好反过来，让这一位是<script type="math/tex">1</script>的对这一位是<script type="math/tex">0</script>的进行贡献。</p>
<h2 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h2><script type="math/tex; mode=display">
FWT(A)=
\begin{cases}
(FWT(A_0+A_1),FWT(A_1))\quad(n\neq 1)\\
A\quad (n=1)
\end{cases}\\
IFWT(A)=
\begin{cases}
(IFWT(A_0-A_1),IFWT(A_1))\quad (n\neq 1)\\
A\quad(n=1)
\end{cases}</script><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FWT</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i += (mid &lt;&lt; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; j++)</span><br><span class="line">                a[i + j] += a[i + mid + j] * type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="异或-xor-运算的FWT"><a href="#异或-xor-运算的FWT" class="headerlink" title="异或(xor)运算的FWT"></a>异或(xor)运算的FWT</h1><p>这个比较难。</p>
<p>与前面一样的想法，我们考虑构造一个序列，但这个序列比较奇怪。</p>
<p>我们定义<script type="math/tex">x\otimes y</script>为<script type="math/tex">x\& y</script>之后的位数的奇偶性（奇数为<script type="math/tex">1</script>，偶数为<script type="math/tex">0</script>）。</p>
<p>这个运算满足<script type="math/tex">(i\otimes j)\oplus (i\otimes k)=i\otimes (j\oplus k)</script>（有点像乘法分配律），可以用来进行异或卷积。</p>
<p>我们构造</p>
<script type="math/tex; mode=display">
A_n=\sum_{n\otimes i=0}a_i-\sum_{n\otimes i=1}a_i</script><p>这个看起来很奇怪，但是</p>
<script type="math/tex; mode=display">
C_n=\sum_{n\otimes k=0}c_k-\sum_{n\otimes k=1}c_k\\
=\sum_{n\otimes k=0}\sum_{i\oplus j=k}a_ib_j-\sum_{n\otimes k=1}\sum_{i\oplus j=k}a_ib_j\\
=\sum_{n\otimes (i\oplus j)=0}a_ib_j-\sum_{n\otimes (i\oplus j)=1}a_ib_j\\
=(\sum_{n\otimes i=0}a_i)*(\sum_{n\otimes j=0}b_j)+(\sum_{n\otimes i=1}a_i)*(\sum_{n\otimes j=1}b_j)\\-(\sum_{n\otimes i=0}a_i)*(\sum_{n\otimes j=1}b_j)-(\sum_{n\otimes i=1}a_i)*(\sum_{n\otimes j=0}b_j)\\
=(\sum_{n\otimes i=0}a_i-\sum_{n\otimes i=1}a_j)*(\sum_{n\otimes i=0}a_i-\sum_{n\otimes i=1}a_j)\\
=A_n*B_n</script><p>那么，这个怎么<script type="math/tex">FWT</script>呢？</p>
<p>正变换，依然考虑分治，分为<script type="math/tex">A_0</script>，<script type="math/tex">A_1</script>，表示当前这一位（<script type="math/tex">i</script>）是<script type="math/tex">0/1</script>，这个时候，我们考虑<script type="math/tex">j</script>和<script type="math/tex">j+2^i</script>，（<script type="math/tex">j</script>的第<script type="math/tex">i</script>位为<script type="math/tex">0</script>），我们设<script type="math/tex">[i,j]</script>表示<script type="math/tex">i</script>这一层<script type="math/tex">j</script>的值，那么有如下几种转移（考虑位数中<script type="math/tex">1</script>的变化）：</p>
<p>第一，<script type="math/tex">[i-1,j]->[i,j]</script>位数增加的为<script type="math/tex">0\& 0=0</script>，所以贡献为<script type="math/tex">+1</script>。</p>
<p>第二，<script type="math/tex">[i-1,j+2^i]->[i,j]</script>增加的为<script type="math/tex">1\& 0=0</script>，贡献也为<script type="math/tex">+1</script>。</p>
<p>第三，<script type="math/tex">[i-1,j]->[i,j+2^i]</script>增加的为<script type="math/tex">0\& 1=0</script>，贡献是<script type="math/tex">+1</script>。</p>
<p>第四，<script type="math/tex">[i-1,j+2^i]->[i,j+2^i]</script>增加的为<script type="math/tex">1\& 1=1</script>，位数中<script type="math/tex">1</script>奇偶性发生变化，符号取反，贡献为<script type="math/tex">-1</script>。</p>
<p>因此，就有</p>
<script type="math/tex; mode=display">
A=merge(A_0+A_1,A_0-A_1)</script><p>那么逆变换也就很简单了，</p>
<script type="math/tex; mode=display">
c=merge(\frac{c_0+c_1}{2},\frac{c_0-c_1}{2})</script><h2 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h2><script type="math/tex; mode=display">
FWT(A)=
\begin{cases}
(FWT(A_0)+FWT(A_1),FWT(A_0)-FWT(A_1))\quad (n \neq 1)\\
A\quad (n = 1)
\end{cases}\\
IFWT(A)=
\begin{cases}
(\frac{IFWT(A_0)+IFWT(A_1)}{2},\frac{IFWT(A_0)-IFWT(A_1)}{2})\quad(n\neq 1)\\
A\quad(n=1)
\end{cases}</script><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FWT</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i += (mid &lt;&lt; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x = a[i + j], y = a[i + mid + j];</span><br><span class="line">                a[i + j] = x + y;</span><br><span class="line">                a[i + mid + j] = x - y;</span><br><span class="line">                <span class="keyword">if</span>(type == <span class="number">-1</span>) a[i + j] /= <span class="number">2</span>, a[i + mid + j] /= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="子集卷积"><a href="#子集卷积" class="headerlink" title="子集卷积"></a>子集卷积</h1><p>在一些题目中，有的时候要求</p>
<script type="math/tex; mode=display">
c[S]=\sum_{T\subset S}a[T]*b[S\oplus T]</script><p>这个时候应该怎么办呢？</p>
<p>我们考虑如果<script type="math/tex">i,j</script>满足<script type="math/tex">j=k\oplus i</script>的话，当且仅当<script type="math/tex">i|j=k, |i|+|j|=|k|</script>，那么我们就是要求</p>
<script type="math/tex; mode=display">
c[k]=\sum_{i|j=k}[|i|+|j|=|k|]*a[i]*b[j]</script><p>那么，我们多记一维，设<script type="math/tex">a[t][k]</script>表示<script type="math/tex">k</script>中有<script type="math/tex">t</script>个<script type="math/tex">1</script>。</p>
<p>每次就是要</p>
<script type="math/tex; mode=display">
c[s+t][i|j]+=a[s][i]*b[t][j]</script><p>最后只要统计所有<script type="math/tex">c[s][i]</script>（<script type="math/tex">i</script>的位数为<script type="math/tex">s</script>）作为<script type="math/tex">ans[i]</script>的答案即可。</p>
<p>那么，我们应该怎么算这个东西呢？</p>
<p>我们把第二维都正向地<script type="math/tex">FWT</script>一下，然后枚举位数，暴力卷积（可以证明这是对的），具体见代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; i++) <span class="built_in">FWTOR</span>(C[i], <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; i++)<span class="comment">//枚举位数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(D, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(D));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; <span class="number">20</span>); s++)</span><br><span class="line">                D[s] = <span class="built_in">ADD</span>(D[s], <span class="number">1ll</span> * C[j][s] * C[i - j][s] % mod);</span><br><span class="line">        <span class="built_in">FWTOR</span>(D, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; <span class="number">20</span>); s++)</span><br><span class="line">            <span class="keyword">if</span>(bc[s] == i) ans[s] = <span class="built_in">ADD</span>(ans[s], D[s]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>多项式</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈数论相关</title>
    <url>/2019/02/20/%E6%B5%85%E8%B0%88%E6%95%B0%E8%AE%BA%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="数论函数"><a href="#数论函数" class="headerlink" title="数论函数"></a>数论函数</h1><p>数论中有很多常用函数，这些函数是我们做题目的基石，也是科学家们智慧的结晶。。。</p>
<span id="more"></span>
<h2 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h2><p>积性函数指如果有一个函数<script type="math/tex">f</script>,若<script type="math/tex">n=pq</script>,且p,q互质，则有<script type="math/tex">f(n)=f(p)f(q)</script></p>
<p>还有一种特殊情况，成为<strong>完全积性函数</strong>，就是去掉p,q互质这个条件，即对于任意的p,q只要满足<script type="math/tex">pq=n</script>都有<script type="math/tex">f(n)=f(p)f(q)</script></p>
<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p>欧拉函数为<script type="math/tex">\phi(n)</script>，它指的是1~n-1中与n互质的数的个数。</p>
<p>其计算方法如下：</p>
<script type="math/tex; mode=display">
若n=p1^{a1}*p2^{a2}*...*pn^{an}\\
则有\phi(n)=n*(1-\frac{1}{p1})*(1-\frac{1}{p2})...(1-\frac{1}{pn})</script><p>线性筛欧拉函数的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxN;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag[i]) prime[++tot]=i,phi[i]=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot&amp;&amp;i*prime[j]&lt;=maxN;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            flag[prime[j]*i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]) phi[prime[j]*i]=phi[i]*phi[prime[j]]%mod;<span class="comment">//i,prime[j]互质积性函数直接乘 </span></span><br><span class="line">            <span class="keyword">else</span> &#123;phi[prime[j]*i]=phi[i]*prime[j]%mod; <span class="keyword">break</span>;&#125;<span class="comment">//i是prime[j]的倍数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h2><p>莫比乌斯函数为<script type="math/tex">\mu(n)</script>，具体为什么要定义它，其实它并没有什么定义，只是因为其有一些好的性质，所以要定义它，具体地，它分为几种情况：</p>
<script type="math/tex; mode=display">
\mu(1)=1\\
当n存在平方因子时（就是质因子分解后某一个质数的指数大于1），\mu(n)=0\\
当n时奇数个不同素数之积时，\mu(n)=-1\\
当n有偶数个不同素数之积时，\mu(n)=1</script><p>所有的一切，都是因为它有这么一个式子：</p>
<script type="math/tex; mode=display">
\sum_{d|n}\mu(d)=[n=1]</script><p>证明？我也不会，但这就是莫比乌斯反演的核心，所谓莫比乌斯反演，就是反复利用这个式子，从而得到我们想要的式子。</p>
<p>线性筛莫比乌斯函数的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxN;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag[i]) prime[++tot]=i,mu[i]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot&amp;&amp;i*prime[j]&lt;=maxN;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            flag[prime[j]*i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]) mu[prime[j]*i]=-mu[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h2><p>这些数论函数看起来非常无聊，甚至觉得有些多余，但在实际运用中，却是非常有用的。</p>
<script type="math/tex; mode=display">
1(n):每一个位置上都是1\\
e(n):除了第一个位置是1外，其他都是0\\
id(n):就是n,即id(n)=n</script><p>有什么用呢？看了后面的式子，你就知道了。</p>
<h1 id="狄利克雷卷积"><a href="#狄利克雷卷积" class="headerlink" title="狄利克雷卷积"></a>狄利克雷卷积</h1><p>狄利克雷卷积与普通的卷积不太一样，具体地，</p>
<script type="math/tex; mode=display">
f,g为两个函数，则有：
(f*g)(n)=\sum_{d|n}f(d)*g(\frac{n}{d})\\
就是(f*g)这个卷积过后的函数的第n项，f(i),g(j)对其有贡献当且仅当i*j=n</script><h1 id="重要公式"><a href="#重要公式" class="headerlink" title="重要公式"></a>重要公式</h1><p>跟<script type="math/tex">\phi,\mu</script>有关的公式如下（函数的*号表示狄利克雷卷积）：</p>
<script type="math/tex; mode=display">
\sum_{d|n}\mu(d)=[n=1]（莫比乌斯反演的根本）\\
\sum_{d|n}\phi(d)=n\\
1*\mu=e\\
1*\phi=id\\
\mu*id=\phi\\
(f*g)(n)=\sum_{d|n}f(d)*g(\frac{n}{d})\\</script><p>还有一些常用公式：</p>
<script type="math/tex; mode=display">
1^3+2^3+...+n^3=(1+2+3+...+n)^2\\
1^2+2^2+...+n^2=\frac{n(n+1)(2n+1)}{6}</script><h1 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h1><p>杜教筛是解决一类函数求和问题的方法，主要包括<script type="math/tex">\sum \mu</script>和<script type="math/tex">\sum \phi</script>等问题。</p>
<h2 id="sum-mu"><a href="#sum-mu" class="headerlink" title="\sum \mu"></a><script type="math/tex">\sum \mu</script></h2><p>由上述公式可得</p>
<script type="math/tex; mode=display">
1*\mu=e</script><p>因此，我们考虑计算</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n(1*\mu)(i)</script><p>我们设一个函数的大写字母为其1~n的函数值之和。</p>
<p>则显然</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n(1*\mu)(i)=\sum_{i=1}^ne(i)=E(n)</script><p>另一方面，根据狄利克雷卷积的定义：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n(1*\mu)(i)=\sum_{i=1}^n1(i)*\sum_{j=1}^{\lfloor \frac{n}{i}\rfloor}\mu(j)\\
我们设F(n)=\sum_{i=1}^n\mu(i)\\
又1(i)=1,所以原式=\sum_{i=1}^nF(\frac{n}{i})</script><p>综上，我们得知</p>
<script type="math/tex; mode=display">
E(n)=\sum_{i=1}^nF(\frac{n}{i})\\
由e的定义可知,E(n)=1,而我们要求的是F(n)\\
我们将i=1的情况提出来，其他的再移项\\
则F(n)=1-\sum_{i=2}^nF(\frac{n}{i})</script><p>这样，不断递归下去并整除分块，就可以了。</p>
<p>但是，根据计算，如果我们预处理出<script type="math/tex">1->n^{\frac{2}{3}}</script>的F值，那么时间复杂度就是<script type="math/tex">O(n^{\frac{2}{3}})</script></p>
<h2 id="sum-phi"><a href="#sum-phi" class="headerlink" title="\sum \phi"></a><script type="math/tex">\sum \phi</script></h2><p>与上面类似，我就直接写了</p>
<script type="math/tex; mode=display">
由上述公式得:1*\phi=id\\
因此\sum_{i=1}^n(1*\phi)(i)=\sum_{i=1}^nid(i)=\frac{n(n+1)}{2}\\
而\sum_{i=1}^n(1*\phi)(i)=\sum_{i=1}^n1(i)*\sum_{j=1}^{n/i}\phi(j)\\
设F(n)=\sum_{i=1}^n\phi(i)\\
则\sum_{i=1}^n(1*\phi)(i)=\sum_{i=1}^nF(n/i)\\
则\frac{n(n+1)}{2}=\sum_{i=1}^nF(n/i)\\
F(n)=\frac{n(n+1)}{2}-\sum_{i=2}^nF(n/i)</script><p>一样的，直接预处理+整除分块就好了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们对于一个形似<script type="math/tex">\sum_{i=1}^nf(i)</script>的结构，如果我们找到<script type="math/tex">f*g=h</script>，且<script type="math/tex">H</script>比较好算，<script type="math/tex">g</script>也比较正常的时候，就可以用上面的办法，一步一步推下来，用杜教筛完成。</p>
<h2 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h2><p>还有一些其他情况，例如，求</p>
<script type="math/tex; mode=display">
\sum_{i=1}^ni*\mu(i)</script><p>这个时候，我们不妨设</p>
<script type="math/tex; mode=display">
f(n)=n*\mu(n)\\
g(n)=n(其实就是id)</script><p>这样，我们可以得到</p>
<script type="math/tex; mode=display">
(f*g)(n)=\sum_{d|n}f(d)*g(\frac{n}{d})=\sum_{d|n}d*\mu(d)*\frac{n}{d}=n*\sum_{d|n}\mu(d)</script><p>我们发现，</p>
<script type="math/tex; mode=display">
\sum_{d|n}\mu(d)=[n=1]\\
同样，n*\sum_{d|n}\mu(d)=[n=1]=e</script><p>由此，我们可以知道：</p>
<script type="math/tex; mode=display">
f*g=e\\
\sum_{i=1}^n(f*g)(i)=\sum_{i=1}^ne(i)=1\\
\sum_{i=1}^n(f*g)(i)=\sum_{i=1}^ng(i)*\sum_{j=1}^{n/i}f(j)=\sum_{i=1}^ni*F(n/i)\\
即\sum_{i=1}^ni*F(n/i)=1\\
F(n)=1-\sum_{i=2}^ni*F(n/i)</script><p>这样，就和从前一样了，直接整除分块就好了。</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>杜教筛也是有模板的。。。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=maxN) <span class="keyword">return</span> sum[n];<span class="comment">//预处理的值</span></span><br><span class="line">    <span class="keyword">if</span>(f.<span class="built_in">count</span>(n)) <span class="keyword">return</span> f[n];<span class="comment">//记忆化</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">2</span>,ans=...;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=n/i,k=n/j;</span><br><span class="line">        ans=...;</span><br><span class="line">        i=k+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n]=ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好像，好像就没什么了。。。</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>1.<a href="https://cmwqf.github.io/2019/02/21/%E7%AE%80%E5%8D%95%E6%95%B0%E5%AD%A6%E9%A2%98/#more">简单数学题</a></p>
<p>2.<a href="https://cmwqf.github.io/2019/02/21/%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C/#more">约数个数和</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈斯特林反演</title>
    <url>/2020/05/06/%E6%B5%85%E8%B0%88%E6%96%AF%E7%89%B9%E6%9E%97%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<h1 id="斯特林反演"><a href="#斯特林反演" class="headerlink" title="斯特林反演"></a>斯特林反演</h1><p>定义第一类斯特林数符号为<script type="math/tex">{n\brack i}</script>，第二类斯特林数为<script type="math/tex">{n\brace i}</script>。</p>
<p>当我们遇到一类计数问题时，往往可以用到斯特林反演。</p>
<p>即如果我们有</p>
<script type="math/tex; mode=display">
f[n]=\sum_{i=0}^n{n \brace i}g[i]</script><p>那么我们可以通过斯特林反演，根据<script type="math/tex">f</script>还原出<script type="math/tex">g</script>。</p>
<p>下面，我们就来认识一下斯特林反演。</p>
<span id="more"></span>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>我们首先定义<script type="math/tex">x</script>的上升幂<script type="math/tex">x^{\overline{n}}=x(x+1)...(x+n-1)</script>，下降幂<script type="math/tex">x^{\underline{n}}=x(x-1)...(x-n+1)</script>。</p>
<p>那么根据第二类斯特林数的性质（组合意义），我们有</p>
<script type="math/tex; mode=display">
x^n=\sum_{i=0}^n{n\brace i}x^{\underline{i}}\tag{1}</script><p>另外，关于第一类斯特林数，我们有</p>
<script type="math/tex; mode=display">
x^{\overline{n}}=\sum_{i=0}^n{n\brack i}x^i\tag{2}</script><p>这是为什么呢？我们考虑<script type="math/tex">dp</script>出<script type="math/tex">x^{\overline{n}}</script>的<script type="math/tex">x^i</script>项系数。</p>
<p>设<script type="math/tex">f(n,i)</script>表示<script type="math/tex">x^{\overline{n}}</script>中<script type="math/tex">x^i</script>项系数，那么我们考虑从<script type="math/tex">x^{\overline{n-1}}</script>转移，乘<script type="math/tex">(x+n-1)</script>，那么我们有</p>
<script type="math/tex; mode=display">
f(n,i)=f(n-1,i-1)+(n-1)*f(n-1,i)</script><p>这个转移式恰好和第一类斯特林数的转移式是一模一样的。</p>
<p>那么，我们就可以用<script type="math/tex">x^i</script>把<script type="math/tex">x^{\overline{n}}</script>和<script type="math/tex">x^{\underline{n}}</script>联系起来了。</p>
<p>另外，实际上两者在定义上还有一种联系：</p>
<script type="math/tex; mode=display">
(-x)^{\underline{n}}=(-1)^nx^{\overline{n}}\tag{3}</script><p>对称地，还有</p>
<script type="math/tex; mode=display">
(-x)^{\overline{n}}=(-1)^nx^{\underline{n}}\tag{4}</script><p>这个根据定义展开就能得证。</p>
<p>有了这几个式子，我们就能进行斯特林反演了。</p>
<p>我们将<script type="math/tex">(1)</script>用<script type="math/tex">-x</script>代换<script type="math/tex">x</script>，那么</p>
<script type="math/tex; mode=display">
(-x)^n=\sum_{i=0}^n{n\brace i}(-x)^{\underline{i}}\\
(-1)^nx^n=\sum_{i=0}^n{n\brace i}(-1)^ix^{\overline{i}}\\
x^n=\sum_{i=0}^n{n\brace i}(-1)^{n-i}\sum_{j=0}^i{i\brack j}x^j\\
x^n=\sum_{j=0}^nx^j\sum_{i=j}^n(-1)^{n-i}{n\brace i}{i\brack j}</script><p>通过比较系数，我们有</p>
<script type="math/tex; mode=display">
\sum_{i=m}^n(-1)^{n-i}{n\brace i}{i\brack j}=[n=m]\tag{A}</script><p>我们在<script type="math/tex">(2)</script>中用<script type="math/tex">-x</script>代换<script type="math/tex">x</script>，那么</p>
<script type="math/tex; mode=display">
(-x)^{\overline{n}}=\sum_{i=0}^n{n\brack i}(-1)^ix^i\\
(-x)^{\overline{n}}=\sum_{i=0}^n{n\brack i}(-1)^i\sum_{j=0}^i{i \brace j}x^{\underline{j}}\\
(-1)^nx^{\underline{n}}=\sum_{j=0}^nx^{\underline{j}}\sum_{i=j}^n(-1)^i{n\brack i}{i\brace j}\\
x^{\underline{n}}=\sum_{j=0}^nx^{\underline{j}}\sum_{i=j}^n(-1)^{n-i}{n\brack i}{i\brace j}</script><p>同样地，比较系数，我们有</p>
<script type="math/tex; mode=display">
\sum_{i=m}^n(-1)^{n-i}{n\brack i}{i\brace j}=[n=m]\tag B</script><p>综上所述，我们有两个非常对称的式子</p>
<script type="math/tex; mode=display">
\sum_{i=m}^n(-1)^{n-i}{n\brace i}{i\brack m}=[n=m]\\
\sum_{i=m}^n(-1)^{n-i}{n\brack i}{i\brace m}=[n=m]</script><h1 id="第一个形式"><a href="#第一个形式" class="headerlink" title="第一个形式"></a>第一个形式</h1><p>有了上面两个式子，我们就可以推导出斯特林反演的公式了。</p>
<p>如果我们有</p>
<script type="math/tex; mode=display">
f[n]=\sum_{i=0}^n{n\brace i}g[i]</script><p>那么</p>
<script type="math/tex; mode=display">
g[n]=\sum_{i=0}^ng[i][i=n]\\
=\sum_{i=0}^ng[i]\sum_{j=i}^n(-1)^{n-j}{n\brack j}{j\brace i}\\
=\sum_{j=0}^n(-1)^{n-j}{n\brack j}\sum_{i=0}^j{j\brace i}g[i]\\
=\sum_{i=0}^n(-1)^{n-i}{n\brack i}f[i]</script><p>即</p>
<script type="math/tex; mode=display">
g[n]=\sum_{i=0}^n(-1)^{n-i}{n\brack i}f[i]\tag{1}</script><p>同样地，如果我们有</p>
<script type="math/tex; mode=display">
f[n]=\sum_{i=0}^n{n\brack i}g[i]</script><p>那么同理也有</p>
<script type="math/tex; mode=display">
g[n]=\sum_{i=0}^n(-1)^{n-i}{n\brace i}f[i]\tag{2}</script><p>只不过下面这个几乎不怎么用罢了。</p>
<p>注意到我们的推导中并没有用到<script type="math/tex">i</script>从<script type="math/tex">0</script>开始的条件，所以<script type="math/tex">i</script>从<script type="math/tex">m</script>（<script type="math/tex">m\le n</script>）开始都可以使用此式。</p>
<h1 id="第二个形式"><a href="#第二个形式" class="headerlink" title="第二个形式"></a>第二个形式</h1><p>实际上，有的时候，我们还会遇到</p>
<script type="math/tex; mode=display">
f[m]=\sum_{i=m}^n{i\brace m}g[i]</script><p>那么此时，我们有</p>
<script type="math/tex; mode=display">
g[m]=\sum_{i=m}^n(-1)^{i-m}{i\brack m}f[i]</script><p>证明过程考虑把后面的式子带入前面的式子</p>
<script type="math/tex; mode=display">
f[m]=\sum_{i=m}^n{i\brace m}\sum_{j=i}^n(-1)^{j-i}{j\brack i}f[j]\\
=\sum_{j=m}^nf[j]\sum_{i=m}^j(-1)^{j-i}{i\brace m}{j\brack i}\\
=\sum_{j=m}^nf[j][j=m]\\
=f[m]</script><p>故等式成立。</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>在<script type="math/tex">dp</script>连通图相关问题时，往往设<script type="math/tex">f(i,j)</script>为考虑了前<script type="math/tex">i</script>个点，分成<script type="math/tex">j</script>组，<strong>不同组之间不连边，同组之间边随便选</strong>的方案数。那么对于最后的<script type="math/tex">f(n,i)</script>，设将<script type="math/tex">n</script>个点连边后分成<script type="math/tex">j</script>个联通块的答案是<script type="math/tex">g(j)</script>，那么显然每个<script type="math/tex">g(j)</script>在答案中被算了<script type="math/tex">j\brace i</script>次（将<script type="math/tex">j</script>个联通块分为<script type="math/tex">i</script>组）。即<script type="math/tex">f[i]=\sum_{j=i}^n{j\brace i}g[j]</script>。</p>
<p>那么，我们直接用斯特林反演来求出<script type="math/tex">g</script>了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>综上，斯特林反演和二项式反演形式上有很大的相似性，只是系数不同而已。</p>
<p>实际上，这类反演都基于反演原理：</p>
<p>若有<script type="math/tex">f,g,u,v</script>满足以下关系</p>
<script type="math/tex; mode=display">
f[n]=\sum_{i=0}^nu[n][i]*g[i]</script><p>那么</p>
<script type="math/tex; mode=display">
g[n]=\sum_{i=0}^nv[n][i]*f[i]</script><p>这个式子成立当且仅当</p>
<script type="math/tex; mode=display">
\sum_{i=m}^nu[n][i]*v[i][m]=[n=m]</script><p>直接带入即证。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈李超线段树</title>
    <url>/2020/05/18/%E6%B5%85%E8%B0%88%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<h1 id="李超线段树"><a href="#李超线段树" class="headerlink" title="李超线段树"></a>李超线段树</h1><p>有的时候，我们会遇到这样一类问题。</p>
<p>有<script type="math/tex">n</script>个操作，每次操作有两种：</p>
<ol>
<li><p>插入一条线段<script type="math/tex">y=kx+b\quad(l\le x\le r)</script>。</p>
</li>
<li><p>查询<script type="math/tex">x=x_0</script>时最大的<script type="math/tex">y</script>是多少。</p>
</li>
</ol>
<p>这个时候，我们就需要用到李超线段树。</p>
<span id="more"></span>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>对于一类问题，有很多个候选答案，暴力方法是每次一个个<script type="math/tex">check</script>更新答案，但是这样复杂度太高。一个重要的优化思想就是减少候选答案的数量，把不可能成为最优解的候选项尽量剔除，使得复杂度达到可以接受的结果。李超线段树根本上用的就是这个思想。</p>
<p>考虑一个区间，如果某个线段在这个区间内被另外一个线段完全覆盖，那么这个线段在这个区间内就是无效的，因为它随时可以被另一线段来代替。</p>
<p>我们考虑对于<script type="math/tex">x</script>轴开一棵线段树，每个节点<script type="math/tex">[l,r]</script>记录所有完全包含<script type="math/tex">[l,r]</script>的线段中，<script type="math/tex">x=mid</script>时<script type="math/tex">y</script>最大的线段编号。</p>
<p>显然我们不可能每次加入一个线段就更新到底，那么我们采用标记持久化的方法来更新。</p>
<p>每次加入一条线段到这个节点（此时线段完全覆盖了<script type="math/tex">[l,r]</script>），步骤为：</p>
<ol>
<li><p>我们先看这个节点是否已经记录线段，如果否，则记录当前线段并返回。</p>
</li>
<li><p>看加入的线段如果覆盖当前节点的线段，更新当前节点线段并返回。</p>
</li>
<li><p>如果当前节点的线段覆盖加入线段，直接返回。</p>
</li>
<li><p>否则，我们看两个线段哪个是<script type="math/tex">mid</script>上的较大值，设为<script type="math/tex">l1</script>，另一个设为<script type="math/tex">l2</script>，那么我们将当前节点线段设为<script type="math/tex">l1</script>并递归<script type="math/tex">l2</script>。</p>
</li>
</ol>
<p>为什么最后一步只需递归一边呢？很显然，因为是一次函数，此时<script type="math/tex">l1</script>已经在一边完全覆盖了<script type="math/tex">l2</script>，所以<script type="math/tex">l2</script>在那一边没有存在的意义，所以只需递归更新另外一边。</p>
<p>复杂度分析很简单，每次更新会到定位到<script type="math/tex">\log n</script>个区间，然后最多会进行<script type="math/tex">\log n</script>次递归修改，因此修改复杂度为<script type="math/tex">O(n\log^2n)</script>。</p>
<p>每次查询的时候，我们只需从线段树根节点到<script type="math/tex">x_0</script>的叶子节点路径上遇到的所有节点记录的线段的<script type="math/tex">y</script>取<script type="math/tex">max</script>即可。</p>
<p>这样为什么是正确的呢？</p>
<p>因为最终的答案一定在从根节点到叶子节点的<script type="math/tex">\log n</script>个线段中产生。考虑插入的过程，如果一个线段没有被完全覆盖的话会继续递归更新下面的节点，而如果从根节点到叶子节点都没有出现这个线段，那么它一定因为被完全覆盖而丢弃了，所以不可能成为答案。</p>
<p>查询的复杂度自然是<script type="math/tex">O(n\log n)</script>。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>插入的时候，比较是否覆盖只要把区间<script type="math/tex">[l,r]</script>中<script type="math/tex">l,r</script>的坐标分别带入两个函数来比较即可。</p>
<p>判断中点坐标哪个更大时，实际上我们并不需要把中点坐标带入两个函数进行比较，我们只需要求出两个函数的交点横坐标，看它在中点的左侧<script type="math/tex">or</script>右侧即可。</p>
<p>另外，我们要写两个函数来插入，第一个函数是为了在线段树上定位区间，第二个则为了进行真正的插入操作（也可以写成一个，但是写成两个更清晰一点）。</p>
<p>注意如果题目要求离散化，我们应该比较的是交点<script type="math/tex">x</script>与<script type="math/tex">t[\frac{l+r}{2}]</script>，而不是<script type="math/tex">\frac{t[l]+t[r]}{2}</script>。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">double</span> k, b;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">&#125;tree[maxN * <span class="number">4</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> id, <span class="keyword">double</span> k, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[node] = (Segment)&#123;id, k, b, <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> id, <span class="keyword">double</span> k, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tree[node].flag) &#123; <span class="built_in">update</span>(node, id, k, b); <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> l1 = l * tree[node].k + tree[node].b, r1 = r * tree[node].k + tree[node].b;</span><br><span class="line">    <span class="keyword">double</span> l2 = l * k + b, r2 = r * k + b;</span><br><span class="line">    <span class="keyword">if</span>(l1 &gt;= l2 &amp;&amp; r1 &gt;= r2) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(l2 &gt;= l1 &amp;&amp; r2 &gt;= r1) &#123; <span class="built_in">update</span>(node, id, k, b); <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">double</span> x = (tree[node].b - b) / (k - tree[node].k);</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 &gt; l2) <span class="built_in">change</span>(ls, l, mid, tree[node].id, tree[node].k, tree[node].b), <span class="built_in">update</span>(node, id, k, b);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">change</span>(ls, l, mid, id, k, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(r1 &gt; r2) <span class="built_in">change</span>(rs, mid + <span class="number">1</span>, r, tree[node].id, tree[node].k, tree[node].b), <span class="built_in">update</span>(node, id, k, b);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">change</span>(rs, mid + <span class="number">1</span>, r, id, k, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> id, <span class="keyword">double</span> k, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= l &amp;&amp; r &lt;= y) &#123; <span class="built_in">change</span>(node, l, r, id, k, b); <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(ls, l, mid, x, y, id, k, b);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid) <span class="built_in">modify</span>(rs, mid + <span class="number">1</span>, r, x, y, id, k, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> tree[node].k * x + tree[node].b;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">double</span> ans = tree[node].k * x + tree[node].b;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) ans = <span class="built_in">max</span>(ans, <span class="built_in">query</span>(ls, l, mid, x));</span><br><span class="line">    <span class="keyword">else</span> ans = <span class="built_in">max</span>(ans, <span class="built_in">query</span>(rs, mid + <span class="number">1</span>, r, x));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>李超线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈竞赛图</title>
    <url>/2020/04/22/%E6%B5%85%E8%B0%88%E7%AB%9E%E8%B5%9B%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="竞赛图"><a href="#竞赛图" class="headerlink" title="竞赛图"></a>竞赛图</h1><p>定义：<script type="math/tex">n</script>个点的有向图，若满足<strong>任意两点都有且仅有一条有向边</strong>，就称此有向图为竞赛图。</p>
<p>为什么竞赛图要专门分析呢？因为竞赛图有很多非常有趣的性质。</p>
<span id="more"></span>
<h1 id="性质一"><a href="#性质一" class="headerlink" title="性质一"></a>性质一</h1><p>将竞赛图缩点之后，缩成的所有强连通分量按照出度从小到大排成的序列，一定满足第<script type="math/tex">i</script>个强连通分量与所有<script type="math/tex">j>i</script>的强连通分量<script type="math/tex">j</script>都有一条<script type="math/tex">i->j</script>的边。</p>
<p>证明：考虑归纳，我们加进来一个新的强连通分量，如果当前所有强连通分量都连向它，那么将它放在序列尾；如果它连向所有强连通分量，那么将它放在序列头；否则，所有它连向的强连通分量一定在连向它的强连通分量的后面（否则就有环，矛盾），那么将它放在对应的分界点处即可。</p>
<h1 id="性质二"><a href="#性质二" class="headerlink" title="性质二"></a>性质二</h1><p>竞赛图的所有强连通分量都存在一条哈密顿回路。</p>
<p>证明：考虑归纳，仍然考虑当前强连通分量构成的序列（即性质一所述的那个序列），目前所有强连通分量都满足存在一条哈密顿回路。现在我们加入一个点，如果它自己构成一个单独的强连通分量，那么将它直接加入序列（类似性质一）；否则，我们找到最左边的它连向的那个强连通分量<script type="math/tex">x</script>，再找到最右边的连向它的强连通分量<script type="math/tex">y</script>，那么所有<script type="math/tex">x,y</script>之间的及当前这个点构成了一个新的强连通分量，那么显然这个新强连通分量也存在一条哈密顿回路（考虑从当前点走到最左边强连通分量某个点开始每次先把其内部的点走一遍再走到下一个强连通分量的某个点，一直走到最右边强连通分量，然后走到当前点本身）。</p>
<h1 id="性质三"><a href="#性质三" class="headerlink" title="性质三"></a>性质三</h1><p>竞赛图存在一条<strong>哈密顿路径</strong>。</p>
<p>证明：因为每个强连通分量都有一条哈密顿回路，直接沿哈密顿回路走完每个强连通分量的所有点然后再走向下个强连通分量即可。</p>
<h1 id="性质四"><a href="#性质四" class="headerlink" title="性质四"></a>性质四</h1><p>竞赛图里，任意大小为<script type="math/tex">n>1</script>的强连通分量中，大小为<script type="math/tex">[3,n]</script>的环均存在。</p>
<p>证明：首先，<script type="math/tex">n=3</script>成立，那么<script type="math/tex">n\ge 4</script>时，我们只需证明存在大小为<script type="math/tex">n-1</script>的环（即存在大小为<script type="math/tex">n-1</script>的强强连通分量）即可。</p>
<p>考虑我们从强连通分量中提出一个点，如果剩下的只有一个强连通分量，那么大小为<script type="math/tex">n-1</script>的环已经出现。</p>
<p>否则，剩下的强连通分量一定构成一个性质一所述的序列，根据性质三，这个序列存在一条哈密顿路径，我们按照原来构造的路径上某个联通分量的最后一个点不走，直接跳到下一个联通分量，这样一条新的路径加上我们提出来的这个点，就构成了一个大小为<script type="math/tex">n-1</script>的环。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈最小表示法</title>
    <url>/2021/04/08/%E6%B5%85%E8%B0%88%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定一个字符串<script type="math/tex">s</script>，求它的一个循环表示（即每次只能把字符串的开头字符删掉并插入到结尾），使得其是该字符串所有循环表示中字典序最小的一个。</p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先，设原字符串的长度为<script type="math/tex">n</script>，然后我们将字符串倍长。</p>
<p>考虑我们有两个指针<script type="math/tex">i,j</script>表示候选位置，现在我们想比较这两个位置谁更优秀。</p>
<p>那么暴力就是我们枚举长度<script type="math/tex">k</script>，如果存在<script type="math/tex">s[i+k]>s[j+k]</script>就让<script type="math/tex">i++</script>，如果<script type="math/tex">s[i+k]<s[j+k]</script>就让<script type="math/tex">j++</script>，并且让<script type="math/tex">k=0</script>。如果相等就继续往后枚举，即<script type="math/tex">k++</script>。</p>
<p>特别地，如果某次移动后发现<script type="math/tex">i==j</script>，那么我们让<script type="math/tex">j++</script>。</p>
<p>如果<script type="math/tex">i</script>和<script type="math/tex">j</script>开头的字符串相等，即<script type="math/tex">k</script>一直枚举到了<script type="math/tex">n</script>，这说明该字符串可以看成由一个长度为<script type="math/tex">len=|j-i|</script>的字符串（假设为<script type="math/tex">t</script>）复制若干次形成（最后一块可能不是整块），换句话说，我们可以看成有一个无限的由<script type="math/tex">t</script>不断复制得到的字符串，那么原字符串就是在这个无限字符串中截取一个长度为<script type="math/tex">n</script>的字符串得来的。</p>
<p>那么，这说明了什么呢？这说明该字符串本质不同的循环同构串只有<script type="math/tex">len</script>种。根据我们的算法，我们发现<script type="math/tex">i<j</script>，那么说明本质不同的循环同构串只有以<script type="math/tex">i,i+1,\dots,j-1</script>为开头的<script type="math/tex">len</script>个。而既然已经枚举到了<script type="math/tex">j</script>，那么说明以<script type="math/tex">i</script>开头的字符串是<script type="math/tex">i,i+1,\dots,j-1</script>这<script type="math/tex">len</script>个字符串中最小的一个，因此它就是答案。</p>
<p>这样，最后的答案就是<script type="math/tex">i</script>。</p>
<p>然后我们发现这个暴力是可以优化的，因为如果<script type="math/tex">s[i+k]>s[j+k]</script>，那么<script type="math/tex">i+1\sim i+k</script>都不可能作为答案，因为对于<script type="math/tex">1\le p\le k</script>，考虑<script type="math/tex">i+p</script>开头的字符串，总有<script type="math/tex">j+p</script>开头的字符串比它优，因此我们可以直接让<script type="math/tex">i+=k+1</script>即可。</p>
<p>但是这样我们就不能保证<script type="math/tex">i<j</script>，因此最后的答案是<script type="math/tex">\min(i,j)</script>。</p>
<p>时间复杂度为<script type="math/tex">O(n)</script>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> s[maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>( !<span class="built_in">isdigit</span>( ch ) ) &#123; <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">isdigit</span>( ch ) ) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> num * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	s[i] = s[i + n] = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">2</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n &amp;&amp; j &lt;= n &amp;&amp; k &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i + k] == s[j + k]) k ++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i + k] &gt; s[j + k]) i += k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> j += k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i == j) j ++;</span><br><span class="line">            k = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">min</span>(i, j);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= x + n - <span class="number">1</span>; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, s[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈线性基相关</title>
    <url>/2020/02/18/%E6%B5%85%E8%B0%88%E7%BA%BF%E6%80%A7%E5%9F%BA%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h1><p>我们称一组数<script type="math/tex">\{a_1,a_2,...,a_n\}</script>互相异或而形成的所有数的集合称为这组数的异或空间<script type="math/tex">S</script>，那么，线性基就是<script type="math/tex">S</script>中最小的一个子集<script type="math/tex">T</script>，使得<script type="math/tex">T</script>中元素互相异或形成的所有数的集合也是<script type="math/tex">S</script>。</p>
<p>若集合中所有的<script type="math/tex">a_i \in [1, 2^m-1]</script>，我们构造出<script type="math/tex">m</script>个线性基</p>
<script type="math/tex; mode=display">
p_0,p_2,...,p_{m-1}</script><p>对于任意<script type="math/tex">i</script>满足<script type="math/tex">p_i</script>在二进制下的最高位为<script type="math/tex">i</script>。</p>
<p>线性基的好处，在于它能用<script type="math/tex">log_2(maxv)</script>的时间和空间内完成原来集合<strong>子集异或有关的问题</strong>。</p>
<span id="more"></span>
<h1 id="线性相关与线性无关"><a href="#线性相关与线性无关" class="headerlink" title="线性相关与线性无关"></a>线性相关与线性无关</h1><p>首先，我们要了解什么是线性变换，对于向量来说，线性变换有两种</p>
<script type="math/tex; mode=display">
1. v_1+v_2\\
2. k*v_1(k是标量)</script><p>对于一个向量的集合<script type="math/tex">\{v_1,v_2,...v_n\}</script>来说，如果存在一个<script type="math/tex">v_i</script>，使得它能被这个集合中的一些向量通过线性变换得到，那么我们称这一组向量是<strong>线性相关</strong>的，反之，则称这一组向量为<strong>线性无关</strong>的。</p>
<p>那么，线性基与这个有什么关系呢？</p>
<p>我们假设我们的原集合都是在<script type="math/tex">[1,2^m-1]</script>的一些数，那么，我们可以将每个数看成一个<script type="math/tex">m</script>维向量，每一维是<script type="math/tex">0/1</script>。</p>
<p>线性基定义在异或中，其中的<strong>线性变换</strong>指的就是<strong>异或</strong>，那么，由于它是能表示出异或空间最小的一个子集，所以线性基中所有元素是<strong>线性无关</strong>的。</p>
<p>这，就说明了线性基的一个性质：</p>
<p><strong>线性基任意元素异或起来不等于0。</strong></p>
<p>理由很显然，假设<script type="math/tex">a_1\oplus a_2\oplus ...\oplus a_i = 0</script>，那么<script type="math/tex">a_1=a_2\oplus a_3\oplus a_4...\oplus a_i</script>，即<script type="math/tex">a_1</script>能被其他向量通过线性变换表示，这与线性基是<strong>线性无关</strong>这一性质矛盾。</p>
<p>由此，我们还能发现另外一个性质：</p>
<p><strong>异或空间中的任何一个数都能且仅能被线性基中的唯一一个非空子集表示。</strong></p>
<p>什么意思呢？</p>
<p>就是不存在两个不同的非空子集异或出来的数是相同的。</p>
<p>为什么呢？</p>
<p>如果存在两个不同的非空子集异或出来的数是相同的，那么这两个子集的数异或起来（也必定是线性基的一个子集）为<script type="math/tex">0</script>，与线性基的性质矛盾。</p>
<p>这些性质在分析问题时可能会有大用处。</p>
<h1 id="构造原理"><a href="#构造原理" class="headerlink" title="构造原理"></a>构造原理</h1><p>我们刚刚提到，可以把每个数看成一个<script type="math/tex">m</script>维向量。</p>
<p>我们考虑把原来的元素写成一个<script type="math/tex">n</script>行<script type="math/tex">m</script>列的矩阵，每个元素是<script type="math/tex">0/1</script>，我们要构造线性基，就是要将这个矩阵高斯消元（这里运算均为异或）消成一个上三角矩阵，那么前<script type="math/tex">m</script>行中每行的向量压缩成<script type="math/tex">m</script>个数，就是线性基。</p>
<p>为什么呢？</p>
<p>我们先证明，<script type="math/tex">S=\{a_1,a_2,...a_n\}</script>构成的异或空间与<script type="math/tex">T=\{a_1\oplus a_2,a_2,...a_n\}</script>的异或空间是等价的。</p>
<p>证明其实很简单，考虑原来<script type="math/tex">S</script>构成的异或空间的某一个数，如果它不需要<script type="math/tex">a_1</script>就能构造出，那么就不管他。</p>
<p>否则，假设它是<script type="math/tex">a_1\oplus x</script>，那么此时的<script type="math/tex">a_1</script>可以由后面<script type="math/tex">T</script>中<script type="math/tex">(a_1\oplus a_2)\oplus a_2</script>来代替，所以两者等价。</p>
<p>这个说明了什么？</p>
<p>说明我们将原集合中任意一个数<script type="math/tex">a_i</script>，用其异或集合中另外一个数<script type="math/tex">a_j</script>后的值<script type="math/tex">a_i\oplus a_j</script>代替，异或空间是不变的。</p>
<p>也就是说我们在高斯消元的过程中，可以随意地用某一行去异或另一行，所代表的异或空间都不变。</p>
<p>这也就说明了高斯消元来求线性基的正确性。</p>
<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>事实上，由于异或的性质，我们并不需要真的求高斯消元。</p>
<p>我们考虑增量法构造。</p>
<p><strong>Tips: 所谓增量法，指的就是在原来的基础上新增一个元素，进行变化。例如我们熟知的后缀自动机就是增量法构造，说白了，就是支持动态插入一个元素。</strong></p>
<p>我们假设加入的这个数为<script type="math/tex">x</script>，我们从高到低地枚举每一位<script type="math/tex">i</script>，如果<script type="math/tex">x</script>这一位是<script type="math/tex">1</script>。</p>
<ol>
<li><p>已经有了对应线性基存在，由线性基的性质，后面的数不能存在<script type="math/tex">2^i</script>这一位，所以要<script type="math/tex">x=x\oplus p_i</script>（因为异或后构成的异或空间不变）。相当于在高斯消元中把第<script type="math/tex">i</script>位给消去。</p>
</li>
<li><p>否则，这个数可以构成一个基，那么我们令<script type="math/tex">p_i=x</script>，并且立刻<script type="math/tex">break</script>掉。</p>
</li>
</ol>
<p>这相当于在线地进行高斯消元。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//lim 为最大的位数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = lim; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span>(x &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i]) x ^= p[i]; <span class="comment">//如果已经存在，就要把这一位消去</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p[i] = x; <span class="comment">//可以作为这一位的线性基</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h2><p><strong>给定一个集合，选出若干元素，使得异或和最大。</strong></p>
<p>从大到小地枚举每一位，如果<script type="math/tex">ans\oplus p_i > ans</script>，那么就<script type="math/tex">ans=ans\oplus p_i</script>。</p>
<p>为什么这样贪心是对的呢？</p>
<p>考虑如果<script type="math/tex">ans\oplus p_i>ans</script>意味着什么，意味着原来的<script type="math/tex">ans</script>第<script type="math/tex">i</script>位必然是<script type="math/tex">0</script>，不管后面怎么样，如果这一位异或了，那么第<script type="math/tex">i</script>位就会变成<script type="math/tex">1</script>，因为后面的线性基都不可能改变第<script type="math/tex">i</script>位，所以直接异或一定更优。</p>
<h2 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h2><p><strong>给定一个集合，每次给一个数<script type="math/tex">x</script>，询问这个集合构成的异或空间中是否存在<script type="math/tex">x</script>。</strong></p>
<p>其实我们这样构造形成的线性基还不足以体现一些性质，我们考虑这样变换线性基：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = lim; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span>(p[i] &amp; (<span class="number">1</span> &lt;&lt; j)) p[i] ^= p[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们构成的线性基就变成了形如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>xxxx0x0xx0</span><br><span class="line"><span class="number">000001</span>x0xx0</span><br><span class="line"><span class="number">00000001</span>xx0</span><br><span class="line"><span class="number">00000000001</span></span><br></pre></td></tr></table></figure>
<p>的形式，可以发现，如果第<script type="math/tex">i</script>位存在线性基的话，那么当前仅由第<script type="math/tex">p[i]</script>来提供第<script type="math/tex">i</script>位的<script type="math/tex">1</script>。</p>
<p>也就是说，如果想要第<script type="math/tex">i</script>位是<script type="math/tex">1</script>，就必须异或上<script type="math/tex">p[i]</script>。</p>
<p>那么，如果这个<script type="math/tex">x</script>的第<script type="math/tex">i</script>位是<script type="math/tex">1</script>，那么它的构成中必然存在<script type="math/tex">p[i]</script>，假设其是<script type="math/tex">1</script>的位置位<script type="math/tex">v_1,v_2,...v_k</script>，我们只需要检查<script type="math/tex">p[v_1]\oplus p[v_2]...\oplus p[v_k]</script>（如果不存在第<script type="math/tex">v_i</script>位的线性基就把第<script type="math/tex">v_i</script>位的线性基看成<script type="math/tex">0</script>），看最后是否等于<script type="math/tex">x</script>即可，或者反过来，如果<script type="math/tex">x</script>的第<script type="math/tex">i</script>位是<script type="math/tex">1</script>，就让它异或<script type="math/tex">p[i]</script>，只需检查最后是否等于<script type="math/tex">0</script>即可（因为异或上<script type="math/tex">p[i]</script>不会改变<script type="math/tex">x</script>原本为<script type="math/tex">1</script>且存在这一位的线性基的那一位的数）。</p>
<h2 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h2><p><strong>给定一个集合，选出若干元素构成的所有数中，求第k大。</strong></p>
<p>我们考虑类似数位<script type="math/tex">dp</script>的方法从小往大枚举每一个存在线性基的位置，如果我们固定选当前位置的线性基<script type="math/tex">p_i</script>，假设是第<script type="math/tex">s</script>个，那么异或空间中第<script type="math/tex">i</script>位为最高位的数有<script type="math/tex">2^{s-1}</script>个，我们设置一个计数器<script type="math/tex">cnt</script>，每次让<script type="math/tex">cnt+=2^{s-1}</script>，那么我们相当于在从小往大枚举每异或空间里的数。假如第<script type="math/tex">s</script>个（第<script type="math/tex">i</script>位）使得<script type="math/tex">cnt>k</script>，那么说明我们必须要选这一个，那么我们就让<script type="math/tex">ans=ans\oplus p_i</script>，并且让<script type="math/tex">k-=2^{s-1}</script>，再从那一位返回，继续这么做（如果<script type="math/tex">cnt>k</script>就减去并且统计），最后的<script type="math/tex">ans</script>就是结果。</p>
<p>回顾刚才的过程，我们是在干什么？考虑每次我们加的都是<script type="math/tex">2</script>的次幂，我们相当于在枚举<script type="math/tex">k</script>在二进制下的每一位！</p>
<p>那么，我们就直接从小到大枚举每一个存在线性基的位置，假设是第<script type="math/tex">s</script>个，那么我们只需要判断<script type="math/tex">k</script>的第<script type="math/tex">s-1</script>位是否为<script type="math/tex">1</script>，如果是，就选择这一个线性基，让<script type="math/tex">ans</script>异或一下即可。</p>
<p>整个过程十分巧妙，笔者也是思考很长时间才明白其中原理，希望读者仔细把原理想清楚。代码虽短，其中的原理其实才是最重要的呢！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈有标号的DAG计数</title>
    <url>/2021/01/01/%E6%B5%85%E8%B0%88%E6%9C%89%E6%A0%87%E5%8F%B7%E7%9A%84DAG%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>求<script type="math/tex">n</script>个点的有标号有向无环图个数，<script type="math/tex">n\le 5000</script>。</p>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>设<script type="math/tex">f_n</script>表示<script type="math/tex">n</script>个点的<script type="math/tex">DAG</script>个数，那么有以下递推式成立：</p>
<script type="math/tex; mode=display">
f_n=\sum_{i=1}^n(-1)^{i+1}\binom{n}{i}2^{i(n-i)}f_{n-i}</script><p>为什么这个式子成立呢？</p>
<span id="more"></span>
<p>考虑<script type="math/tex">DAG</script>的判定是进行拓扑排序，使得每一轮都能找到有入度为<script type="math/tex">0</script>的点。我们可以根据这个思想进行递推。</p>
<p>对于一个<script type="math/tex">DAG</script>，一定有至少<script type="math/tex">1</script>个入度为<script type="math/tex">0</script>的点，那么我们枚举钦定有<script type="math/tex">i</script>个点入度为<script type="math/tex">0</script>，先从<script type="math/tex">n</script>个里面选出<script type="math/tex">i</script>个，那么剩下的<script type="math/tex">n-i</script>个点为<script type="math/tex">DAG</script>，然后这<script type="math/tex">i</script>个点和剩下<script type="math/tex">n-i</script>个点之间随便连边，即<script type="math/tex">2^{i(n-i)}</script>。但是，剩下的<script type="math/tex">n-i</script>个点中也有可能出现入度为<script type="math/tex">0</script>的点，因此我们需要容斥（容斥系数可以根据二项式反演推导）。</p>
<p>时间复杂度<script type="math/tex">O(n^2)</script>。</p>
<h1 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h1><p>求<script type="math/tex">n</script>个点的<script type="math/tex">DAG</script>个数，对<script type="math/tex">998244353</script>取模，<script type="math/tex">n\le 10^5</script>。</p>
<h1 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h1><p>考虑把递推式写为卷积形式，但是注意到<script type="math/tex">2^{i(n-i)}</script>不太能拆。这个时候，由类似<script type="math/tex">Z</script>变换的经典套路，因为</p>
<script type="math/tex; mode=display">
ix=\frac{1}{2}((i+x)^2-i^2-x^2)</script><p>因此</p>
<script type="math/tex; mode=display">
2^{i(n-i)}=2^{\frac{1}{2}(n^2-i^2-(n-i)^2)}</script><p>由于模<script type="math/tex">998244353</script>意义下存在<script type="math/tex">2</script>的二次剩余，即存在<script type="math/tex">w</script>使得<script type="math/tex">w^2\equiv 2\pmod{998244353}</script>，因此递推式可以转化为</p>
<script type="math/tex; mode=display">
f_n=\sum_{i=1}^n(-1)^{i+1}\frac{n!}{i!(n-i)!}w^{n^2-i^2-(n-i)^2}f_{n-i}</script><p>记</p>
<script type="math/tex; mode=display">
F(x)=\sum_{i\ge 0} \frac{f_i}{i!w^i}x^i\\
G(x)=\sum_{i\ge 1}\frac{(-1)^{i+1}}{i!w^i}x^i</script><p>那么根据递推式，有</p>
<script type="math/tex; mode=display">
F(x)=F(x)G(x)+1\\
F(x)=\frac{1}{1-G(x)}</script><p>直接多项式求逆即可，时间复杂度<script type="math/tex">O(n\log n)</script>。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>容斥原理</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈虚树</title>
    <url>/2020/04/17/%E6%B5%85%E8%B0%88%E8%99%9A%E6%A0%91/</url>
    <content><![CDATA[<h1 id="虚树"><a href="#虚树" class="headerlink" title="虚树"></a>虚树</h1><p>有的时候，题目给你一棵树，然后有<script type="math/tex">q</script>组询问，每组询问为与树上有关的<script type="math/tex">k</script>个点的相关问题，而这个问题如果只有一个询问的话，可以用树形<script type="math/tex">dp</script>轻松解决，那么我们可以考虑每次只在这<script type="math/tex">k</script>个点及相关的点构成的树上进行<script type="math/tex">dp</script>，时间复杂度为<script type="math/tex">O(\sum klog_2 k)</script>。</p>
<span id="more"></span>
<h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><p>虚树是由哪些点组成的呢？</p>
<p>我们姑且称每次询问的<script type="math/tex">k</script>个点为关键节点，虚树由这<script type="math/tex">k</script>个点和任意两点的<script type="math/tex">LCA</script>构成。</p>
<p>这个规模看起来很大，但实际上，把这<script type="math/tex">k</script>个点按照<script type="math/tex">dfs</script>序排好序，那么在序列中相邻两点的<script type="math/tex">LCA</script>构成的点集就是任意两点的<script type="math/tex">LCA</script>的点集，这个可以画图来证明。</p>
<p>一般来说，虚树还要把根节点看为关键节点，有利于做题，只不过统计答案时不统计它就是了。</p>
<p>可以看出，如果边可以压缩，那么在这棵树上进行<script type="math/tex">dp</script>和在原树上<script type="math/tex">dp</script>是等价的，但此时点的规模就要小很多了，一共只有<script type="math/tex">2k</script>个点。</p>
<h1 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h1><p>那么，我们如何构造虚树呢？</p>
<p>首先，我们把这<script type="math/tex">k</script>个点按照<script type="math/tex">dfs</script>序排好序，然后我们用一个单调栈来维护树上的一条链。</p>
<p>我们考虑加入一个点<script type="math/tex">u</script>，我们求出它与栈顶元素的<script type="math/tex">LCA</script>，记为<script type="math/tex">l</script>，如果<script type="math/tex">l=stk[top]</script>，那么说明这个点也在当前栈表示的这条链上，加入栈即可。</p>
<p>否则，说明这个点开辟了一个新的链，因为我们的栈中始终维护的是当前节点与根节点构成的链，所以我们要把原来的栈顶元素一个个弹出，并连边<script type="math/tex">(stk[top-1],stk[top])</script>，直到<script type="math/tex">stk[top]</script>是<script type="math/tex">l</script>的祖先为止。</p>
<p>此时我们看<script type="math/tex">stk[top]</script>是否等于<script type="math/tex">l</script>，如果是，直接加入当前节点即可，否则，我们还要把<script type="math/tex">l</script>给加进去。</p>
<p>别忘了，如果我们要加<script type="math/tex">l</script>进去，记得把<script type="math/tex">l</script>和上一个弹出栈的点连边。</p>
<p>最后再把<script type="math/tex">u</script>加进去即可。</p>
<p><script type="math/tex">LCA</script>可以<script type="math/tex">O(nlog_2n)-O(1)</script>求，主要是排序复杂度为<script type="math/tex">O(klog_2k)</script>，故总复杂度为<script type="math/tex">O(\sum klog_2 k)</script>。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> dfn[a] &lt; dfn[b]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + k + <span class="number">1</span>, comp);</span><br><span class="line">    </span><br><span class="line">    stk[ top = <span class="number">1</span> ] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = a[i];</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">LCA</span>(x, stk[top]);</span><br><span class="line">        <span class="keyword">if</span>(l != stk[top])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(dfn[l] &lt; dfn[ stk[top - <span class="number">1</span>] ])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">add</span>(stk[top - <span class="number">1</span>], stk[top]);</span><br><span class="line">                top --;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dfn[l] &gt; dfn[ stk[top - <span class="number">1</span>] ]) <span class="built_in">add</span>(l, stk[top]), stk[top] = l;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">add</span>(l, stk[top]), top --;</span><br><span class="line">        &#125;</span><br><span class="line">        stk[++ top] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(top &gt; <span class="number">1</span>) <span class="built_in">add</span>(stk[top - <span class="number">1</span>], stk[top]), top --;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈询问分块</title>
    <url>/2020/04/20/%E6%B5%85%E8%B0%88%E8%AF%A2%E9%97%AE%E5%88%86%E5%9D%97/</url>
    <content><![CDATA[<h1 id="询问分块"><a href="#询问分块" class="headerlink" title="询问分块"></a>询问分块</h1><p>什么是询问分块？</p>
<p>对于一些题目，它的操作我们无法用高级数据结构在<script type="math/tex">log_2n</script>时间复杂度内解决，那么，我们可以考虑，<strong>对询问分块，定期重构</strong>，使复杂度降为<script type="math/tex">\sqrt{n}</script>级别。</p>
<p>注意，这个询问分块的适用范围还是比较广泛的，因为它只需要答案重构复杂度为<script type="math/tex">O(n)</script>，且对于一个修改，我们能很快，如在<script type="math/tex">O(1)</script>或<script type="math/tex">O(log_2n)</script>的时间内，计算出它对某个询问的贡献，那么我们就可以用这种对询问分块的方法。</p>
<p>实际上，对询问分块可以看成一种强大的暴力。</p>
<span id="more"></span>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>我们考虑两种暴力：</p>
<p>第一种，对于一个修改，我们用它暴力更新所有答案（例如单点加，区间查询，我们每加一个数，就修改所有前缀和）；第二种，对于一个询问，我们暴力枚举前面所有的修改，计算其对当前询问的影响。</p>
<p>这两种暴力，时间复杂度都是<script type="math/tex">O(1)-O(n)</script>的，只不过第一种是询问<script type="math/tex">O(1)</script>，修改<script type="math/tex">O(n)</script>，第二种为询问<script type="math/tex">O(n)</script>，修改<script type="math/tex">O(1)</script>。那么，我们能不能把这两种暴力结合起来呢？</p>
<p>实际上，对操作分块，定期重构，就是这两种暴力的结合。</p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p>我们将所有的操作（查询和修改）分块，然后对于一个块的修改，我们暴力更新这个块内的所有询问（或者，对于一个块的询问，我们暴力遍历这个块的所有修改，计算贡献）。当这一个块结束的时候，我们用这个块内所有修改，重构所有的答案。</p>
<p>这就是整个流程，是不是非常简单？</p>
<p>时间复杂度呢？我们考虑设<script type="math/tex">B</script>个元素为一个块。</p>
<p>那么，对于第一种操作，每个修改会更新<script type="math/tex">B</script>个询问（或者每个询问会访问<script type="math/tex">B</script>个修改），这一部分时间复杂度为<script type="math/tex">O(nB)</script>；对于第二种操作，每次重构答案是<script type="math/tex">O(n)</script>，所以第二种操作复杂度为<script type="math/tex">O(n\frac{n}{B})</script>。</p>
<p>那么总复杂度为<script type="math/tex">O(nB+n\frac{n}{B})</script>，由均值不等式得当<script type="math/tex">B=\sqrt{n}</script>时时间复杂度为<script type="math/tex">O(n\sqrt{n})</script>。</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>对于许多一般性问题，可以直接应用此思想。</p>
<p>对于有些树上问题，每次修改对询问的影响涉及所有点的更新，我们可以对整棵树在这个块内涉及的修改点建成一棵虚树，每次修改在虚树上面跑，也可以保证复杂度。</p>
<p>如果读者实在想不出有什么问题要建虚树，请看这道经典<strong>虚树加操作分块</strong>的题：</p>
<p><a href="https://codeforces.com/contest/966/problem/E">CF966E May Holidays</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈连通图计数</title>
    <url>/2019/03/09/%E6%B5%85%E8%B0%88%E8%BF%9E%E9%80%9A%E5%9B%BE%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="什么是连通图计数"><a href="#什么是连通图计数" class="headerlink" title="什么是连通图计数"></a>什么是连通图计数</h1><p>所谓连通图计数，指的是：n个<strong>有序的点</strong>构成的<strong>无向连通图</strong>的个数。</p>
<p>这是一个很经典的模型，很多题目都是基于它而产生，而且，它的思想也十分值得学习。</p>
<p>我们一起来看看吧。</p>
<span id="more"></span>
<h1 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h1><p>连通图计数是有递推公式的，而且还不简单。</p>
<p>具体地，我们设：</p>
<script type="math/tex; mode=display">
f[n]:n个点构成的无向连通图个数\\
g[n]:含有n个点的图的个数</script><p>n个点所构成的所有的图（包括连通和不连通）有<script type="math/tex">2^{C(n-1,2)}=2^{\frac{n(n-1)}{2}}</script>。</p>
<p>则<script type="math/tex">g[n]=2^{\frac{n(n-1)}{2}}</script></p>
<p>考虑<script type="math/tex">g[n]</script>的递推公式，这是一个非常重要的思想：我们枚举1号点所在的联通块大小，然后当1号点大小为<script type="math/tex">i</script>的时候，其他的在联通块中的点一共有<script type="math/tex">C(n-1,i-1)</script>种选法，每种选法有<script type="math/tex">f[i]</script>种连通图，然后剩下的点就可以随便选，就是<script type="math/tex">g[n-i]</script>：</p>
<script type="math/tex; mode=display">
g[n]=\sum_{i=1}^{n}C(n-1,i-1)*f[i]*g[n-i]\\
g[n]=\sum_{i=1}^n\frac{(n-1)!}{(n-i)!(i-1)!}*f[i]*g[n-i]\\
\frac{g[n]}{(n-1)!}=\sum_{i=1}^n\frac{f[i]}{(i-1)!}\frac{g[n-i]}{(n-i)!}</script><p>然后，我们设几个生成函数：</p>
<script type="math/tex; mode=display">
H(x)=\sum_{i=1}\frac{g[i]}{(i-1)!}x^i\\
F(x)=\sum_{i=1}\frac{f[i]}{(i-1)!}x^i\\
G(x)=\sum_{i=0}\frac{g[i]}{i!}x^i</script><p>那么，我们有</p>
<script type="math/tex; mode=display">
H=F*G\\
F=H*G^{-1}(mod\quad x^{n+1})</script><p>这样，我们直接对<script type="math/tex">G</script>多项式求逆再与<script type="math/tex">H</script>卷积就好了。</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>这个例题就是裸题了：</p>
<p><a href="https://www.luogu.org/problemnew/show/P4841">城市规划</a></p>
<p>注意，这一题的模数是1004535809，我们要找它的原根。</p>
<p>怎样找一个数的原根呢？</p>
<p>我们可以暴力找，找到一个数<script type="math/tex">g</script>使得<script type="math/tex">g^{p-1}\equiv 1(mod\quad p)</script>，那么，这个<script type="math/tex">g</script>就是原根。</p>
<p>这里，原根是3。</p>
<p>嗯，就是模板题啦，上代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">1e6</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g = <span class="number">3</span>, gi = <span class="number">334845270</span>, mod = <span class="number">1004535809</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> F[maxN + <span class="number">1</span>], G[maxN + <span class="number">1</span>], H[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> tmp[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> inv[maxN + <span class="number">1</span>], fac[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> r[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    inv[n] = <span class="built_in">pow</span>(fac[n], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) inv[i] = inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> lim, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++)</span><br><span class="line">       <span class="keyword">if</span>(i &lt; r[i]) <span class="built_in">swap</span>(a[i], a[ r[i] ]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> wn = <span class="built_in">pow</span>(type == <span class="number">1</span> ? g : gi, (mod - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i += (mid &lt;&lt; <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; j++, w = w * wn % mod)</span><br><span class="line">            &#123;</span><br><span class="line">                 <span class="keyword">int</span> x = a[i + j], y = a[i + mid + j] * w % mod;</span><br><span class="line">                 a[i + j] = (x + y) % mod, a[i + mid + j] = ((x - y) % mod + mod) % mod;    </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> lim, <span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">NTT</span>(a, lim, <span class="number">1</span>); <span class="built_in">NTT</span>(b, lim, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++) b[i] = ((<span class="number">2</span> - a[i] * b[i]) % mod + mod) % mod * b[i] % mod;</span><br><span class="line">    <span class="built_in">NTT</span>(b, lim, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="built_in">pow</span>(lim, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++) b[i] = b[i] * tmp % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> deg, <span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(deg == <span class="number">1</span>) &#123; b[<span class="number">0</span>] = <span class="built_in">pow</span>(a[<span class="number">0</span>], mod - <span class="number">2</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="built_in">solve</span>((deg + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, a, b);</span><br><span class="line">    <span class="keyword">int</span> lim = <span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(lim &lt; (deg &lt;&lt; <span class="number">1</span>)) lim &lt;&lt;= <span class="number">1</span>, cnt ++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; cnt - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">copy</span>(a, a + deg, tmp);</span><br><span class="line">    <span class="built_in">fill</span>(tmp + deg, tmp + lim, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">calc</span>(lim, tmp, b); </span><br><span class="line">    <span class="built_in">fill</span>(b + deg, b + lim, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lim = <span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(lim &lt; (n * <span class="number">2</span>)) lim &lt;&lt;= <span class="number">1</span>, cnt ++;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; cnt - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NTT</span>(a, lim, <span class="number">1</span>); <span class="built_in">NTT</span>(b, lim, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++) a[i] = a[i] * b[i] % mod;</span><br><span class="line">    <span class="built_in">NTT</span>(a, lim, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="built_in">pow</span>(lim, mod - <span class="number">2</span>); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++) a[i] = a[i] * tmp % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> int</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) H[i] = <span class="built_in">pow</span>(<span class="number">2</span>, i * (i - <span class="number">1</span>) / <span class="number">2</span>) * inv[i - <span class="number">1</span>] % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) G[i] = <span class="built_in">pow</span>(<span class="number">2</span>, i * (i - <span class="number">1</span>) / <span class="number">2</span>) * inv[i] % mod;</span><br><span class="line">    <span class="built_in">solve</span>(n + <span class="number">1</span>, G, F);</span><br><span class="line">    <span class="built_in">mul</span>(F, H);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, F[n] * fac[n - <span class="number">1</span>] % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈莫队算法</title>
    <url>/2021/07/20/%E6%B5%85%E8%B0%88%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="普通莫队"><a href="#普通莫队" class="headerlink" title="普通莫队"></a>普通莫队</h1><p>莫队，是一种算法，是国家队长莫涛发明的，它是来解决什么问题的呢？</p>
<p>我们常常会遇到这样一类题：给你一个<script type="math/tex">[1,n]</script>的序列，每次查询<script type="math/tex">[l,r]</script>的一些信息（例如不同数的个数等），这个时候，我们就可以使用莫队来解决。</p>
<span id="more"></span>
<p>注意，莫队是一种离线算法。</p>
<p>我们考虑，当我们知道<script type="math/tex">[l1,r1]</script>的值时，我们要计算出<script type="math/tex">[l2,r2]</script>的值。</p>
<p>我们可以<script type="math/tex">O(1)</script>地算出<script type="math/tex">[l1-1,r1],[l1+1,r1],[l1,r1-1],[l1,r1+1]</script>的值，那么，我们就可以在<script type="math/tex">O(|l2-l1|+|r2-r1|)</script>的时间复杂度内完成这次转移，即算出答案。也就是说，我们可以省去这两个询问区间的交集所需要的时间。</p>
<p>而我们现在要做的，就是通过一种特定的排序方式，使得对于一个询问集合<script type="math/tex">q</script>,使得<script type="math/tex">\sum_{i=1}^n(|q[i].l-q[i-1].l|+q[i].r-q[i-1].r|)</script>达到我们可以接受的值；</p>
<p>我们考虑用分块来优化，以<strong>左端点所在的块</strong>为第一关键字，<strong>右端点的值</strong>为第二关键字来排序，这样的时间复杂度就降到了<script type="math/tex">O(n\sqrt{m})</script>。</p>
<p>为什么呢？</p>
<p>设块大小为<script type="math/tex">B</script>。</p>
<p>我们考虑莫队的过程，左端点在同一个块里的操作会在一起做。我们考虑<script type="math/tex">l,r</script>指针的移动次数。先考虑块内移动，对于每个询问，左端点因为在块内移动，最多移动<script type="math/tex">B</script>次，而右端点由于对于每个块内部右端点是单调的（可能单调升也可能单调降），因此对于每个块内的所有询问，右端点的移动次数和是<script type="math/tex">O(n)</script>的。那么总复杂度就是<script type="math/tex">O(mB+\frac{n^2}{B})</script>，此时当<script type="math/tex">mB=\frac{n^2}{B}</script>，即<script type="math/tex">B=\frac{n}{\sqrt{m}}</script>时，复杂度达到理论最优，为<script type="math/tex">O(n\sqrt{m})</script>。</p>
<p>另外，我们在comp函数中可以进行优化（奇偶块优化），即如果是奇数块就右端点升序排列，否则就降序排列：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(Node a, Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> belong[a.l] ^ belong[b.l] ? belong[a.l] &lt; belong[b.l] : belong[a.l] &amp; <span class="number">1</span> ? a.r &lt; b.r : a.r &gt; b.r; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样会快很多，还有就是<script type="math/tex">B</script>的大小跟代码速度有巨大关系，实际上当<script type="math/tex">B=\frac{n}{\sqrt{\frac{2}{3}m}}</script>时，是最快的</p>
<h1 id="高维莫队"><a href="#高维莫队" class="headerlink" title="高维莫队"></a>高维莫队</h1><p>从本质上来看，莫队是解决偏序问题的有力武器，具体来说，对于每个点，它有若干维度，那么莫队的每个询问就是查询第一个维度<script type="math/tex">\le a_1</script>，第二个维度<script type="math/tex">\le a_2</script>，…，第<script type="math/tex">k</script>个维度<script type="math/tex">\le a_k</script>的点的集合的价值（当然，每一维也可以是<script type="math/tex">\ge</script>）。</p>
<p>而普通莫队，本质上是二维莫队，即它的询问形如求第一维<script type="math/tex">\ge l</script>，第二维<script type="math/tex">\le r</script>的点构成的集合的价值，而在序列上点的第一维和第二维都是这个点的位置。</p>
<p>为了方便起见，在以下的讨论中，我们默认对于每一维的限制都是<script type="math/tex">\le a_i</script>，并且假设是<script type="math/tex">k</script>维莫队。</p>
<p>那么，莫队实际上是维护了<script type="math/tex">k</script>个指针<script type="math/tex">(t_1,t_2,\dots,t_k)</script>，而每次操作形如<script type="math/tex">add(t_i)</script>或者<script type="math/tex">del(t_i)</script>，其意义在于加入/删除第<script type="math/tex">i</script>维为<script type="math/tex">t_i</script>，且对于剩下的第<script type="math/tex">j</script>（<script type="math/tex">j\neq i</script>）维均满足<script type="math/tex">a_j\le t_j</script>的点。而为什么在普通莫队中我们看不到这样的操作呢？那是由于序列操作的特殊性，使得我们无需判断这些情况。</p>
<p>那么，对于高维莫队，我们怎么解决呢？</p>
<p>以下为了方便起见，我们假设每一维的值域都是相同的<script type="math/tex">[1, n]</script>，且询问数和值域同阶，也是<script type="math/tex">n</script>。</p>
<p>仍然沿用二维莫队的做法，我们给前<script type="math/tex">k-1</script>维进行分块。设每一维都以<script type="math/tex">B</script>个值为一块。那么在给询问排序的时候，我们先比较第一维块的编号，若相同则比较第二维块的编号，…，若前<script type="math/tex">k-1</script>维编号都相同，那么就比较第<script type="math/tex">k</script>维的大小。</p>
<p>那么，这样做的复杂度是什么呢？</p>
<p>首先，考虑第<script type="math/tex">k</script>维指针的移动次数。一共有<script type="math/tex">(\frac{n}{B})^{k-1}</script>种不同的块，而每个块我们都要在第<script type="math/tex">k</script>维遍历一遍，因此这一部分的复杂度是<script type="math/tex">(\frac{n}{B})^{k-1}n</script>，即<script type="math/tex">\frac{n^k}{B^{k-1}}</script>。</p>
<p>然后，考虑前<script type="math/tex">k-1</script>维指针移动的次数。对于每个询问，前<script type="math/tex">k-1</script>个指针每个指针都最多移动<script type="math/tex">B</script>次，因此这一部分复杂度为<script type="math/tex">knB</script>。由于<script type="math/tex">k</script>不会很大，基本上是常数，因此我们把这一部分复杂度看成<script type="math/tex">nB</script>。</p>
<p>总复杂度即<script type="math/tex">\frac{n^k}{B^{k-1}}+nB</script>，那么在<script type="math/tex">B=n^{\frac{k-1}{k}}</script>时这个式子取到最小，是<script type="math/tex">O(n^{\frac{2k-1}{k}})</script>。</p>
<p>那么，对于高维莫队，我们有了统一的解决方法，可以发现当<script type="math/tex">k</script>过大的时候这个方法不一定有暴力优秀，因此对于这类问题，<script type="math/tex">k</script>不会很大。</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>其实很多问题可以看成高维莫队问题。</p>
<p>例如，我们常说的带修莫队，实际上就是三维莫队，即我们多加了一维时间，表示求所有时间<script type="math/tex">\le t</script>的点的价值，此时我们取<script type="math/tex">B=n^{\frac{2}{3}}</script>最优，复杂度为<script type="math/tex">O(n^{\frac{5}{3}})</script>。</p>
<p>而对于一类对矩形进行统计的问题，我们可以把它看成四维莫队，即行有两维限制，列也有两维限制，那么我们只需要快速求出同一行某个区间内的价值及同一列某个区间内价值即可，此时取<script type="math/tex">B=n^{\frac{3}{4}}</script>，时间复杂度<script type="math/tex">O(n^{\frac{7}{4}})</script>。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>第二类斯特林数相关</title>
    <url>/2019/02/25/%E7%AC%AC%E4%BA%8C%E7%B1%BB%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="第二类斯特林数基础"><a href="#第二类斯特林数基础" class="headerlink" title="第二类斯特林数基础"></a>第二类斯特林数基础</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>第二类斯特林数<script type="math/tex">S(n,m)</script>表示n个不同的球放到m个相同的盒子里的方案数。</p>
<h2 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h2><p>一般的求法有两种：</p>
<h3 id="1-递推："><a href="#1-递推：" class="headerlink" title="1.递推："></a>1.递推：</h3><script type="math/tex; mode=display">
S(n,m)=S(n-1,m-1)+m*S(n-1,m)</script><span id="more"></span>
<p>为什么呢？</p>
<p>我们考虑最新加进来的球放在哪，如果它自成一个盒子，那么就加上<script type="math/tex">S(n-1,m-1)</script>,还有，就是加入原有的<script type="math/tex">m</script>个盒子中的任何一个，因此要加上<script type="math/tex">m*S(n-1,m)</script></p>
<h3 id="2-容斥（常用方法）："><a href="#2-容斥（常用方法）：" class="headerlink" title="2.容斥（常用方法）："></a>2.容斥（常用方法）：</h3><p>我们有这样一个式子：</p>
<script type="math/tex; mode=display">
S(n,m)=\frac{1}{m!}\sum_{k=0}^m(-1)^kC(m,k)(m-k)^n</script><p>这是什么意思呢？</p>
<p>我们枚举的k是指m个盒子中至少有k个空盒子，然后这k个空盒子一共有<script type="math/tex">C(m,k)</script>种方案，这样，有<script type="math/tex">(m-k)</script>个盒子可供选择。对于每一个球，一共有<script type="math/tex">m-k</script>种选择，就乘上<script type="math/tex">(m-k)^n</script>就好了。</p>
<p>然后，由于盒子都是相同的，所以最后的答案要除以<script type="math/tex">m!</script>。</p>
<p>为什么说这是一个常用方法呢？</p>
<p>因为这样，可以让<script type="math/tex">S(n,m)</script>变成一个卷积，就可以在<script type="math/tex">O(nlogn)</script>的时间内解决这个问题。</p>
<p>怎么卷积呢？</p>
<p>我们考虑，我们现在要求的是</p>
<script type="math/tex; mode=display">
\frac{1}{m!}\sum_{k=0}^m(-1)^kC(m,k)(m-k)^n\\
=\sum_{k=0}^m(-1)^k*\frac{1}{m!}*\frac{m!}{(m-k)!*k!}*(m-k)^n\\
=\sum_{k=0}^m\frac{(-1)^k}{k!}*\frac{(m-k)^n}{(m-k)!}</script><p>这样，很显然地，我们设</p>
<script type="math/tex; mode=display">
f(i)=\frac{(-1)^i}{i!},g(i)=\frac{i^n}{i!}</script><p>这样，我们直接求<script type="math/tex">f*g</script>就可以了。</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>第二类斯特林数有一个特别重要的性质：</p>
<script type="math/tex; mode=display">
x^n=\sum_{k=0}^{min(x,n)}S(n,k)*x^{\underline{k}}</script><p>其中，</p>
<script type="math/tex; mode=display">
x^{\underline{k}}=x*(x-1)*...*(x-k+1)</script><p>称为下降幂。</p>
<p>而，我们又有：</p>
<script type="math/tex; mode=display">
C(x,k)=\frac{x^{\underline{k}}}{k!}</script><p>这个式子的证明就是把组合数暴力展开一下，就会发现等于右边的式子。</p>
<p>于是，最上面的那个式子又可以写成</p>
<script type="math/tex; mode=display">
x^n=\sum_{k=0}^{x}S(n,k)*C(x,k)*k!</script><p>考虑我们怎么证明这个鬼东西。</p>
<p>首先，<script type="math/tex">x^n</script>可以看成n个小球放在x个不同盒子的方案数（允许空盒），那么，我们就有：</p>
<script type="math/tex; mode=display">
x^n=\sum_{k=0}^xS(n,k)*k!*C(x,k)</script><p>这个也很好理解，就是我们枚举这x个盒子中非空的盒子有k个，那么，如果这k个盒子相同，答案就是<script type="math/tex">S(n,k)</script>，然而，问题是这k个盒子不同，所以我们就要乘以一个排列，就是乘以<script type="math/tex">k!</script>，然后，这x个盒子中还要选出k个，所以还要再乘以一个组合数<script type="math/tex">C(x,k)</script></p>
<p><del>感性理解一下</del></p>
<p>于是，我们就发现了一个神奇的式子，而且非常有用。</p>
<p>再列出来给大家熟悉（背诵）一下，因为S,C都要非0，则有<script type="math/tex">k<=n,k<=x</script>，所以，最终的式子就是：</p>
<script type="math/tex; mode=display">
x^n=\sum_{k=0}^{min(n,x)}S(n,k)*k!*C(x,k)</script><h1 id="第二类斯特林数应用"><a href="#第二类斯特林数应用" class="headerlink" title="第二类斯特林数应用"></a>第二类斯特林数应用</h1><p><a href="https://cmwqf.github.io/2019/02/26/%E5%9B%BE%E7%9A%84%E4%BB%B7%E5%80%BC/#more">BZOJ5093图的价值</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>美好的一天</title>
    <url>/2019/01/28/%E7%BE%8E%E5%A5%BD%E7%9A%84%E4%B8%80%E5%A4%A9/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>回归天空是一件庄重的事情，所以卓司决定让大家分批次进行，给每个人给了一个小写字母’a’-&gt;’z’作为编号</p>
<p>一个区间的人如果满足他们的<strong>编号重排之后可以成为一个回文串</strong>，则他们可以一起回归天空，即这个区间可以回归天空</p>
<p>由于卓司是一个喜欢妄想的人，他妄想了m个区间，每次他想知道每个区间中有多少个子区间可以回归天空</p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>虽然毒瘤，但是不得不说，这是一道好题啊</p>
<p>很容易知道，如果一段区间可以组成回文串，则最多有一个字母出现奇数次；</p>
<p>这个奇数偶数的问题，我们便可以想到用状压，开一个<script type="math/tex">1<<26</script>的数组（然而毒瘤卡空间，因为<script type="math/tex">n<=60000</script>，所以可以用<script type="math/tex">unsigned short</script>），用1表示奇数次，用0表示偶数次，这样，只要计算一个区间的异或和就可以了，而区间<script type="math/tex">[l,r]</script>的异或和<script type="math/tex">ans(l,r)=ans(1,r)\oplus ans(1,l-1)</script>，于是，我们就可以记录<script type="math/tex">a</script>数组为这个序列的前缀异或和；</p>
<p>然后，怎么做呢？</p>
<p>我们考虑从<script type="math/tex">[l,r]</script>转移到<script type="math/tex">[l,r+1]</script>，答案会发生什么变化：</p>
<p>我们只要加上</p>
<script type="math/tex; mode=display">
a[x]\oplus a[r+1]==0(x\in[l-1,r])</script><p>或者</p>
<script type="math/tex; mode=display">
a[x]\oplus a[r+1]==2^i(x\in[l-1,r])</script><p>的个数就可以了。</p>
<p>我们怎样找个数呢？我们记录一个<script type="math/tex">cnt</script>数组，<script type="math/tex">cnt[x]</script>代表状态为<script type="math/tex">x</script>的个数有多少个；</p>
<p>由异或的性质，第一种情况可看成</p>
<script type="math/tex; mode=display">
a[r+1]\oplus0==a[x]，即a[r+1]==a[x]</script><p>的个数，此时，<script type="math/tex">ans+=cnt[a[r+1]]</script>即可；</p>
<p>对于第二种，同样，我们可以写成</p>
<script type="math/tex; mode=display">
a[r+1]\oplus 2^i==a[x]</script><p>的个数，这样，我们枚举<script type="math/tex">i</script>（从<script type="math/tex">0</script>到<script type="math/tex">25</script>），<script type="math/tex">ans+=cnt[a[r+1]\oplus (1<<i)]</script>即可；</p>
<p>这样，就做完了，时间复杂度为<script type="math/tex">O(26m\sqrt{n})</script></p>
<p><strong>注意</strong>：</p>
<p>我以前写的莫队模板因为毒瘤的<script type="math/tex">unsigned short</script>变得奇怪起来（我调了好长时间），以后要注意，莫队修改的时候，先<script type="math/tex">add</script>，后<script type="math/tex">del</script>，防止出现<script type="math/tex">cnt</script>负数而导致奇怪的情况。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN=<span class="number">6e4</span> + <span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,id;</span><br><span class="line">&#125;q[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> cnt[(<span class="number">1</span>&lt;&lt;<span class="number">26</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,ans,res[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> block,belong[maxN+<span class="number">1</span>],a[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">char</span> s[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) num=(num&lt;&lt;<span class="number">3</span>)+(num&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> num*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(Node a,Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> belong[a.l]^belong[b.l] ? belong[a.l]&lt;belong[b.l] : belong[a.l]&amp;<span class="number">1</span> ? a.r&lt;b.r : a.r&gt;b.r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt[x]--;</span><br><span class="line">    ans-=cnt[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) ans-=cnt[x^(<span class="number">1</span>&lt;&lt;i)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans+=cnt[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) ans+=cnt[x^(<span class="number">1</span>&lt;&lt;i)];</span><br><span class="line">    cnt[x]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>; cnt[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(l&gt;q[i].l) <span class="built_in">add</span>(a[--l]);</span><br><span class="line">        <span class="keyword">while</span>(r&lt;q[i].r) <span class="built_in">add</span>(a[++r]);</span><br><span class="line">        <span class="keyword">while</span>(l&lt;q[i].l) <span class="built_in">del</span>(a[l++]);</span><br><span class="line">        <span class="keyword">while</span>(r&gt;q[i].r) <span class="built_in">del</span>(a[r--]);</span><br><span class="line">        res[q[i].id]=ans; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    block=n/<span class="built_in">sqrt</span>(m*<span class="number">2</span>/<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=a[i<span class="number">-1</span>]^(<span class="number">1</span>&lt;&lt;(s[i]-<span class="string">&#x27;a&#x27;</span>)),belong[i]=(i<span class="number">-1</span>)/block+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) q[i].l=<span class="built_in">read</span>()<span class="number">-1</span>,q[i].r=<span class="built_in">read</span>(),q[i].id=i;</span><br><span class="line">    <span class="built_in">sort</span>(q+<span class="number">1</span>,q+m+<span class="number">1</span>,comp);</span><br><span class="line">    <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>简单数学题</title>
    <url>/2019/02/21/%E7%AE%80%E5%8D%95%E6%95%B0%E5%AD%A6%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>求</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\sum_{j=1}^nijgcd(i,j)\quad mod\quad p</script><span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>我们开始大力推式子：</p>
<p>根据以往经验，我们这样变形：</p>
<script type="math/tex; mode=display">
\sum_{d=1}^nd*\sum_{i=1}^n\sum_{j=1}^nij*[gcd(i,j)==d]\\
\sum_{d=1}^nd^3*\sum_{i=1}^{n/d}\sum_{j=1}^{n/d}ij*[gcd(i,j)==1]\\</script><p>这就是把后面的<script type="math/tex">i,j</script>都除以<script type="math/tex">d</script>，这样，在前面要把补回来，于是就出现了<script type="math/tex">d^3</script></p>
<p>有莫比乌斯反演可得：</p>
<script type="math/tex; mode=display">
\sum_{d=1}^nd^3*\sum_{i=1}^{n/d}\sum_{j=1}^{n/d}ij\sum_{p|i,p|j}\mu(p)</script><p>接下来的式子，理解起来有些困难（可能是我太弱了）：我们将p的枚举提到前面来，并且枚举原来的i,j分别是p的多少倍：</p>
<script type="math/tex; mode=display">
\sum_{d=1}^nd^3*\sum_{p=1}^{n/d}\mu(p)\sum_{i=1}^{n/(pd)}\sum_{j=1}^{n/(pd)}(i*p)*(j*p)</script><p>此处的i,j枚举的是原来的i,j是p的多少倍，而此处的<script type="math/tex">i\times p,j\times p</script>才是原来的i和j（可能有点绕，多读几遍就好了）。接下来，我们可以将两个p提到前面来：</p>
<script type="math/tex; mode=display">
\sum_{d=1}^nd^3*\sum_{p=1}^{n/d}\mu(p)*p^2\sum_{i=1}^{n/(pd)}\sum_{j=1}^{n/(pd)}i*j</script><p>而</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{n/(pd)}\sum_{j=1}^{n/(pd)}i*j=（1+2+...+\frac{n}{pd})^2</script><p>所以，原式就变成了：</p>
<script type="math/tex; mode=display">
\sum_{d=1}^nd^3*\sum_{p=1}^{n/d}\mu(p)*p^2*(1+2+...+\frac{n}{pd})^2</script><p>我们设<script type="math/tex">T=pd</script>（也是套路）,再换一种枚举方式，并把提到最前面，并设：</p>
<script type="math/tex; mode=display">
sum(n)=1+2+...+n</script><script type="math/tex; mode=display">
\sum_{T=1}^nsum(\frac{n}{T})^2\sum_{d|T}d^3*(\frac{T^2}{d^2})*\mu(\frac{T}{d})\\
\sum_{T=1}^nsum(\frac{n}{T})^2\sum_{d|T}d*T^2*\mu(\frac{T}{d})\\
\sum_{T=1}^nsum(\frac{n}{T})^2*T^2\sum_{d|T}d*\mu(\frac{T}{d})\\</script><p>根据之前的结论，我们有：</p>
<script type="math/tex; mode=display">
\mu*id=\phi</script><p>而巧合的是：</p>
<script type="math/tex; mode=display">
\sum_{d|T}d*\mu(\frac{T}{d})=\sum_{d|T}id(d)*\mu(\frac{T}{d})=(\mu*id)(T)=\phi(T)</script><p>所以，原式就变成了：</p>
<script type="math/tex; mode=display">
\sum_{T=1}^nsum(\frac{n}{T})^2*T^2*\phi(T)</script><p>由于<script type="math/tex">sum(\frac{n}{T})^2</script>可以用整除分块和预处理算出，所以我们要用杜教筛算的就是：</p>
<script type="math/tex; mode=display">
\sum_{T=1}^nT^2*\phi(T)\\
即\sum_{i=1}^ni^2*\phi(i)</script><p>我们设:</p>
<script type="math/tex; mode=display">
f(i)=i^2*\phi(i)\\
g(i)=i^2\\
这些函数的大写表示从1->n求和</script><p>我们考虑：</p>
<script type="math/tex; mode=display">
(f*g)(n)=\sum_{d|n}f(d)*g(n/d)=\sum_{d|n}d^2*\phi(d)*\frac{n^2}{d^2}\\
=n^2*\sum_{d|n}\phi(d)=n^3</script><p>我们设：</p>
<script type="math/tex; mode=display">
h(n)=n^3,则\\
\sum_{i=1}^n(f*g)(i)=\sum_{i=1}^nh(i)=H(n)\\</script><p>从另一方面考虑：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n(f*g)(i)=\sum_{i=1}^ng(i)*\sum_{j=1}^{n/i}f(i)=\sum_{i=1}^ni^2*F(n/i)</script><p>所以：</p>
<script type="math/tex; mode=display">
H(n)=\sum_{i=1}^ni^2*F(n/i)\\
移项可得：F(n)=H(n)-\sum_{i=2}^ni^2*F(n/i)\\
=sum(n)^2-\sum_{i=2}^ni^2*F(n/i)</script><p>这样，答案就可以求出来了。</p>
<p>呼，数论题真的就是推式子啊。。。</p>
<p><strong>注意：有的式子要先把n模一下，不然会爆long long</strong></p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN=<span class="number">5e6</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,mod;</span><br><span class="line"><span class="keyword">int</span> prime[maxN+<span class="number">10</span>],tot;</span><br><span class="line"><span class="keyword">int</span> phi[maxN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> flag[maxN+<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> sumf[maxN+<span class="number">10</span>],inv2,inv6;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; f;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x&amp;<span class="number">1</span>) ans=ans*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxN;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag[i]) prime[++tot]=i,phi[i]=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot&amp;&amp;i*prime[j]&lt;=maxN;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            flag[prime[j]*i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]) phi[prime[j]*i]=phi[i]*phi[prime[j]]%mod;<span class="comment">//i,prime[j]互质积性函数直接乘 </span></span><br><span class="line">            <span class="keyword">else</span> &#123;phi[prime[j]*i]=phi[i]*prime[j]%mod; <span class="keyword">break</span>;&#125;<span class="comment">//i是prime[j]的倍数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxN;i++) sumf[i]=phi[i]*i%mod*i%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxN;i++) sumf[i]=(sumf[i]+sumf[i<span class="number">-1</span>])%mod;</span><br><span class="line">    inv6=<span class="built_in">pow</span>(<span class="number">6</span>,mod<span class="number">-2</span>);</span><br><span class="line">    inv2=<span class="built_in">pow</span>(<span class="number">2</span>,mod<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sum1</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x%=mod;</span><br><span class="line">    <span class="keyword">return</span> x*(x+<span class="number">1</span>)%mod*inv2%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sum2</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x%=mod;</span><br><span class="line">    <span class="keyword">return</span> x*(x+<span class="number">1</span>)%mod*(<span class="number">2</span>*x+<span class="number">1</span>)%mod*inv6%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=maxN) <span class="keyword">return</span> sumf[n];</span><br><span class="line">    <span class="keyword">if</span>(f.<span class="built_in">count</span>(n)) <span class="keyword">return</span> f[n];</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">2</span>,ans=<span class="built_in">sum1</span>(n);</span><br><span class="line">    ans=ans*ans%mod;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=n/i,k=n/j;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="built_in">sum2</span>(k)-<span class="built_in">sum2</span>(i<span class="number">-1</span>);</span><br><span class="line">        tmp=(tmp%mod+mod)%mod;</span><br><span class="line">        ans=((ans-tmp*<span class="built_in">solve</span>(j)%mod)%mod+mod)%mod;</span><br><span class="line">        i=k+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n]=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=n/i,k=n/j;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="built_in">sum1</span>(j);</span><br><span class="line">        sum=sum*sum%mod;</span><br><span class="line">        ans=(ans+sum*((<span class="built_in">solve</span>(k)-<span class="built_in">solve</span>(i<span class="number">-1</span>))%mod+mod)%mod)%mod;</span><br><span class="line">        i=k+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> int</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;mod,&amp;n);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈高维前缀和</title>
    <url>/2019/07/26/%E6%B5%85%E8%B0%88%E9%AB%98%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    <content><![CDATA[<h1 id="高维前缀和"><a href="#高维前缀和" class="headerlink" title="高维前缀和"></a>高维前缀和</h1><p>什么是高维前缀和？其实，高维前缀和是用来计算子集和的问题的，也就是</p>
<script type="math/tex; mode=display">
ans[S]=\sum_{T\subset S}a[T]</script><span id="more"></span>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>我们举个例子，比如我们如果要求二维前缀和，我们可以这样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        a[i][j] += a[i - <span class="number">1</span>][j] + a[i][j - <span class="number">1</span>] - a[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>但我们也可以这样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) a[i][j] += a[i][j - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) a[i][j] += a[i - <span class="number">1</span>][j];</span><br></pre></td></tr></table></figure>
<p>看起来多了一重，但实际上并非如此。</p>
<p>在更高维的情况下，如果采用上面的容斥方法，时间复杂度是<script type="math/tex">O(n2^d)</script>，其中<script type="math/tex">d</script>是维度。</p>
<p>但用后者，时间复杂度是<script type="math/tex">O(nd)</script>。</p>
<p>显然后者更优秀。</p>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>给一个模板吧</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); j++)</span><br><span class="line">        <span class="keyword">if</span>(j &amp; (<span class="number">1</span> &lt;&lt; i)) f[j] += f[j ^ (<span class="number">1</span> &lt;&lt; i)];</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
</search>
