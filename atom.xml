<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cmwqf&#39;s blog</title>
  
  
  <link href="http://cmwqf.github.io/atom.xml" rel="self"/>
  
  <link href="http://cmwqf.github.io/"/>
  <updated>2024-03-06T06:29:00.641Z</updated>
  <id>http://cmwqf.github.io/</id>
  
  <author>
    <name>cmwqf</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈莫队算法</title>
    <link href="http://cmwqf.github.io/2021/07/20/%E6%B5%85%E8%B0%88%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/"/>
    <id>http://cmwqf.github.io/2021/07/20/%E6%B5%85%E8%B0%88%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/</id>
    <published>2021-07-20T11:43:06.000Z</published>
    <updated>2024-03-06T06:29:00.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="普通莫队"><a href="#普通莫队" class="headerlink" title="普通莫队"></a>普通莫队</h1><p>莫队，是一种算法，是国家队长莫涛发明的，它是来解决什么问题的呢？</p><p>我们常常会遇到这样一类题：给你一个<script type="math/tex">[1,n]</script>的序列，每次查询<script type="math/tex">[l,r]</script>的一些信息（例如不同数的个数等），这个时候，我们就可以使用莫队来解决。</p><span id="more"></span><p>注意，莫队是一种离线算法。</p><p>我们考虑，当我们知道<script type="math/tex">[l1,r1]</script>的值时，我们要计算出<script type="math/tex">[l2,r2]</script>的值。</p><p>我们可以<script type="math/tex">O(1)</script>地算出<script type="math/tex">[l1-1,r1],[l1+1,r1],[l1,r1-1],[l1,r1+1]</script>的值，那么，我们就可以在<script type="math/tex">O(|l2-l1|+|r2-r1|)</script>的时间复杂度内完成这次转移，即算出答案。也就是说，我们可以省去这两个询问区间的交集所需要的时间。</p><p>而我们现在要做的，就是通过一种特定的排序方式，使得对于一个询问集合<script type="math/tex">q</script>,使得<script type="math/tex">\sum_{i=1}^n(|q[i].l-q[i-1].l|+q[i].r-q[i-1].r|)</script>达到我们可以接受的值；</p><p>我们考虑用分块来优化，以<strong>左端点所在的块</strong>为第一关键字，<strong>右端点的值</strong>为第二关键字来排序，这样的时间复杂度就降到了<script type="math/tex">O(n\sqrt{m})</script>。</p><p>为什么呢？</p><p>设块大小为<script type="math/tex">B</script>。</p><p>我们考虑莫队的过程，左端点在同一个块里的操作会在一起做。我们考虑<script type="math/tex">l,r</script>指针的移动次数。先考虑块内移动，对于每个询问，左端点因为在块内移动，最多移动<script type="math/tex">B</script>次，而右端点由于对于每个块内部右端点是单调的（可能单调升也可能单调降），因此对于每个块内的所有询问，右端点的移动次数和是<script type="math/tex">O(n)</script>的。那么总复杂度就是<script type="math/tex">O(mB+\frac{n^2}{B})</script>，此时当<script type="math/tex">mB=\frac{n^2}{B}</script>，即<script type="math/tex">B=\frac{n}{\sqrt{m}}</script>时，复杂度达到理论最优，为<script type="math/tex">O(n\sqrt{m})</script>。</p><p>另外，我们在comp函数中可以进行优化（奇偶块优化），即如果是奇数块就右端点升序排列，否则就降序排列：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(Node a, Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> belong[a.l] ^ belong[b.l] ? belong[a.l] &lt; belong[b.l] : belong[a.l] &amp; <span class="number">1</span> ? a.r &lt; b.r : a.r &gt; b.r; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样会快很多，还有就是<script type="math/tex">B</script>的大小跟代码速度有巨大关系，实际上当<script type="math/tex">B=\frac{n}{\sqrt{\frac{2}{3}m}}</script>时，是最快的</p><h1 id="高维莫队"><a href="#高维莫队" class="headerlink" title="高维莫队"></a>高维莫队</h1><p>从本质上来看，莫队是解决偏序问题的有力武器，具体来说，对于每个点，它有若干维度，那么莫队的每个询问就是查询第一个维度<script type="math/tex">\le a_1</script>，第二个维度<script type="math/tex">\le a_2</script>，…，第<script type="math/tex">k</script>个维度<script type="math/tex">\le a_k</script>的点的集合的价值（当然，每一维也可以是<script type="math/tex">\ge</script>）。</p><p>而普通莫队，本质上是二维莫队，即它的询问形如求第一维<script type="math/tex">\ge l</script>，第二维<script type="math/tex">\le r</script>的点构成的集合的价值，而在序列上点的第一维和第二维都是这个点的位置。</p><p>为了方便起见，在以下的讨论中，我们默认对于每一维的限制都是<script type="math/tex">\le a_i</script>，并且假设是<script type="math/tex">k</script>维莫队。</p><p>那么，莫队实际上是维护了<script type="math/tex">k</script>个指针<script type="math/tex">(t_1,t_2,\dots,t_k)</script>，而每次操作形如<script type="math/tex">add(t_i)</script>或者<script type="math/tex">del(t_i)</script>，其意义在于加入/删除第<script type="math/tex">i</script>维为<script type="math/tex">t_i</script>，且对于剩下的第<script type="math/tex">j</script>（<script type="math/tex">j\neq i</script>）维均满足<script type="math/tex">a_j\le t_j</script>的点。而为什么在普通莫队中我们看不到这样的操作呢？那是由于序列操作的特殊性，使得我们无需判断这些情况。</p><p>那么，对于高维莫队，我们怎么解决呢？</p><p>以下为了方便起见，我们假设每一维的值域都是相同的<script type="math/tex">[1, n]</script>，且询问数和值域同阶，也是<script type="math/tex">n</script>。</p><p>仍然沿用二维莫队的做法，我们给前<script type="math/tex">k-1</script>维进行分块。设每一维都以<script type="math/tex">B</script>个值为一块。那么在给询问排序的时候，我们先比较第一维块的编号，若相同则比较第二维块的编号，…，若前<script type="math/tex">k-1</script>维编号都相同，那么就比较第<script type="math/tex">k</script>维的大小。</p><p>那么，这样做的复杂度是什么呢？</p><p>首先，考虑第<script type="math/tex">k</script>维指针的移动次数。一共有<script type="math/tex">(\frac{n}{B})^{k-1}</script>种不同的块，而每个块我们都要在第<script type="math/tex">k</script>维遍历一遍，因此这一部分的复杂度是<script type="math/tex">(\frac{n}{B})^{k-1}n</script>，即<script type="math/tex">\frac{n^k}{B^{k-1}}</script>。</p><p>然后，考虑前<script type="math/tex">k-1</script>维指针移动的次数。对于每个询问，前<script type="math/tex">k-1</script>个指针每个指针都最多移动<script type="math/tex">B</script>次，因此这一部分复杂度为<script type="math/tex">knB</script>。由于<script type="math/tex">k</script>不会很大，基本上是常数，因此我们把这一部分复杂度看成<script type="math/tex">nB</script>。</p><p>总复杂度即<script type="math/tex">\frac{n^k}{B^{k-1}}+nB</script>，那么在<script type="math/tex">B=n^{\frac{k-1}{k}}</script>时这个式子取到最小，是<script type="math/tex">O(n^{\frac{2k-1}{k}})</script>。</p><p>那么，对于高维莫队，我们有了统一的解决方法，可以发现当<script type="math/tex">k</script>过大的时候这个方法不一定有暴力优秀，因此对于这类问题，<script type="math/tex">k</script>不会很大。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>其实很多问题可以看成高维莫队问题。</p><p>例如，我们常说的带修莫队，实际上就是三维莫队，即我们多加了一维时间，表示求所有时间<script type="math/tex">\le t</script>的点的价值，此时我们取<script type="math/tex">B=n^{\frac{2}{3}}</script>最优，复杂度为<script type="math/tex">O(n^{\frac{5}{3}})</script>。</p><p>而对于一类对矩形进行统计的问题，我们可以把它看成四维莫队，即行有两维限制，列也有两维限制，那么我们只需要快速求出同一行某个区间内的价值及同一列某个区间内价值即可，此时取<script type="math/tex">B=n^{\frac{3}{4}}</script>，时间复杂度<script type="math/tex">O(n^{\frac{7}{4}})</script>。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;普通莫队&quot;&gt;&lt;a href=&quot;#普通莫队&quot; class=&quot;headerlink&quot; title=&quot;普通莫队&quot;&gt;&lt;/a&gt;普通莫队&lt;/h1&gt;&lt;p&gt;莫队，是一种算法，是国家队长莫涛发明的，它是来解决什么问题的呢？&lt;/p&gt;
&lt;p&gt;我们常常会遇到这样一类题：给你一个&lt;script type=&quot;math/tex&quot;&gt;[1,n]&lt;/script&gt;的序列，每次查询&lt;script type=&quot;math/tex&quot;&gt;[l,r]&lt;/script&gt;的一些信息（例如不同数的个数等），这个时候，我们就可以使用莫队来解决。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://cmwqf.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="莫队" scheme="http://cmwqf.github.io/tags/%E8%8E%AB%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>浅谈最小表示法</title>
    <link href="http://cmwqf.github.io/2021/04/08/%E6%B5%85%E8%B0%88%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/"/>
    <id>http://cmwqf.github.io/2021/04/08/%E6%B5%85%E8%B0%88%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/</id>
    <published>2021-04-08T03:12:27.000Z</published>
    <updated>2024-03-06T06:29:00.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定一个字符串<script type="math/tex">s</script>，求它的一个循环表示（即每次只能把字符串的开头字符删掉并插入到结尾），使得其是该字符串所有循环表示中字典序最小的一个。</p><span id="more"></span><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先，设原字符串的长度为<script type="math/tex">n</script>，然后我们将字符串倍长。</p><p>考虑我们有两个指针<script type="math/tex">i,j</script>表示候选位置，现在我们想比较这两个位置谁更优秀。</p><p>那么暴力就是我们枚举长度<script type="math/tex">k</script>，如果存在<script type="math/tex">s[i+k]>s[j+k]</script>就让<script type="math/tex">i++</script>，如果<script type="math/tex">s[i+k]<s[j+k]</script>就让<script type="math/tex">j++</script>，并且让<script type="math/tex">k=0</script>。如果相等就继续往后枚举，即<script type="math/tex">k++</script>。</p><p>特别地，如果某次移动后发现<script type="math/tex">i==j</script>，那么我们让<script type="math/tex">j++</script>。</p><p>如果<script type="math/tex">i</script>和<script type="math/tex">j</script>开头的字符串相等，即<script type="math/tex">k</script>一直枚举到了<script type="math/tex">n</script>，这说明该字符串可以看成由一个长度为<script type="math/tex">len=|j-i|</script>的字符串（假设为<script type="math/tex">t</script>）复制若干次形成（最后一块可能不是整块），换句话说，我们可以看成有一个无限的由<script type="math/tex">t</script>不断复制得到的字符串，那么原字符串就是在这个无限字符串中截取一个长度为<script type="math/tex">n</script>的字符串得来的。</p><p>那么，这说明了什么呢？这说明该字符串本质不同的循环同构串只有<script type="math/tex">len</script>种。根据我们的算法，我们发现<script type="math/tex">i<j</script>，那么说明本质不同的循环同构串只有以<script type="math/tex">i,i+1,\dots,j-1</script>为开头的<script type="math/tex">len</script>个。而既然已经枚举到了<script type="math/tex">j</script>，那么说明以<script type="math/tex">i</script>开头的字符串是<script type="math/tex">i,i+1,\dots,j-1</script>这<script type="math/tex">len</script>个字符串中最小的一个，因此它就是答案。</p><p>这样，最后的答案就是<script type="math/tex">i</script>。</p><p>然后我们发现这个暴力是可以优化的，因为如果<script type="math/tex">s[i+k]>s[j+k]</script>，那么<script type="math/tex">i+1\sim i+k</script>都不可能作为答案，因为对于<script type="math/tex">1\le p\le k</script>，考虑<script type="math/tex">i+p</script>开头的字符串，总有<script type="math/tex">j+p</script>开头的字符串比它优，因此我们可以直接让<script type="math/tex">i+=k+1</script>即可。</p><p>但是这样我们就不能保证<script type="math/tex">i<j</script>，因此最后的答案是<script type="math/tex">\min(i,j)</script>。</p><p>时间复杂度为<script type="math/tex">O(n)</script>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> s[maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>( !<span class="built_in">isdigit</span>( ch ) ) &#123; <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">isdigit</span>( ch ) ) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> num * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)s[i] = s[i + n] = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">2</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n &amp;&amp; j &lt;= n &amp;&amp; k &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i + k] == s[j + k]) k ++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i + k] &gt; s[j + k]) i += k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> j += k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i == j) j ++;</span><br><span class="line">            k = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">min</span>(i, j);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= x + n - <span class="number">1</span>; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, s[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;给定一个字符串&lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;，求它的一个循环表示（即每次只能把字符串的开头字符删掉并插入到结尾），使得其是该字符串所有循环表示中字典序最小的一个。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://cmwqf.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="字符串" scheme="http://cmwqf.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>AGC030F Permutation and Minimum</title>
    <link href="http://cmwqf.github.io/2021/03/01/AGC030F-Permutation-and-Minimum/"/>
    <id>http://cmwqf.github.io/2021/03/01/AGC030F-Permutation-and-Minimum/</id>
    <published>2021-03-01T07:16:05.000Z</published>
    <updated>2024-03-06T06:29:00.634Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>对于<script type="math/tex">2n</script>个数的排列<script type="math/tex">p</script>，定义其生成数列<script type="math/tex">g_i=\min(p_{2i-1},p_{2i})\quad\forall 1\le i\le n</script>。现在有一个<script type="math/tex">2n</script>个数的排列，其中有一些位置还不确定，问在所有合法的填法中，能生成的不同的<script type="math/tex">g</script>的个数，答案对<script type="math/tex">1e9+7</script>取模。</p><p>两个<script type="math/tex">g</script>不同当且仅当存在<script type="math/tex">1\le i\le n</script>，使得<script type="math/tex">g1_i\neq g2_i</script>。</p><p>其中<script type="math/tex">1\le n\le 300</script>。</p><span id="more"></span><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Tip1"><a href="#Tip1" class="headerlink" title="Tip1"></a>Tip1</h2><p>这类问题可以形式化地表述为：我们有一个<script type="math/tex">f</script>，根据一些操作变成<script type="math/tex">g</script>，我们要数<script type="math/tex">g</script>的个数。</p><p>这种问题的麻烦处在于，如果只数<script type="math/tex">f</script>，会把<script type="math/tex">g</script>算重，如果只数<script type="math/tex">g</script>，有些<script type="math/tex">g</script>是不合法的，会算多。</p><p>那么，我们就是要在<script type="math/tex">g</script>和<script type="math/tex">f</script>中建立一个桥梁，即一个构造方法（很多时候是贪心），使得每个合法的<script type="math/tex">g_0</script>通过构造能得到唯一一个合法的<script type="math/tex">f_0</script>，且这个<script type="math/tex">f_0</script>通过原来的操作变成的序列为<script type="math/tex">g_0</script>。</p><p>我们考虑对<script type="math/tex">g</script>序列进行<script type="math/tex">dp</script>，同时<script type="math/tex">dp</script>状态维护当前<script type="math/tex">g</script>经过构造形成的<script type="math/tex">f</script>的必要参数。最后，只要<script type="math/tex">f</script>的参数表明构造出了合法的<script type="math/tex">f</script>，那么<script type="math/tex">g</script>也是合法的。也就是说，最后把所有表示<script type="math/tex">f</script>合法的<script type="math/tex">dp</script>值加起来即可。</p><hr><p>现在考虑本题。</p><p>显然，本题中的<script type="math/tex">f</script>就是<script type="math/tex">n</script>个二元组组成的序列，<script type="math/tex">g</script>就是题目所述的生成序列。</p><p>可以发现，本题的<script type="math/tex">n</script>个二元组可以分为<script type="math/tex">3</script>种类型，分别为<script type="math/tex">(0,-1),(-1,-1),(0,0)</script>，其中<script type="math/tex">0</script>表示给定的数，<script type="math/tex">-1</script>表示可以随便填的数。可以发现，<script type="math/tex">(0,0)</script>对答案没用，因此可以忽略它。</p><p>那么，我们把所有形如<script type="math/tex">(0,-1)</script>的分为一类，设为<script type="math/tex">A</script>，所有<script type="math/tex">(-1,-1)</script>的分为一类，设为<script type="math/tex">B</script>。</p><p>我们考虑通过一个合法的<script type="math/tex">g</script>构造出唯一的相应的<script type="math/tex">f</script>。</p><p>注意到因为我们统计的是<script type="math/tex">g</script>的个数，因此每个二元组内部交换顺序，<script type="math/tex">g</script>不变，那么我们不妨假设<script type="math/tex">f</script>中所有二元组<script type="math/tex">(a_i,b_i)</script>都满足<script type="math/tex">a_i<b_i</script>。</p><p>考虑从小到大枚举数。</p><p>如果这个数是已经给定的，那么直接放到它对应的二元组去，如果那个二元组还没有数，就填在左边，否则填在右边（为了满足<script type="math/tex">a_i<b_i</script>）。</p><p>如果这个数不是给定的，那么有两种情况：第一种，它出现在<script type="math/tex">g</script>中，即它是某个二元组的最小值，那么我们把它填在其在<script type="math/tex">g</script>出现位置的那个二元组的左边。否则，如果它不出现在<script type="math/tex">g</script>中，那么说明它是某个二元组的最小值，那么考虑当前所有<strong>已经填了左边数且右边数不是给定的二元组</strong>，实际上它可以放在这些二元组中的任何一个，但是由于我们要求构造出唯一的一个<script type="math/tex">f</script>，不难想到将它填在其中左边数字最小的那个二元组中。</p><p>如此构造出相应的<script type="math/tex">f</script>。</p><p>可以发现，一个合法的<script type="math/tex">g</script>唯一对应一个操作序列，而一个操作序列也唯一对应一个合法的<script type="math/tex">g</script>（因为构造出来的<script type="math/tex">f</script>唯一对应一个<script type="math/tex">g</script>）。</p><p>那么我们现在考虑如何<script type="math/tex">dp</script>。</p><p>考虑如果我们想要完成这个操作序列需要知道什么？</p><p>首先如果这个数已经给定，那么它填的位置已经确定，所以不需要知道信息。</p><p>如果这个数没有被给定，那么它需要知道什么信息呢？如果它出现在<script type="math/tex">g</script>中，那么我们需要知道有多少个二元组一个数都没填，然后选一个填下去。否则，如果它不出现在<script type="math/tex">g</script>中，那么我们需要知道有多少个二元组已经填了左边数且右边数不是给定的。因此，我们一共需要这两个状态。</p><p>根据这个进行<script type="math/tex">dp</script>，问题似乎解决了？？</p><p>但是，我们很快发现这个做法有些问题。在这个算法中，可能出现我们填已经<strong>给定的数</strong>的时候，如果我们决定填左边，而实际上左边已经被填过了。又或者如果我们准备填右边，而实际上这个二元组左边还没有被填。这个时候，<script type="math/tex">g</script>已经不合法了，但还是被我们统计到了答案里。</p><p>如果还是考虑<strong>给定的数</strong>能否填，似乎只有记录所有<script type="math/tex">A</script>中二元组的状态？这是无法接受的。</p><p>既然无法考虑<strong>给定的数</strong>能否填，不如在填<strong>没给定的数</strong>的时候决定它应该和哪个进行配对，然后再考虑<strong>给定的数</strong>的时候在一个固定的集合里选择。</p><p>具体地，我们在状态中记录一维表示当前有多少个<strong>没给定的数</strong>决定以后和<strong>给定的数</strong>配对。那么每次填<strong>给定的数</strong>的时候，如果它想放在后面（不出现在<script type="math/tex">g</script>中）的话，就在这些数中选一个进行配对即可。</p><h2 id="Tip2"><a href="#Tip2" class="headerlink" title="Tip2"></a>Tip2</h2><p>这是一个很常用的思想，即当我们按照一定顺序进行<script type="math/tex">dp</script>，选出来一些元素要放在某些位置，但是如果在选出来这个元素的同时决定它放在哪个位置会影响后面的选择，那么不如先把它放入一个候选集合中，等到需要它的时候再拿出来即可。</p><hr><p>那么，我们设<script type="math/tex">f[i][j][k]</script>表示考虑了所有<script type="math/tex">\le i</script>的数，有<script type="math/tex">j</script>个数决定和<strong>给定的数</strong>配对，有<script type="math/tex">k</script>个数决定和<strong>没给定的数</strong>配对的方案数。</p><p>但是，这样还有一个问题，如果我们当前考虑的数是<strong>没给定的</strong>，而我们想填在<script type="math/tex">B</script>组的左边，那么我们还要记录当前有多少个还没被填的<script type="math/tex">B</script>组，来进行选择。</p><p>这样，时间复杂度又不对了。注意到实际上<script type="math/tex">B</script>组中的二元组是可以交换的，那么我们不妨假设所有<script type="math/tex">B</script>组二元组满足<script type="math/tex">a_1<a_2<\dots<a_k</script>（其中<script type="math/tex">k</script>是<script type="math/tex">B</script>组的大小），最后乘以<script type="math/tex">k!</script>即可。</p><p>因此，当我们把<strong>没给定的数</strong>填到<script type="math/tex">B</script>组的左边时无需考虑具体填到哪个二元组，因为它会自动填在当前所有已经填了左边数的<script type="math/tex">B</script>组二元组的后面那个二元组中。</p><p>接下来，转移过程就很简单了。设当前考虑<script type="math/tex">f[i][j][k]</script>能往哪些地方转移。</p><p>如果它是<strong>给定的</strong>：</p><p>第一种情况，想让它在<script type="math/tex">g</script>中出现，那么它后面一定配对一个<strong>没给定的数</strong>，那么<script type="math/tex">f[i+1][j][k+1]+=f[i][j][k]</script>。</p><p>第二种情况，它不在<script type="math/tex">g</script>中出现，那么在候选集合中选一个，<script type="math/tex">f[i+1][j-1][k]+=f[i][j][k]\times j</script>。</p><p>如果它是<strong>没给定的</strong>：</p><p>第一种情况，想让它在<script type="math/tex">g</script>中出现，那么它后面既可以配对<strong>给定的</strong>，也可以配对<strong>没给定的</strong>，因此<script type="math/tex">f[i+1][j+1][k]+=f[i][j][k],f[i+1][j][k+1]+=f[i][j][k]</script>。</p><p>第二种情况，不在<script type="math/tex">g</script>中出现，那么和配对集合中数字最小的那个配对，即<script type="math/tex">f[i+1][j][k-1]+=f[i][j][k]</script>。</p><p>最后的答案是<script type="math/tex">f[2n][0][0]\times k!</script>。</p><p>为什么这两个状态都是<script type="math/tex">0</script>就一定符合条件呢？这个状态中丝毫没有用到<script type="math/tex">A</script>组和<script type="math/tex">B</script>组的集合大小，会不会最后构造出来的<script type="math/tex">f</script>两个集合大小和原来不相等呢？</p><p>不会，因为在去除了两边都给定的二元组的情况下，只需要知道有多少个数字给定，多少个数字没给定，就能推出<script type="math/tex">A</script>和<script type="math/tex">B</script>的大小。而这两个状态都是<script type="math/tex">0</script>，说明这<script type="math/tex">2n</script>个数已经合法地填满了所有的二元组，自然满足条件。</p><p>时间复杂度<script type="math/tex">O(n^3)</script>。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">305</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, s;</span><br><span class="line"><span class="keyword">int</span> flag[maxN * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>][maxN + <span class="number">1</span>][maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123; x = x + y &gt;= mod ? x + y - mod : x + y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span>(x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123; flag[x] = flag[y] = <span class="number">2</span>; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; <span class="number">0</span>) flag[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(y &gt; <span class="number">0</span>) flag[y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) s ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    f[now][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        now ^= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(f[now], <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f[now]));</span><br><span class="line">        <span class="keyword">if</span>(flag[i] == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n; k++)</span><br><span class="line">                    f[now][j][k] = f[now ^ <span class="number">1</span>][j][k];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!f[now ^ <span class="number">1</span>][j][k]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> res = f[now ^ <span class="number">1</span>][j][k];</span><br><span class="line">                <span class="keyword">if</span>(!flag[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">update</span>(f[now][j + <span class="number">1</span>][k], res);</span><br><span class="line">                    <span class="built_in">update</span>(f[now][j][k + <span class="number">1</span>], res);</span><br><span class="line">                    <span class="keyword">if</span>(j) <span class="built_in">update</span>(f[now][j - <span class="number">1</span>][k], res);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">update</span>(f[now][j + <span class="number">1</span>][k], res);</span><br><span class="line">                    <span class="keyword">if</span>(k) <span class="built_in">update</span>(f[now][j][k - <span class="number">1</span>], <span class="number">1ll</span> * res * k % mod);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = f[now][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s; i++) ans = <span class="number">1ll</span> * ans * i % mod;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以后我们遇到这类计数”由某个操作生成的序列“的问题，首先考虑判定问题：一个序列能否被生成？</p><p>如果这个问题可以在这个序列上从头到尾遍历的同时用贪心解决，且贪心过程所用到的信息（称为贪心参数）是<script type="math/tex">O(1)</script>的，那么我们就可以从头到尾以这些信息作为状态进行<script type="math/tex">dp</script>。</p><p>我们的思想实际上是对<script type="math/tex">g</script>进行<script type="math/tex">dp</script>，但是有的<script type="math/tex">g</script>是不合法的，因此我们在状态中加入可以判定是否合法的贪心参数，最后对所有合法的答案累加。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;对于&lt;script type=&quot;math/tex&quot;&gt;2n&lt;/script&gt;个数的排列&lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;，定义其生成数列&lt;script type=&quot;math/tex&quot;&gt;g_i=\min(p_{2i-1},p_{2i})\quad\forall 1\le i\le n&lt;/script&gt;。现在有一个&lt;script type=&quot;math/tex&quot;&gt;2n&lt;/script&gt;个数的排列，其中有一些位置还不确定，问在所有合法的填法中，能生成的不同的&lt;script type=&quot;math/tex&quot;&gt;g&lt;/script&gt;的个数，答案对&lt;script type=&quot;math/tex&quot;&gt;1e9+7&lt;/script&gt;取模。&lt;/p&gt;
&lt;p&gt;两个&lt;script type=&quot;math/tex&quot;&gt;g&lt;/script&gt;不同当且仅当存在&lt;script type=&quot;math/tex&quot;&gt;1\le i\le n&lt;/script&gt;，使得&lt;script type=&quot;math/tex&quot;&gt;g1_i\neq g2_i&lt;/script&gt;。&lt;/p&gt;
&lt;p&gt;其中&lt;script type=&quot;math/tex&quot;&gt;1\le n\le 300&lt;/script&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Atcoder" scheme="http://cmwqf.github.io/categories/Atcoder/"/>
    
    
    <category term="dp" scheme="http://cmwqf.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>CF1307G Cow and Exercise</title>
    <link href="http://cmwqf.github.io/2021/02/22/CF1307G-Cow-and-Exercise/"/>
    <id>http://cmwqf.github.io/2021/02/22/CF1307G-Cow-and-Exercise/</id>
    <published>2021-02-22T07:56:11.000Z</published>
    <updated>2024-03-06T06:29:00.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定<script type="math/tex">n</script>个点<script type="math/tex">m</script>条边的有向图（无重边自环），每条边有边权。</p><p>一共<script type="math/tex">q</script>次询问，每次给定一个数<script type="math/tex">x_i</script>，我们可以增加某些边的边权，要求在总增加量不超过<script type="math/tex">x_i</script>的前提下让<script type="math/tex">1</script>到<script type="math/tex">n</script>的最短路最大，问这个最大值是多少。</p><p>其中<script type="math/tex">2\le n\le 50,1\le m\le n(n-1),q\le 10^5</script>。</p><span id="more"></span><h1 id="线性规划对偶性"><a href="#线性规划对偶性" class="headerlink" title="线性规划对偶性"></a>线性规划对偶性</h1><p><strong>什么是线性规划？</strong></p><p>我们有<script type="math/tex">n</script>个变量<script type="math/tex">x_1,x_2,\dots,x_n</script>，然后有<script type="math/tex">m</script>条限制，第<script type="math/tex">i</script>条限制为</p><script type="math/tex; mode=display">\sum_{j=1}^na_{j,i}x_j\le c_i</script><p>我们的目标是求</p><script type="math/tex; mode=display">\max \sum_{i=1}^nb_ix_i</script><p>上面的<script type="math/tex">\le</script>可以取反，<script type="math/tex">\max</script>也可以变成<script type="math/tex">\min</script>。</p><p>这一类问题称为线性规划问题，在<script type="math/tex">OI</script>中一般采用单纯形进行解决。但是，有许多线性规划问题由于问题本身的特殊性可以用网络流解决。</p><p><strong>那么，线性规划的对偶问题又是什么呢？</strong></p><p>对于上面这个线性规划，其对偶问题为</p><p>我们有<script type="math/tex">m</script>个变量<script type="math/tex">y_1,y_2,\dots,y_m</script>，有<script type="math/tex">n</script>条限制，第<script type="math/tex">i</script>条限制为</p><script type="math/tex; mode=display">\sum_{j=1}^ma_{i,j}y_j\ge b_i</script><p>目标是</p><script type="math/tex; mode=display">\min \sum_{i=1}^mc_iy_i</script><p><strong>那么，如何直观地理解对偶问题呢？</strong></p><p>实际上，我们可以从经济学的角度理解对偶问题。</p><p>为了方便起见，不妨设原问题为问题<script type="math/tex">a</script>，其对偶问题为问题<script type="math/tex">b</script>。</p><p>有两个公司<script type="math/tex">A,B</script>，其中，<script type="math/tex">A</script>公司是制作产品的，<script type="math/tex">B</script>公司是回收原料的。</p><p>现在，有<script type="math/tex">n</script>个产品，<script type="math/tex">m</script>种原料，第<script type="math/tex">i</script>个产品需要用<script type="math/tex">a_{i,j}</script>个第<script type="math/tex">j</script>种原料。<script type="math/tex">c_i</script>表示第<script type="math/tex">i</script>种原料有<script type="math/tex">c_i</script>个，<script type="math/tex">b_i</script>表示第<script type="math/tex">i</script>种产品的利润为每个<script type="math/tex">b_i</script>元。</p><p>问题<script type="math/tex">a</script>是对于<script type="math/tex">A</script>公司而言的，公司<script type="math/tex">A</script>要选择每种产品制作多少个，它的目标是在满足要求的情况下总利润最大。设它决定第<script type="math/tex">i</script>个产品制作<script type="math/tex">x_i</script>个，那么<script type="math/tex">A</script>公司制作产品一定要满足原料的个数在限制范围内，即</p><script type="math/tex; mode=display">\sum_{j=1}^na_{j,i}x_j\le c_i</script><p>它所希望的总利润最大即</p><script type="math/tex; mode=display">\max \sum_{i=1}^nb_ix_i</script><p>而问题<script type="math/tex">b</script>是针对<script type="math/tex">B</script>公司而言的，现在<script type="math/tex">B</script>公司想要从<script type="math/tex">A</script>公司手中收购原材料，那么显然它要向<script type="math/tex">A</script>公司报价。设第<script type="math/tex">i</script>种材料的报价为<script type="math/tex">y_i</script>。而<script type="math/tex">A</script>公司也不傻，它同意这个报价当且仅当对于每一种产品，其原材料卖给<script type="math/tex">B</script>公司的收益不小于产品的利润（否则，不如不卖这些原材料，做成产品，收益更大）。而<script type="math/tex">B</script>公司的目标自然是最小化购入成本。</p><p>那么，<script type="math/tex">A</script>公司同意的条件为</p><script type="math/tex; mode=display">\sum_{j=1}^m a_{i,j}y_j\ge b_i</script><p>而<script type="math/tex">B</script>公司希望的最小化成本为</p><script type="math/tex; mode=display">\min \sum_{i=1}^mc_iy_i</script><p>这样，我们就能很直观地看出对偶问题的关系。可以发现，这两个问题是互为对偶的。</p><p><strong>那么，这两个问题有什么性质？</strong></p><p>这里，我们不加证明地给出线性规划的对偶性：</p><script type="math/tex; mode=display">\max \sum_{i=1}^nb_ix_i=\min \sum_{i=1}^mc_iy_i</script><p>感性理解一下也是可以的：如果前者更大，那么<script type="math/tex">A</script>公司为什么要进行这个交易来减少收益呢？显然不合理。如果后者更大，那么<script type="math/tex">A</script>公司为什么要制作产品，倒手卖原材料岂不更好？因此，两者只能相等。</p><p>但是注意，虽然上述理解过程中我们以产品，材料来便于理解，但实际上<script type="math/tex">x_i,y_i,c_i,d_i,a_{i,j}</script>不一定是整数，甚至不一定是正数，在实际应用中不要混淆。</p><p>线性规划的对偶性让我们可以把<script type="math/tex">\max</script>转为<script type="math/tex">\min</script>，也可以把较复杂的问题简化，从而有利于解题。当我们看到一个线性规划问题十分复杂困难时，也许其对偶问题比较简单。</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>这道题看起来十分不可做的样子，但是无法暴力以及较小的数据范围启发我们往线性规划的方面想。</p><p>注意到最短路是可以转化为线性规划的形式的。设<script type="math/tex">d_u</script>为<script type="math/tex">1</script>到<script type="math/tex">u</script>的最短路，那么原问题可以形式化地写为：</p><p>我们有如下条件</p><script type="math/tex; mode=display">d_u+val_{u,v}+c_{u,v}\ge d_v\\d_u,c_{u,v}\ge 0</script><p>其中<script type="math/tex">val_{u,v}</script>为边的长度，<script type="math/tex">c_{u,v}</script>为边增加的长度。</p><p>原本还有条件应该是<script type="math/tex">\sum c_{u,v}\le x_i</script>，但是注意到询问非常多，如果限制与<script type="math/tex">x_i</script>有关的话应该不太行。这种有那么多询问的题目应该是每次询问在一个特定的候选集合中找符合条件的。</p><p>因此我们考虑对于某个答案<script type="math/tex">D</script>，求出其所需要的最小的<script type="math/tex">\sum c_{u,v}</script>。</p><p>那么限制为</p><script type="math/tex; mode=display">d_u-d_v+c_{u,v}\ge -val_{u,v}\\d_n-d_1\ge D\\d_u,c_{u,v}\ge 0\\</script><p>我们要求出</p><script type="math/tex; mode=display">\min \sum c_{u,v}</script><p>在这个问题中一共有<script type="math/tex">n+m</script>个变量，分别为<script type="math/tex">d_1,\dots,d_n</script>以及<script type="math/tex">c_{u,v}</script>。</p><p>考虑这个问题的对偶问题，设<script type="math/tex">F</script>为上面第二个条件对偶后的变量，</p><p>则限制为</p><script type="math/tex; mode=display">\left\{\begin{array}{lr}\sum y_{u,v}-\sum y_{v,u}-F\le 0, & u=1\\\sum y_{u,v}-\sum y_{v,u}\le 0, & \forall u=2,\dots,n-1\\\sum y_{u,v}-\sum y_{v,u}+F\le 0, & u=n\\y_{u,v}\le 1, & \forall(u,v)\in E\end{array}\right.</script><p>而我们的目标是</p><script type="math/tex; mode=display">\max D\times F-\sum y_{u,v}val_{u,v}</script><p>观察限制，我们断言，</p><script type="math/tex; mode=display">\forall 1<u<n,\sum y_{u,v}=\sum y_{v,u}\\u=1,\sum y_{u,v}=\sum y_{v,u}+F\\u=n,\sum y_{u,v}=\sum y_{v,u}-F</script><p>为什么呢？我们把前三个限制组成的不等式全部相加，因为这是一张图，那么不等式左边和不等式右边都是<script type="math/tex">0</script>，说明不等式是取等的。那么对于每个不等式都是取等的。</p><p>观察这个性质，很明显，这个相当于以<script type="math/tex">1</script>为源点，<script type="math/tex">n</script>为汇点的网络流，<script type="math/tex">y_{u,v}</script>为<script type="math/tex">(u,v)</script>的流量，对于<script type="math/tex">1<u<n</script>满足流量守恒，而<script type="math/tex">F</script>是整个网络的流量。每条边的流量上界为<script type="math/tex">1</script>。</p><p>那么对于一个<script type="math/tex">D</script>，我们只需要检查所有<script type="math/tex">F</script>与<script type="math/tex">y_{u,v}</script>的取值中使得<script type="math/tex">D\times F-\sum y_{u,v}val_{u,v}</script>最大的那一个是否<script type="math/tex">\le x_i</script>即可。</p><p>对于一个固定的<script type="math/tex">F</script>，后面的<script type="math/tex">\sum y_{u,v}val_{u,v}</script>最小值显然是以<script type="math/tex">val_{u,v}</script>为代价的最小费用流，因此我们只需要对于每个<script type="math/tex">F</script>，求出最小费用流，每次询问的时候逐一检查即可。</p><p>但是我们显然不能枚举<script type="math/tex">D</script>，我们只需要枚举所有二元组<script type="math/tex">(F,C)</script>，此时<script type="math/tex">D\le \frac{x_i+C}{F}</script>，对此取<script type="math/tex">\min</script>即可。</p><p>注意到<script type="math/tex">F</script>只有<script type="math/tex">O(n)</script>种取值，因此每次检查的时间复杂度为<script type="math/tex">O(n)</script>，总时间复杂度为<script type="math/tex">O(nq)</script>。</p><p>实际上根据费用流一些结论，这<script type="math/tex">n</script>个取值构成凸壳，可以在凸壳上二分，但是本题并不需要。</p><p>对于每个<script type="math/tex">F</script>求费用流可以建立超级源汇，往<script type="math/tex">1</script>和<script type="math/tex">n</script>连流量为<script type="math/tex">F</script>的边跑最小费用最大流，但这是不必要的。考虑求费用流的过程，如果每次增广单位流量，那么<script type="math/tex">F</script>的最小费用流就是<script type="math/tex">F-1</script>的最小费用流加上这次增广的结果，但是如果采用多路增广这个方法就不行了。</p><p>时间复杂度<script type="math/tex">O(maxflow+nq)</script>。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">55</span>;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, value, cost, next;</span><br><span class="line">&#125;edge[maxN * maxN * <span class="number">4</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q, cnt, s, t;</span><br><span class="line"><span class="keyword">int</span> head[maxN + <span class="number">1</span>], tot = <span class="number">1</span>, pre[maxN + <span class="number">1</span>], id[maxN + <span class="number">1</span>];</span><br><span class="line">LL dis[maxN + <span class="number">1</span>], ans[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> flag[maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> t, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++ tot] = (Node)&#123;y, t, c, head[x]&#125;; head[x] = tot;</span><br><span class="line">    edge[++ tot] = (Node)&#123;x, <span class="number">0</span>, -c, head[y]&#125;; head[y] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) dis[i] = INF, pre[i] = id[i] = <span class="number">0</span>, flag[i] = <span class="literal">false</span>;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s); dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        flag[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to, w = edge[i].cost;</span><br><span class="line">            <span class="keyword">if</span>(!edge[i].value || dis[u] + w &gt;= dis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            dis[v] = dis[u] + w;</span><br><span class="line">            pre[v] = u; id[v] = i;</span><br><span class="line">            <span class="keyword">if</span>(!flag[v]) flag[v] = <span class="literal">true</span>, q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre[t] &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MCMF</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">spfa</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">        cnt ++;</span><br><span class="line">        ans[cnt] = ans[cnt - <span class="number">1</span>] + dis[t];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> now = t; now != s; now = pre[now])</span><br><span class="line">            edge[ id[now] ].value --, edge[ id[now] ^ <span class="number">1</span> ].value ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, t;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;x, &amp;y, &amp;t);</span><br><span class="line">        <span class="built_in">add</span>(x, y, <span class="number">1</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = <span class="number">1</span>, t = n;</span><br><span class="line">    <span class="built_in">MCMF</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1e18</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) res = <span class="built_in">min</span>(res, (<span class="keyword">double</span>)(x + ans[i]) / (<span class="keyword">double</span>)(i));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在以后做题的过程中，如果题目很难下手，可以往线性规划上面想，而如果线性规划的式子可以写成如下形式：</p><p>限制为</p><script type="math/tex; mode=display">\left\{\begin{array}{lr}d_u-d_v+x_{u,v}\ge w_{u,v}\\d_u\ge 0, x_{u,v}\ge 0\end{array}\right.</script><p>目标为</p><script type="math/tex; mode=display">\min \sum c_{u,v}x_{u,v}</script><p>那么就可以对偶为费用流问题。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;给定&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;个点&lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt;条边的有向图（无重边自环），每条边有边权。&lt;/p&gt;
&lt;p&gt;一共&lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt;次询问，每次给定一个数&lt;script type=&quot;math/tex&quot;&gt;x_i&lt;/script&gt;，我们可以增加某些边的边权，要求在总增加量不超过&lt;script type=&quot;math/tex&quot;&gt;x_i&lt;/script&gt;的前提下让&lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt;到&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;的最短路最大，问这个最大值是多少。&lt;/p&gt;
&lt;p&gt;其中&lt;script type=&quot;math/tex&quot;&gt;2\le n\le 50,1\le m\le n(n-1),q\le 10^5&lt;/script&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Codeforces" scheme="http://cmwqf.github.io/categories/Codeforces/"/>
    
    
    <category term="网络流" scheme="http://cmwqf.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    <category term="线性规划" scheme="http://cmwqf.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Rikka with Game解题报告</title>
    <link href="http://cmwqf.github.io/2021/01/19/Rikka-with-Game%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <id>http://cmwqf.github.io/2021/01/19/Rikka-with-Game%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</id>
    <published>2021-01-19T07:04:15.000Z</published>
    <updated>2024-03-06T06:29:00.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有<script type="math/tex">n</script>个人玩游戏，有些人是朋友关系（用邻接矩阵给出）。</p><p>游戏开始时，先选一个人成为龙，剩下的人为勇士。</p><p>每轮游戏过程如下：每个勇士选择是否攻击龙，如果这个勇士和龙有朋友关系那么一定不会攻击。如果所有勇士都不攻击，游戏结束，龙胜利。否则龙被淘汰，且编号最小的选择攻击的勇士成为新的龙，游戏进入下一轮。</p><p>游戏结束后，被淘汰的玩家获得<script type="math/tex">1</script>分，活着的勇士获得<script type="math/tex">10</script>分，活着的龙获得<script type="math/tex">100</script>分。</p><p>假设每个玩家足够聪明，都想最大化自己分数。现在，对于每个玩家，你要回答：如果第一轮选的龙是他，他是否能获得<script type="math/tex">100</script>分。</p><p>其中<script type="math/tex">n\le 500</script>。<br><span id="more"></span></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先注意到游戏最多只会进行两轮。</p><p>因为每个玩家都足够聪明，所以每个玩家都能预测出整个游戏的过程。那么，第一轮中，一个勇士选择攻击龙当且仅当在下一轮中他能成为龙且在下一轮中获胜。</p><p>如果他选择攻击龙之后在下一轮中成为龙并且失败了，那么他只能获得<script type="math/tex">1</script>分，如果他什么都不干，能获得<script type="math/tex">10</script>分，因此只有当他确定下一轮他成为龙且必胜时，他才会选择攻击龙。</p><p>遇到这种博弈论问题，我们可以设计出<script type="math/tex">dp</script>。设<script type="math/tex">f(s,i)</script>表示勇士的集合为<script type="math/tex">s</script>，且当前龙是<script type="math/tex">i</script>，这一轮中龙能否获胜。</p><p>转移考虑枚举<script type="math/tex">s</script>中的每个元素<script type="math/tex">j</script>，如果<script type="math/tex">i,j</script>不是朋友关系，那么考虑<script type="math/tex">f(s-\{j\},j)</script>，如果它是<script type="math/tex">true</script>，即如果下一轮<script type="math/tex">j</script>成为龙能获胜，那么他就会选择攻击，<script type="math/tex">i</script>就会失败。</p><p>设朋友关系的图的补图为<script type="math/tex">G</script>，那么转移为</p><script type="math/tex; mode=display">f(s,i)=\prod_{j\in S,(i,j)\in G}[f(s-\{j\},j)=false]</script><p>即这一轮中<script type="math/tex">i</script>能获胜当且仅当所有能攻击的勇士选择攻击之后都无法获胜。</p><p>考虑观察转移形式，可以发现这个转移式类似一个经典的博弈模型：</p><p>有一张图<script type="math/tex">G</script>，<script type="math/tex">Alice</script>和<script type="math/tex">Bob</script>轮流移动棋子。一开始棋子在某个节点<script type="math/tex">u</script>，每一步可以把棋子移向任意一个与<script type="math/tex">u</script>相邻的且没有经过的点<script type="math/tex">v</script>，不能移动者算输，<script type="math/tex">Alice</script>先手。对于每个<script type="math/tex">1\le u\le n</script>，求出一开始棋子在<script type="math/tex">u</script>时<script type="math/tex">Alice</script>能否获胜。</p><p>这个问题的转移为设<script type="math/tex">f(s,i)</script>表示目前没有到过的节点集合为<script type="math/tex">s</script>，当前在节点<script type="math/tex">i</script>，先手能否获胜。</p><p>那么有</p><script type="math/tex; mode=display">f(s,i)=!(\prod_{j\in S,(i,j)\in G}[f(s-\{j\},j)=true])</script><p>其中<script type="math/tex">!</script>表示取反。可以发现，这个转移和我们原问题的转移方程差异仅在胜负的定义相反，即原问题的胜，在新问题中是负；原问题中的负，在新问题中是正。</p><p>那么，我们可以把原问题完全转化到这个新的问题上来。</p><p>这个经典问题的结论是：起点在<script type="math/tex">u</script>时先手能获胜当且仅当<script type="math/tex">u</script>出现在所有<script type="math/tex">G</script>的最大匹配中。换句话说，不存在某个<script type="math/tex">G</script>的最大匹配<script type="math/tex">M</script>，使得<script type="math/tex">u\notin M</script>。</p><p>为什么呢？</p><p>我们先证明，如果存在某个<script type="math/tex">G</script>的最大匹配<script type="math/tex">M</script>，使得<script type="math/tex">u\notin M</script>，那么先手必败。</p><p>考虑从<script type="math/tex">u</script>先随便走一条边到一个点<script type="math/tex">v</script>，那么一定有<script type="math/tex">v\in M</script>，否则<script type="math/tex">(u,v)</script>能构成一组新的匹配，原匹配不是最大匹配。那么后手只要沿着<script type="math/tex">v</script>的匹配边走即可。即<script type="math/tex">Alice</script>每次都会走一条非匹配边，<script type="math/tex">Bob</script>每次都会走一条匹配边。这样走下去，<script type="math/tex">Bob</script>必胜。因为假设某一次<script type="math/tex">Alice</script>走完一条非匹配边后，<script type="math/tex">Bob</script>没法走一条匹配边。那么回顾走过的路，是一条开头和结尾都是非匹配边的交错轨，那么如果我们把这条路上的边全部取反（即非匹配边变为匹配边，匹配边变为非匹配边），那么会获得一个更大的匹配，与最大匹配矛盾。</p><p>接下来我们要证明如果<script type="math/tex">u</script>出现在<script type="math/tex">G</script>的所有最大匹配中，先手必胜。</p><p>随便选择某个最大匹配<script type="math/tex">M</script>。<script type="math/tex">Alice</script>走的策略即每次走匹配边，<script type="math/tex">Bob</script>每次只能走非匹配边。如果存在某一步<script type="math/tex">Bob</script>走完后<script type="math/tex">Alice</script>走不了了，那么回顾走过的这条路径，一定是开头为匹配边，结尾为非匹配边的交错轨，那么我们把这条路径上的边取反，会得到一个新的最大匹配，且起点不被包含在这个最大匹配中，与假设矛盾。</p><p>那么，我们现在的问题就是对于每个点，我们要判断它是否出现在所有的最大匹配中。</p><p>先考虑如何求出一般图的最大匹配。可以考虑带花树，但是那个比较复杂。</p><p>考虑定义<script type="math/tex">tutte</script>矩阵<script type="math/tex">T</script>。对于<script type="math/tex">\forall (i,j)\in G</script>，<script type="math/tex">A_{i,j}=val_{i,j}</script>，<script type="math/tex">A_{j,i}=-val_{i,j}</script>。其中<script type="math/tex">val_{i,j}</script>是对这条边设的一个随机权值。而对于<script type="math/tex">\forall (i,j)\notin G</script>，<script type="math/tex">A_{i,j}=0</script>。</p><p>结论是：矩阵<script type="math/tex">T</script>的秩的<script type="math/tex">\frac{1}{2}</script>就是<script type="math/tex">G</script>的最大匹配数（可以证明，<script type="math/tex">T</script>的秩一定是偶数）。</p><p>具体证明和理论可以参考<script type="math/tex">2017</script>国家集训队论文：《基于线性代数的一般图匹配》（杨家齐）。此处略去。</p><p>这样，我们可以通过高斯消元在<script type="math/tex">O(n^3)</script>的时间复杂度内算出最大匹配数。</p><p>回到判定点是否在最大匹配中的问题。</p><p>一个想法是考虑删掉这个点，看剩下的图的最大匹配是否和原图最大匹配相等。如果相等，那么这个点就不会出现在所有最大匹配中。但这样时间复杂度是<script type="math/tex">O(n^4)</script>，无法接受。</p><p>假设我们考虑的点为<script type="math/tex">s</script>。</p><p>考虑新加一个点<script type="math/tex">ns</script>，并将这个点向<script type="math/tex">s</script>连一条边，那么我们只需要判断新图的最大匹配是否增加即可。因为如果存在一个最大匹配，使得<script type="math/tex">s</script>不在最大匹配中，那么<script type="math/tex">s</script>和<script type="math/tex">ns</script>能构成一组新的匹配，换句话说，会使最大匹配增加<script type="math/tex">1</script>。否则，如果对于所有的最大匹配<script type="math/tex">s</script>都在其中，因为<script type="math/tex">ns</script>只与<script type="math/tex">s</script>连边，因此最大匹配不会变化。</p><p>现在的问题就是每次考虑在原矩阵右边和下边新增一行一列，问新的矩阵的秩是否增加。每次暴力做显然无法接受，但是我们可以考虑优化。</p><p>首先考虑高斯消元是行变换，因此我们可以把新增的那一列看成原矩阵的增广矩阵，即把原矩阵扩充为<script type="math/tex">n</script>行<script type="math/tex">2n</script>列的矩阵，其中第<script type="math/tex">n+i</script>列表示的是当我们考虑第<script type="math/tex">i</script>个点为起点时向右边新增的一列，那么我们可以在对原矩阵进行高斯消元的同时对右边增广的列也做同样的变换，就可以在<script type="math/tex">O(n^3)</script>的时间复杂度内算出高斯消元后右边的列。</p><p>现在对于每个点<script type="math/tex">s</script>，先考虑如果除了以<script type="math/tex">1,2,\dots,n</script>为主元的行向量外存在某个行向量的第<script type="math/tex">n+1</script>位非零，那么就多了以<script type="math/tex">n+1</script>为主元的行向量，使得秩增加<script type="math/tex">1</script>，可以直接返回。</p><p>接下来考虑加入的一行。高斯消元是支持加入一个行向量的，具体可以考虑线性基的构造过程，我们让<script type="math/tex">i</script>从<script type="math/tex">1</script>到<script type="math/tex">n+1</script>来扫，如果加入的行向量第<script type="math/tex">i</script>个元素非零，考虑矩阵中，如果存在以这个位置为主元的向量，那么我们用这个向量去消加入的行向量，再继续往下做。否则，我们就使矩阵的秩增加了<script type="math/tex">1</script>，即可返回。</p><p>这样时间复杂度为<script type="math/tex">O(n^3)</script>，可以通过本题。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">rnd</span><span class="params">( time(<span class="literal">NULL</span>) )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">510</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ct;</span><br><span class="line"><span class="keyword">int</span> a[maxN + <span class="number">1</span>][maxN * <span class="number">2</span> + <span class="number">1</span>], id[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> b[maxN + <span class="number">1</span>][maxN + <span class="number">1</span>], v[maxN + <span class="number">1</span>], val[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">char</span> s[maxN + <span class="number">1</span>][maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123; x = x + y &gt;= mod ? x + y - mod : x + y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>) ans = <span class="number">1ll</span> * ans * a % mod;</span><br><span class="line">        a = <span class="number">1ll</span> * a * a % mod;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>j = ct + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(a[j][i]) &#123; p = j; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span>(!p) <span class="keyword">continue</span>;</span><br><span class="line">        id[i] = ++ ct;</span><br><span class="line">        <span class="keyword">if</span>(p != ct) <span class="built_in">swap</span>(a[p], a[ct]);</span><br><span class="line">        <span class="keyword">int</span> INV = <span class="built_in">mpow</span>(a[ct][i], mod - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = ct + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">1ll</span> * INV * a[j][i] % mod;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= <span class="number">2</span> * n; k++)</span><br><span class="line">                <span class="built_in">update</span>(a[j][k], mod - <span class="number">1ll</span> * a[ct][k] * t % mod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = ct + <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(b[i][n + <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!v[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!id[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">1ll</span> * v[i] * <span class="built_in">mpow</span>(b[ id[i] ][i], mod - <span class="number">2</span>) % mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= n + <span class="number">1</span>; j++)</span><br><span class="line">            <span class="built_in">update</span>(v[j], mod - <span class="number">1ll</span> * b[ id[i] ][j] * t % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[i] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(s[i][j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x = <span class="built_in">rnd</span>() % (mod - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">                a[i][j] = x; a[j][i] = mod - x;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        a[i][n + i] = val[i] = <span class="built_in">rnd</span>() % (mod - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Gauss</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            b[i][j] = a[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= n; s++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            b[i][n + <span class="number">1</span>] = a[i][n + s];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(i == s) v[i] = mod - val[s];</span><br><span class="line">            <span class="keyword">else</span> v[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="built_in">check</span>() ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;有&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;个人玩游戏，有些人是朋友关系（用邻接矩阵给出）。&lt;/p&gt;
&lt;p&gt;游戏开始时，先选一个人成为龙，剩下的人为勇士。&lt;/p&gt;
&lt;p&gt;每轮游戏过程如下：每个勇士选择是否攻击龙，如果这个勇士和龙有朋友关系那么一定不会攻击。如果所有勇士都不攻击，游戏结束，龙胜利。否则龙被淘汰，且编号最小的选择攻击的勇士成为新的龙，游戏进入下一轮。&lt;/p&gt;
&lt;p&gt;游戏结束后，被淘汰的玩家获得&lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt;分，活着的勇士获得&lt;script type=&quot;math/tex&quot;&gt;10&lt;/script&gt;分，活着的龙获得&lt;script type=&quot;math/tex&quot;&gt;100&lt;/script&gt;分。&lt;/p&gt;
&lt;p&gt;假设每个玩家足够聪明，都想最大化自己分数。现在，对于每个玩家，你要回答：如果第一轮选的龙是他，他是否能获得&lt;script type=&quot;math/tex&quot;&gt;100&lt;/script&gt;分。&lt;/p&gt;
&lt;p&gt;其中&lt;script type=&quot;math/tex&quot;&gt;n\le 500&lt;/script&gt;。&lt;br&gt;</summary>
    
    
    
    
    <category term="线性代数" scheme="http://cmwqf.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    <category term="博弈论" scheme="http://cmwqf.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>浅谈有标号的DAG计数</title>
    <link href="http://cmwqf.github.io/2021/01/01/%E6%B5%85%E8%B0%88%E6%9C%89%E6%A0%87%E5%8F%B7%E7%9A%84DAG%E8%AE%A1%E6%95%B0/"/>
    <id>http://cmwqf.github.io/2021/01/01/%E6%B5%85%E8%B0%88%E6%9C%89%E6%A0%87%E5%8F%B7%E7%9A%84DAG%E8%AE%A1%E6%95%B0/</id>
    <published>2021-01-01T11:41:55.000Z</published>
    <updated>2024-03-06T06:29:00.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>求<script type="math/tex">n</script>个点的有标号有向无环图个数，<script type="math/tex">n\le 5000</script>。</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>设<script type="math/tex">f_n</script>表示<script type="math/tex">n</script>个点的<script type="math/tex">DAG</script>个数，那么有以下递推式成立：</p><script type="math/tex; mode=display">f_n=\sum_{i=1}^n(-1)^{i+1}\binom{n}{i}2^{i(n-i)}f_{n-i}</script><p>为什么这个式子成立呢？</p><span id="more"></span><p>考虑<script type="math/tex">DAG</script>的判定是进行拓扑排序，使得每一轮都能找到有入度为<script type="math/tex">0</script>的点。我们可以根据这个思想进行递推。</p><p>对于一个<script type="math/tex">DAG</script>，一定有至少<script type="math/tex">1</script>个入度为<script type="math/tex">0</script>的点，那么我们枚举钦定有<script type="math/tex">i</script>个点入度为<script type="math/tex">0</script>，先从<script type="math/tex">n</script>个里面选出<script type="math/tex">i</script>个，那么剩下的<script type="math/tex">n-i</script>个点为<script type="math/tex">DAG</script>，然后这<script type="math/tex">i</script>个点和剩下<script type="math/tex">n-i</script>个点之间随便连边，即<script type="math/tex">2^{i(n-i)}</script>。但是，剩下的<script type="math/tex">n-i</script>个点中也有可能出现入度为<script type="math/tex">0</script>的点，因此我们需要容斥（容斥系数可以根据二项式反演推导）。</p><p>时间复杂度<script type="math/tex">O(n^2)</script>。</p><h1 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h1><p>求<script type="math/tex">n</script>个点的<script type="math/tex">DAG</script>个数，对<script type="math/tex">998244353</script>取模，<script type="math/tex">n\le 10^5</script>。</p><h1 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h1><p>考虑把递推式写为卷积形式，但是注意到<script type="math/tex">2^{i(n-i)}</script>不太能拆。这个时候，由类似<script type="math/tex">Z</script>变换的经典套路，因为</p><script type="math/tex; mode=display">ix=\frac{1}{2}((i+x)^2-i^2-x^2)</script><p>因此</p><script type="math/tex; mode=display">2^{i(n-i)}=2^{\frac{1}{2}(n^2-i^2-(n-i)^2)}</script><p>由于模<script type="math/tex">998244353</script>意义下存在<script type="math/tex">2</script>的二次剩余，即存在<script type="math/tex">w</script>使得<script type="math/tex">w^2\equiv 2\pmod{998244353}</script>，因此递推式可以转化为</p><script type="math/tex; mode=display">f_n=\sum_{i=1}^n(-1)^{i+1}\frac{n!}{i!(n-i)!}w^{n^2-i^2-(n-i)^2}f_{n-i}</script><p>记</p><script type="math/tex; mode=display">F(x)=\sum_{i\ge 0} \frac{f_i}{i!w^i}x^i\\G(x)=\sum_{i\ge 1}\frac{(-1)^{i+1}}{i!w^i}x^i</script><p>那么根据递推式，有</p><script type="math/tex; mode=display">F(x)=F(x)G(x)+1\\F(x)=\frac{1}{1-G(x)}</script><p>直接多项式求逆即可，时间复杂度<script type="math/tex">O(n\log n)</script>。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;求&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;个点的有标号有向无环图个数，&lt;script type=&quot;math/tex&quot;&gt;n\le 5000&lt;/script&gt;。&lt;/p&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;设&lt;script type=&quot;math/tex&quot;&gt;f_n&lt;/script&gt;表示&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;个点的&lt;script type=&quot;math/tex&quot;&gt;DAG&lt;/script&gt;个数，那么有以下递推式成立：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
f_n=\sum_{i=1}^n(-1)^{i+1}\binom{n}{i}2^{i(n-i)}f_{n-i}&lt;/script&gt;&lt;p&gt;为什么这个式子成立呢？&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://cmwqf.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="dp" scheme="http://cmwqf.github.io/tags/dp/"/>
    
    <category term="容斥原理" scheme="http://cmwqf.github.io/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    
    <category term="多项式" scheme="http://cmwqf.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>浅谈常系数齐次线性递推</title>
    <link href="http://cmwqf.github.io/2020/12/20/%E6%B5%85%E8%B0%88%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/"/>
    <id>http://cmwqf.github.io/2020/12/20/%E6%B5%85%E8%B0%88%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/</id>
    <published>2020-12-20T11:58:52.000Z</published>
    <updated>2024-03-06T06:29:00.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常系数齐次线性递推"><a href="#常系数齐次线性递推" class="headerlink" title="常系数齐次线性递推"></a>常系数齐次线性递推</h1><p>给定<script type="math/tex">a_1,a_2,...,a_m</script>以及<script type="math/tex">f_1,f_2,...,f_m</script>，对于<script type="math/tex">\forall n>m</script>，满足</p><script type="math/tex; mode=display">f_n=\sum_{i=1}^ma_if_{n-i}</script><p>每次给定<script type="math/tex">n</script>，求<script type="math/tex">f_n</script>。<script type="math/tex">n\le 10^{18}</script>。</p><p>这个显然可以矩阵乘法，然而有所不同的是，这回<script type="math/tex">m</script>比较大，可能有<script type="math/tex">m\le 500</script>甚至<script type="math/tex">m\le 30000</script>，那么，普通的矩阵乘法就无法解决了。</p><p>这个时候，我们就可以使用一些技巧来加速这个过程。</p><span id="more"></span><h1 id="特征多项式"><a href="#特征多项式" class="headerlink" title="特征多项式"></a>特征多项式</h1><p>设<script type="math/tex">A</script>是<script type="math/tex">n</script>阶矩阵，那么如果数<script type="math/tex">\lambda</script>和非零向量<script type="math/tex">v</script>满足</p><script type="math/tex; mode=display">\lambda v=Av</script><p>那么称<script type="math/tex">\lambda</script>为矩阵<script type="math/tex">A</script>的特征值，<script type="math/tex">v</script>为矩阵<script type="math/tex">A</script>的特征向量。</p><p>上式可以写成</p><script type="math/tex; mode=display">(\lambda I - A)v=0</script><p>对于某个特定的<script type="math/tex">\lambda</script>，这个式子有非零<script type="math/tex">v</script>解当且仅当</p><script type="math/tex; mode=display">\det(\lambda I-A)=0</script><p>把<script type="math/tex">\lambda</script>看成未知量，那么<script type="math/tex">\det(\lambda I-A)</script>可以看成关于<script type="math/tex">\lambda</script>的一个多项式，记为<script type="math/tex">p_A(\lambda)</script>，称为<script type="math/tex">A</script>的特征多项式。</p><p>显然，这个多项式应该是一个关于<script type="math/tex">\lambda</script>的<script type="math/tex">n</script>次多项式。</p><h1 id="Cayley-Hamilton定理"><a href="#Cayley-Hamilton定理" class="headerlink" title="Cayley-Hamilton定理"></a>Cayley-Hamilton定理</h1><p>为什么要引入特征多项式的定义呢？其实就是为了这个定理做准备。</p><p>这个定理的内容很简洁：</p><script type="math/tex; mode=display">p_A(A)=O</script><p>其中<script type="math/tex">O</script>是零矩阵。</p><p>如果读者感兴趣，可以自行查阅证明，此处略去。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>现在，我们就可以讲述常系数齐次线性递推的原理了。</p><p>我们想要加速矩阵快速幂的过程，那么我们的目标：对于一个矩阵<script type="math/tex">A</script>，快速算出<script type="math/tex">A^n</script>。</p><p>假设这个<script type="math/tex">m</script>阶矩阵<script type="math/tex">A</script>的特征多项式为</p><script type="math/tex; mode=display">p_A(\lambda)=\sum_{i=0}^mc_i\lambda^i</script><p>由<script type="math/tex">Cayley-Hamilton</script>定理可知，</p><script type="math/tex; mode=display">p_A(A)=\sum_{i=0}^mc_iA^i=0</script><p>那么我们只需要求出<script type="math/tex">G(x)=x^n\bmod p_A(x)</script>，最终的答案就是<script type="math/tex">A^n=G(A)</script>。</p><p>对于特征多项式的求法，我们可以用拉格朗日插值，但是由于常系数齐次线性递推的矩阵比较特殊，我们可以直接计算，这个我们后面再说。</p><p>假设我们已经求出了<script type="math/tex">p_A(x)</script>，那么我们只需要求出<script type="math/tex">G(x)</script>即可解决问题，因为<script type="math/tex">G(x)</script>必然是一个不超过<script type="math/tex">m-1</script>次的多项式，那么有</p><script type="math/tex; mode=display">G(x)=\sum_{i=0}^{m-1}g_ix^i\\G(A)=\sum_{i=0}^{m-1}g_iA^i\\f_n=\sum_{i=0}^{m-1}g_if_{m+i}</script><p>因此我们可以根据<script type="math/tex">f_m,f_{m+1},...,f_{2m-1}</script>来推出<script type="math/tex">f_n</script>。</p><h1 id="多项式取模"><a href="#多项式取模" class="headerlink" title="多项式取模"></a>多项式取模</h1><p>首先我们注意到要求出<script type="math/tex">G(x)</script>，我们要进行多项式取模。有<script type="math/tex">FFT</script>版的多项式取模+快速幂做法，时间复杂度<script type="math/tex">O(m\log m\log n)</script>，但是那个非常难写，考场上几乎不可能写出来。我们来介绍暴力方法。</p><p>在<a href="https://cmwqf.github.io/2020/07/27/%E6%B5%85%E8%B0%88%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%9A%84%E6%9A%B4%E5%8A%9B%E5%AE%9E%E7%8E%B0/">多项式操作的暴力实现</a>中，我介绍了如何暴力进行多项式取模，但是在此处，我们不能直接对<script type="math/tex">x^n</script>进行多项式取模，这样时间复杂度<script type="math/tex">O(n)</script>，无法接受。</p><p>我们可以考虑快速幂的思想，只不过变成在<script type="math/tex">\bmod p_A(x)</script>的情况下进行。</p><p>考虑快速幂的过程，我们把数换成多项式，并且每次让多项式先平方，再取模，这样时间复杂度为<script type="math/tex">O(m^2\log n)</script>。</p><h1 id="特征多项式求法"><a href="#特征多项式求法" class="headerlink" title="特征多项式求法"></a>特征多项式求法</h1><p>现在，唯一的问题是如何求特征多项式。</p><p>考虑<script type="math/tex">A</script>长什么样子？</p><script type="math/tex; mode=display">A=\begin{bmatrix}a_1 & a_2 & a_3 & ... & a_{m-1} & a_m\\1 & 0 & 0 & ... & 0 & 0\\0 & 1 & 0 & ... & 0 & 0\\... & ... & ... & ... & ... & ...\\0 & 0 & 0 & ... & 1 & 0\end{bmatrix}</script><p>那么</p><script type="math/tex; mode=display">p_A(\lambda)=\det(\lambda I-A)=|\begin{bmatrix}\lambda - a_1 & -a_2 & -a_3 & ... & -a_{m-1} & -a_m\\-1 & \lambda & 0 & ... & 0 & 0\\0 & -1 & \lambda & ... & 0 & 0\\... & ... & ... & ... & ... & ...\\0 & 0 & 0 & ... & -1 & \lambda\end{bmatrix}|</script><p>假设<script type="math/tex">B=\lambda I - A</script>，那么根据第一行展开，有</p><script type="math/tex; mode=display">\det(B)=(\lambda-a_1)B_{1,1}-a_2B_{1,2}-...-a_mB_{1,m}</script><p>其中<script type="math/tex">B_{i,j}</script>表示代数余子式。</p><p>注意到<script type="math/tex">1,i</script>余子式的行列式就是其对角线上数的乘积，即<script type="math/tex">(-1)^{i-1}\lambda^{m-i}</script>，则</p><script type="math/tex; mode=display">B_{1,i}=(-1)^{1+i}(-1)^{i-1}\lambda^{m-i}=\lambda^{m-i}</script><p>那么我们有</p><script type="math/tex; mode=display">\det(B)=\lambda^m-\sum_{i=1}^ma_i\lambda^{m-i}</script>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;常系数齐次线性递推&quot;&gt;&lt;a href=&quot;#常系数齐次线性递推&quot; class=&quot;headerlink&quot; title=&quot;常系数齐次线性递推&quot;&gt;&lt;/a&gt;常系数齐次线性递推&lt;/h1&gt;&lt;p&gt;给定&lt;script type=&quot;math/tex&quot;&gt;a_1,a_2,...,a_m&lt;/script&gt;以及&lt;script type=&quot;math/tex&quot;&gt;f_1,f_2,...,f_m&lt;/script&gt;，对于&lt;script type=&quot;math/tex&quot;&gt;\forall n&gt;m&lt;/script&gt;，满足&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
f_n=\sum_{i=1}^ma_if_{n-i}&lt;/script&gt;&lt;p&gt;每次给定&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;，求&lt;script type=&quot;math/tex&quot;&gt;f_n&lt;/script&gt;。&lt;script type=&quot;math/tex&quot;&gt;n\le 10^{18}&lt;/script&gt;。&lt;/p&gt;
&lt;p&gt;这个显然可以矩阵乘法，然而有所不同的是，这回&lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt;比较大，可能有&lt;script type=&quot;math/tex&quot;&gt;m\le 500&lt;/script&gt;甚至&lt;script type=&quot;math/tex&quot;&gt;m\le 30000&lt;/script&gt;，那么，普通的矩阵乘法就无法解决了。&lt;/p&gt;
&lt;p&gt;这个时候，我们就可以使用一些技巧来加速这个过程。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://cmwqf.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="线性代数" scheme="http://cmwqf.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>浅谈BEST定理</title>
    <link href="http://cmwqf.github.io/2020/09/12/%E6%B5%85%E8%B0%88BEST%E5%AE%9A%E7%90%86/"/>
    <id>http://cmwqf.github.io/2020/09/12/%E6%B5%85%E8%B0%88BEST%E5%AE%9A%E7%90%86/</id>
    <published>2020-09-12T02:10:48.000Z</published>
    <updated>2024-03-06T06:29:00.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BEST定理"><a href="#BEST定理" class="headerlink" title="BEST定理"></a>BEST定理</h1><p>什么是<script type="math/tex">BEST</script>定理呢？</p><p>所谓<script type="math/tex">BEST</script>，是由发现这个定理的四个人缩写构成的。这个定理的作用，是求有向图欧拉回路的个数。</p><span id="more"></span><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>首先，如果存在某个点的入度和出度不相等，那么这张图不存在欧拉回路。</p><p>否则，我们设<script type="math/tex">T(x)</script>表示以<script type="math/tex">x</script>为根的内向树个数，<script type="math/tex">deg(x)</script>为<script type="math/tex">x</script>的出度（等于入度），那么有向图欧拉回路个数为</p><script type="math/tex; mode=display">ans=T(rt)\prod_{v\in V}(deg(v)-1)!</script><p>其中，<script type="math/tex">rt\in V</script>，也就是说，以任何一个点作为根最后都可以得出一样的答案。</p><p>但是，如果规定欧拉回路起点的话答案有所不同，这个我们后面再说。</p><h1 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h1><p>我们来考虑一个内向树与一个欧拉回路的对应关系。</p><p>内向树中除了根节点<script type="math/tex">rt</script>，都有一个指向父亲的边，我们把它看成从这个点出发的最后一条边。另外，我们把每个点除了指向父亲的边以外的所有边按照一定顺序排序（随便什么顺序），特别地，对于根节点，因为我们统计的是欧拉回路，是一个环，因此为了避免算重，我们钦定根节点第一个出去的边是与根节点连接的编号最小的那条边，并对与根节点相连的剩下的边按照一定顺序排序。</p><p>现在我们来证明这个与一条欧拉回路一一对应。</p><p>首先考虑确定了内向树和每个点的出边顺序后能唯一对应一条欧拉回路。</p><p>我们从根节点开始，按照确定的出边顺序走，即如果我们到了一个节点<script type="math/tex">u</script>，那么我们现在会走按照已经确定的<script type="math/tex">u</script>的出边顺序还没走过的顺序最小的边。显然，最后会回到根节点，<strong>因为如果一个点走了内向树上连向父亲的那条边，那么说明这个点所有其他出边和入边都被走完了，反过来，对于任何一个不是根节点的节点，只要能到达这个节点，它与父亲的连边一定没有走过</strong>，因此不会成为终点。</p><p>那么我们走出了一条回路，那么这是不是欧拉回路呢？会不会有的边没有走到呢？</p><p>假设<script type="math/tex">u</script>的某条出边或入边没有被走，那么它与父亲的连边一定不会被走，它父亲与它父亲的父亲的连边也不会走……这样，从<script type="math/tex">u</script>到根节点这条链上的所有边都不会被走，也就是说根节点有一条入边没被走，根据入度等于出度，根节点有一条出边没被走，此时根节点不会成为路径的终点，矛盾。</p><p>下面我们来证明一条欧拉路径能反过来唯一对应。</p><p>考虑每个点（除了根节点）走出的最后一条边设为内向树上这个节点与父亲的连边。我们把所有树边拿出来，每个点只有一条出边，因此我们只需证明由这些树边组成的图中没有环即可。</p><p>这个很显然，如果有环，那么因为根节点没有选边，因此根节点不可能出现在环上。那么对于环上任意一点，我们走了它的树边以后还能回到这个点，根据入度等于出度，一定还有一条边没被走，那么显然这不符合“这条树边是最后一条出边”的定义，矛盾。</p><p>那么，我们就证明了对应关系。</p><p> 内向树的方案数是<script type="math/tex">T(rt)</script>，而我们要对每个点（包括根节点）的其他出边选一个顺序，是<script type="math/tex">\prod (deg(v)-1)!</script>，那么</p><script type="math/tex; mode=display">ans=T(rt)\prod_{v\in V}(deg(v)-1)!</script><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>如果答案要求以某个点<script type="math/tex">s</script>为出发点的欧拉回路个数，那么答案是</p><script type="math/tex; mode=display">ans=T(s)deg(s)\prod_{v\in V}(deg(v)-1)!</script><p>为什么呢？因为这个时候相当于将一条欧拉回路从<script type="math/tex">s</script>处断环成链，那么一条欧拉回路有<script type="math/tex">deg(s)</script>处可以断开，因此要在答案上乘以<script type="math/tex">deg(s)</script>。</p><p>另外，这个算法中，重边看作不同的边，因此如果重边看作相同的边，还要除以重边的排列数。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;BEST定理&quot;&gt;&lt;a href=&quot;#BEST定理&quot; class=&quot;headerlink&quot; title=&quot;BEST定理&quot;&gt;&lt;/a&gt;BEST定理&lt;/h1&gt;&lt;p&gt;什么是&lt;script type=&quot;math/tex&quot;&gt;BEST&lt;/script&gt;定理呢？&lt;/p&gt;
&lt;p&gt;所谓&lt;script type=&quot;math/tex&quot;&gt;BEST&lt;/script&gt;，是由发现这个定理的四个人缩写构成的。这个定理的作用，是求有向图欧拉回路的个数。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://cmwqf.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="图论" scheme="http://cmwqf.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>浅谈多项式操作的暴力实现</title>
    <link href="http://cmwqf.github.io/2020/07/27/%E6%B5%85%E8%B0%88%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%9A%84%E6%9A%B4%E5%8A%9B%E5%AE%9E%E7%8E%B0/"/>
    <id>http://cmwqf.github.io/2020/07/27/%E6%B5%85%E8%B0%88%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%9A%84%E6%9A%B4%E5%8A%9B%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-07-27T02:59:35.000Z</published>
    <updated>2024-03-06T06:29:00.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多项式操作的暴力实现"><a href="#多项式操作的暴力实现" class="headerlink" title="多项式操作的暴力实现"></a>多项式操作的暴力实现</h1><p>对于有些题目，数据范围很小或者模数不是<script type="math/tex">998244353</script>，这个时候用<script type="math/tex">NTT</script>就不适用了，比如对于<script type="math/tex">n\le 1000</script>做多项式<script type="math/tex">\exp</script>，那么显然不如暴力<script type="math/tex">O(n^2)</script>常数小。另外，在考场上如果能用暴力写多项式操作尽量用暴力，因为码量小，好调试。</p><p>因此，我们不仅要掌握如何用<script type="math/tex">NTT</script>求多项式，还要了解暴力求解多项式的各种方法。</p><p>注意，暴力求解的复杂度都是<script type="math/tex">O(n^2)</script>。</p><span id="more"></span><h1 id="多项式乘法"><a href="#多项式乘法" class="headerlink" title="多项式乘法"></a>多项式乘法</h1><p>这个不用多说，根据定义直接类似背包实现即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        ans[i + j] += f[i] * g[j];</span><br></pre></td></tr></table></figure><h1 id="多项式除法"><a href="#多项式除法" class="headerlink" title="多项式除法"></a>多项式除法</h1><p>如果多项式能整除且我们要求除后的商，那么我们将背包操作倒过来实现即可。</p><p>如果我们要求除后的余数（比如线性递推），可以用类似数学的方法，每次提取因式消去最高项即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= m; i--)</span><br><span class="line">    <span class="keyword">if</span>(g[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">1ll</span> * g[i] * <span class="built_in">mpow</span>(f[m], mod - <span class="number">2</span>) % mod; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            g[i - j] -= <span class="number">1ll</span> * f[j] * t % mod;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="多项式求逆"><a href="#多项式求逆" class="headerlink" title="多项式求逆"></a>多项式求逆</h1><p>我们已知<script type="math/tex">F(x)</script>，我们现在要求一个<script type="math/tex">G(x)</script>，使得<script type="math/tex">F(x)G(x)\equiv1\pmod{x^m}</script>。</p><p>那么根据定义，我们有</p><script type="math/tex; mode=display">[x^n]F(x)G(x)=\sum_{i=0}^nf_ig_{n-i}=[n=0]</script><p>那么</p><script type="math/tex; mode=display">g_nf_0=[n=0]-\sum_{i=1}^{n}f_ig_{n-i}</script><p>直接递推即可。</p><h1 id="多项式ln"><a href="#多项式ln" class="headerlink" title="多项式ln"></a>多项式ln</h1><p>我们已知<script type="math/tex">F(x)</script>，要求<script type="math/tex">G(x)\equiv\ln F(x)\pmod{x^m}</script>。</p><p>首先，我们两边求导</p><script type="math/tex; mode=display">G'(x)\equiv\frac{F'(x)}{F(x)}\pmod{x^m}\\G'(x)F(x)\equiv F'(x)\pmod{x^m}</script><p>那么</p><script type="math/tex; mode=display">[x^{n-1}]G'(x)F(x)=\sum_{i=0}^{n-1}f_ig_{n-i}(n-i)=f_nn</script><p>即</p><script type="math/tex; mode=display">f_0g_nn=f_nn-\sum_{i=1}^{n-1}f_ig_{n-i}(n-i)</script><p>根据定义，边界条件为<script type="math/tex">g_0=0</script>，递推即可。</p><h1 id="多项式exp"><a href="#多项式exp" class="headerlink" title="多项式exp"></a>多项式exp</h1><p>我们已知<script type="math/tex">F(x)</script>，要求<script type="math/tex">G(x)\equiv \exp F(x) \pmod{x^m}</script>。实际上，我们要求</p><script type="math/tex; mode=display">G(x)\equiv \sum_{i\ge 0}\frac{F^i}{i!}\pmod{x^m}</script><p>首先我们两边求导，有</p><script type="math/tex; mode=display">G'(x)\equiv G(x)F'(x)\pmod{x^m}</script><p>那么</p><script type="math/tex; mode=display">[x^{n-1}]G'(x)=g_nn=\sum_{i=0}^{n-1}f_{i+1}(i+1)g_{n-1-i}</script><p>即</p><script type="math/tex; mode=display">g_nn=\sum_{i=1}^{n}f_iig_{n-i}</script><p>根据定义，<script type="math/tex">g_0=1</script>，依然直接递推即可。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;多项式操作的暴力实现&quot;&gt;&lt;a href=&quot;#多项式操作的暴力实现&quot; class=&quot;headerlink&quot; title=&quot;多项式操作的暴力实现&quot;&gt;&lt;/a&gt;多项式操作的暴力实现&lt;/h1&gt;&lt;p&gt;对于有些题目，数据范围很小或者模数不是&lt;script type=&quot;math/tex&quot;&gt;998244353&lt;/script&gt;，这个时候用&lt;script type=&quot;math/tex&quot;&gt;NTT&lt;/script&gt;就不适用了，比如对于&lt;script type=&quot;math/tex&quot;&gt;n\le 1000&lt;/script&gt;做多项式&lt;script type=&quot;math/tex&quot;&gt;\exp&lt;/script&gt;，那么显然不如暴力&lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt;常数小。另外，在考场上如果能用暴力写多项式操作尽量用暴力，因为码量小，好调试。&lt;/p&gt;
&lt;p&gt;因此，我们不仅要掌握如何用&lt;script type=&quot;math/tex&quot;&gt;NTT&lt;/script&gt;求多项式，还要了解暴力求解多项式的各种方法。&lt;/p&gt;
&lt;p&gt;注意，暴力求解的复杂度都是&lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://cmwqf.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="生成函数" scheme="http://cmwqf.github.io/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
    <category term="多项式" scheme="http://cmwqf.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Berlekamp-Massey算法</title>
    <link href="http://cmwqf.github.io/2020/07/18/%E6%B5%85%E8%B0%88Berlekamp-Massey%E7%AE%97%E6%B3%95/"/>
    <id>http://cmwqf.github.io/2020/07/18/%E6%B5%85%E8%B0%88Berlekamp-Massey%E7%AE%97%E6%B3%95/</id>
    <published>2020-07-18T14:32:35.000Z</published>
    <updated>2024-03-06T06:29:00.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BM算法"><a href="#BM算法" class="headerlink" title="BM算法"></a>BM算法</h1><p>如果我们已知一个数列是线性递推数列（或猜测一个数列是线性递推数列），但是我们并不知道它的线性递推式具体是多少，那么我们可以使用<script type="math/tex">Berlekamp-Massey</script>算法，简称<script type="math/tex">BM</script>算法，来计算最短线性递推式。</p><p>具体来说，如果已知数列可以写成</p><script type="math/tex; mode=display">a[n]=\sum_{i=1}^mr[i]*a[n - i]\quad(n\ge m+1)</script><p>给定长度为<script type="math/tex">n</script>数列<script type="math/tex">a</script>，那么我们可以通过<script type="math/tex">BM</script>计算出这个数列最短的线性递推式（设长度为<script type="math/tex">m</script>），满足对于<script type="math/tex">m+1\le i\le n</script>，<script type="math/tex">a[i]</script>都满足这个规律。</p><span id="more"></span><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>考虑通过不断增加数来修改线性递推数列，设<script type="math/tex">R_i</script>为第<script type="math/tex">i</script>版线性递推数列。</p><p>假设我们现在已经求出<script type="math/tex">a_1,a_2,...a_{i-1}</script>的线性递推数列<script type="math/tex">r_1,r_2,...r_m</script>（记为<script type="math/tex">R_{cnt}</script>），现在我们要求<script type="math/tex">a_1,a_2,...,a_i</script>的线性递推数列。</p><p>设<script type="math/tex">delta_i=\sum_{j=1}^mr[j]*a[n-j]-a[i]</script>。</p><p>如果<script type="math/tex">delta_i=0</script>，那么说明<script type="math/tex">R_{cnt}</script>对<script type="math/tex">a_1,a_2,...,a_i</script>也成立。</p><p>否则，说明我们需要调整<script type="math/tex">R_{cnt}</script>为<script type="math/tex">R_{cnt+1}</script>。怎么调整呢？</p><p>首先，如果此时<script type="math/tex">cnt=0</script>，那么说明<script type="math/tex">a_i</script>是数列中第一个非零数，那么我们只需将<script type="math/tex">R_1</script>置为<script type="math/tex">\{0,0,..,0\}</script>（<script type="math/tex">i</script>个<script type="math/tex">0</script>）即可。</p><p>否则，如果我们能找到另一个线性递推数列，使得这个线性递推数列前<script type="math/tex">i-1</script>个数都是<script type="math/tex">0</script>，而第<script type="math/tex">i</script>个数是<script type="math/tex">delta_i</script>，那么我们只需将这个线性递推数列和<script type="math/tex">R_{cnt}</script>加起来就能得到一个合法的<script type="math/tex">R_{cnt+1}</script>。</p><p>其实要构造这样的线性递推数列很简单，我们只需找任意一个历史版本的<script type="math/tex">R_k(k<cnt)</script>。设<script type="math/tex">w=fail_k</script>为使得<script type="math/tex">R_k</script>变得不合法的第一个位置。那么我们设<script type="math/tex">mul=\frac{delta_i}{delta_w}</script>，并构造<script type="math/tex">\{0,0,...,0,mul,-mul*R_k\}</script>（前面有<script type="math/tex">i-w-1</script>个<script type="math/tex">0</script>）即可，设其长度为<script type="math/tex">m</script>。</p><p>这样，对于<script type="math/tex">\forall j<i</script>，<script type="math/tex">mul*a[j-(i-w)]</script>与最后的相抵消，结果为<script type="math/tex">0</script>。而当<script type="math/tex">j=i</script>时，结果是<script type="math/tex">delta_i</script>，因此满足我们所需的数列条件。</p><p>因此，<script type="math/tex">R_{cnt+1}=\{0,0,...,0,mul,-mul*R_k\}+R_{cnt}</script>，长度为<script type="math/tex">max(i-w+len_k,len_{cnt})</script>。</p><p>而我们要求最短，因此只需记录下当前<script type="math/tex">len_k-fail_k</script>最短的<script type="math/tex">R</script>即可。</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>用<script type="math/tex">BM</script>得到的最短线性递推式最好要长度远小于<script type="math/tex">\frac{n}{2}</script>才结束，否则要再打表。因为如果长度为<script type="math/tex">\frac{n}{2}</script>，那么相当于<script type="math/tex">\frac{n}{2}</script>个未知数列<script type="math/tex">\frac{n}{2}</script>个方程，总能找到解。因此对于任何一个长度为<script type="math/tex">n</script>随机数列，它的线性递推数列也是<script type="math/tex">\frac{n}{2}</script>左右，所以只有当长度远小于<script type="math/tex">\frac{n}{2}</script>时才能大致确定是原数列的线性递推式。如果长度一直在<script type="math/tex">\frac{n}{2}</script>左右，那么很可能这个数列并不是线性递推数列。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">BM</span><span class="params">(<span class="keyword">int</span> *a, vector&lt;<span class="keyword">int</span>&gt; &amp;ans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans.<span class="built_in">clear</span>();</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; lst;</span><br><span class="line">    <span class="keyword">int</span> w = <span class="number">0</span>, delta = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ans.<span class="built_in">size</span>(); j++)</span><br><span class="line">            t = <span class="built_in">ADD</span>(t, <span class="number">1ll</span> * ans[j] * a[i - j - <span class="number">1</span>] % mod);</span><br><span class="line">        <span class="keyword">if</span>(t == a[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!w)</span><br><span class="line">        &#123;</span><br><span class="line">            w = i; delta = <span class="built_in">SUB</span>(a[i], t);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) ans.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; now = ans;</span><br><span class="line">        <span class="keyword">int</span> mul = <span class="number">1ll</span> * <span class="built_in">SUB</span>(a[i], t) * <span class="built_in">mpow</span>(delta, mod - <span class="number">2</span>) % mod;</span><br><span class="line">        <span class="keyword">if</span>(i - w + (<span class="keyword">int</span>)lst.<span class="built_in">size</span>() &gt; (<span class="keyword">int</span>)ans.<span class="built_in">size</span>()) ans.<span class="built_in">resize</span>(i - w + (<span class="keyword">int</span>)lst.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">        ans[i - w - <span class="number">1</span>] = <span class="built_in">ADD</span>(ans[i - w - <span class="number">1</span>], mul);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lst.<span class="built_in">size</span>(); j++) ans[i - w + j] = <span class="built_in">SUB</span>(ans[i - w + j], <span class="number">1ll</span> * mul * lst[j] % mod);</span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">int</span>)now.<span class="built_in">size</span>() - i &lt; (<span class="keyword">int</span>)lst.<span class="built_in">size</span>() - w) delta = <span class="built_in">SUB</span>(a[i], t), w = i, lst = now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;BM算法&quot;&gt;&lt;a href=&quot;#BM算法&quot; class=&quot;headerlink&quot; title=&quot;BM算法&quot;&gt;&lt;/a&gt;BM算法&lt;/h1&gt;&lt;p&gt;如果我们已知一个数列是线性递推数列（或猜测一个数列是线性递推数列），但是我们并不知道它的线性递推式具体是多少，那么我们可以使用&lt;script type=&quot;math/tex&quot;&gt;Berlekamp-Massey&lt;/script&gt;算法，简称&lt;script type=&quot;math/tex&quot;&gt;BM&lt;/script&gt;算法，来计算最短线性递推式。&lt;/p&gt;
&lt;p&gt;具体来说，如果已知数列可以写成&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
a[n]=\sum_{i=1}^mr[i]*a[n - i]\quad(n\ge m+1)&lt;/script&gt;&lt;p&gt;给定长度为&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;数列&lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;，那么我们可以通过&lt;script type=&quot;math/tex&quot;&gt;BM&lt;/script&gt;计算出这个数列最短的线性递推式（设长度为&lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt;），满足对于&lt;script type=&quot;math/tex&quot;&gt;m+1\le i\le n&lt;/script&gt;，&lt;script type=&quot;math/tex&quot;&gt;a[i]&lt;/script&gt;都满足这个规律。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://cmwqf.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="线性代数" scheme="http://cmwqf.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>浅谈带权二分</title>
    <link href="http://cmwqf.github.io/2020/07/05/%E6%B5%85%E8%B0%88%E5%B8%A6%E6%9D%83%E4%BA%8C%E5%88%86/"/>
    <id>http://cmwqf.github.io/2020/07/05/%E6%B5%85%E8%B0%88%E5%B8%A6%E6%9D%83%E4%BA%8C%E5%88%86/</id>
    <published>2020-07-05T07:28:05.000Z</published>
    <updated>2024-03-06T06:29:00.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="带权二分"><a href="#带权二分" class="headerlink" title="带权二分"></a>带权二分</h1><p>带权二分，又称为<script type="math/tex">wqs</script>二分或凸优化，它适用于一类<script type="math/tex">dp</script>的优化，可以将一个二维的状态转化为一维，从而达到优化时间复杂度的效果。</p><p>具体地，带权二分一般适用于这样一类问题：有<script type="math/tex">n</script>个物品，要求从里面选恰好<script type="math/tex">m</script>个（可能有若干限制），使得价值总和最优。但是，并不是所有这一类问题都可以使用<script type="math/tex">wqs</script>二分。</p><p>那么，具体什么情况可以使用带权二分呢？带权二分又是运用了什么思想呢？</p><span id="more"></span><h1 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h1><p>什么情况下，我们可以使用带权二分呢？注意我们上面提出的这一类问题，一般我们会设计状态为设<script type="math/tex">f[i][j]</script>表示前<script type="math/tex">i</script>个物品，选了<script type="math/tex">j</script>个的最优结果是什么。显然最后的答案是<script type="math/tex">f[n][m]</script>。</p><p>如果我们把<script type="math/tex">f[n]</script>画成图像：即我们画一张图像，每个点为<script type="math/tex">(i,f[n][i])</script>，并顺次连接。如果这个图像是凸的（不管是上凸还是下凸），我们就可以使用带权二分。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>我们的思想是去掉选择个数的条件，即我们去掉“恰好选<script type="math/tex">m</script>个”，下面我们不妨设问题让我们求最大值，<script type="math/tex">f[n]</script>的图像为上凸函数。</p><p>设<script type="math/tex">g[i]</script>表示<script type="math/tex">f[i][j]</script>的最大值，然后我们来<script type="math/tex">dp</script>出<script type="math/tex">g</script>，这个的时间复杂度显然就要优秀的多。但是，我们最后并不能通过<script type="math/tex">g</script>知道<script type="math/tex">f[n][m]</script>，因为<script type="math/tex">g[n]</script>代表的只是<script type="math/tex">f[n][i]</script>的最大值。</p><p>这个时候，我们考虑<script type="math/tex">f[n]</script>图像的导函数，由于是上凸函数，其导函数一定是递减的。其导函数与<script type="math/tex">x</script>轴的交点横坐标就是<script type="math/tex">f[n]</script>取最大值时的横坐标。</p><p>我们考虑给<script type="math/tex">f[n]</script>加上一个正比例函数<script type="math/tex">y=kx</script>，那么，这个时候其导函数会加上<script type="math/tex">k</script>，那么其与<script type="math/tex">x</script>轴的交点会往右移，换句话说，<script type="math/tex">f[n]</script>的最值点会往右移。那么，我们可以通过加上正比例函数，使得<script type="math/tex">f</script>的最值点位置调整。因为<script type="math/tex">g[n]</script>求的是<script type="math/tex">f[n][i]</script>的最值点，那么我们只需要调整<script type="math/tex">k</script>使得<script type="math/tex">f[n]</script>的最值点变到<script type="math/tex">x=m</script>上，那么此时的<script type="math/tex">g[n]-mk</script>就是答案。</p><p>怎样使得整个函数加上<script type="math/tex">kx</script>呢？注意<script type="math/tex">kx</script>的实际意义是每多选一个物品，我们就多获得<script type="math/tex">k</script>的价值，所以我们只需在<script type="math/tex">dp</script>的时候修改一下价值即可。</p><p>那么，我们怎么调整<script type="math/tex">k</script>呢？注意到<script type="math/tex">k</script>显然是可二分的，因此我们只需二分<script type="math/tex">k</script>（<script type="math/tex">k</script>的值域为<script type="math/tex">f[n]</script>导函数的值域），然后我们在<script type="math/tex">dp</script>的时候很容易记录<script type="math/tex">g[i]</script>取这个最优值时最少要选多少个物品（只需转移时稍微记录一下即可），设为<script type="math/tex">s[i]</script>，那么如果最后<script type="math/tex">s[n]>m</script>那么说明<script type="math/tex">k</script>要调小，否则说明<script type="math/tex">k</script>要调大。</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>最后二分出来的<script type="math/tex">k</script>会是小数吗？</p><p>不会，我们只需在整数上进行二分即可。因为<script type="math/tex">k</script>的值域是<script type="math/tex">f[n]</script>导函数的值域。实际上<script type="math/tex">f[n]</script>是由一些折线构成的，相邻两个点的斜率为<script type="math/tex">f[n][i]-f[n][i-1]</script>，故只要<script type="math/tex">f[n]</script>中不存在小数，那么其导函数（即斜率的值）不可能会是小数。</p><p>如果最后二分出来的<script type="math/tex">k</script>中<script type="math/tex">s[n]\neq m</script>怎么办？</p><p>由上文所述，<script type="math/tex">k</script>不会是小数，因此如果最后<script type="math/tex">s[n]\neq m</script>，一定是因为<script type="math/tex">f[n]</script>导函数中<script type="math/tex">m</script>周围点的导函数与<script type="math/tex">m</script>相同，那么，注意<script type="math/tex">s[i]</script>的定义是当<script type="math/tex">g[i]</script>取最优值时<strong>最少</strong>要选多少物品，因此我们只需保留<script type="math/tex">s[n]\le m</script>中<script type="math/tex">s[n]</script>最大的所对应的<script type="math/tex">k</script>即可。</p><p>如果读者无法理解，可以想象导函数图像，是一些递减的水平线段，最后的<script type="math/tex">s[n]</script>即<script type="math/tex">x=m</script>时导函数上那个点所在线段的左端点的横坐标。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>那么，在考试的时候，我们怎样才能想到带权二分？</p><p>首先，明确带权二分是<script type="math/tex">dp</script>的优化，所以我们要先想到朴素的<script type="math/tex">dp</script>，然后如果发现这个<script type="math/tex">dp</script>无法获得满分，我们尝试把<script type="math/tex">f[n][i]</script>的表打出来，观察是否是凸的。如果是，尝试通过归纳法证明，实在无法证明可以进行大胆猜想，写完以后对拍验证。不放心的话，最后还是和前面的暴力<script type="math/tex">dp</script>数据分治一下。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;带权二分&quot;&gt;&lt;a href=&quot;#带权二分&quot; class=&quot;headerlink&quot; title=&quot;带权二分&quot;&gt;&lt;/a&gt;带权二分&lt;/h1&gt;&lt;p&gt;带权二分，又称为&lt;script type=&quot;math/tex&quot;&gt;wqs&lt;/script&gt;二分或凸优化，它适用于一类&lt;script type=&quot;math/tex&quot;&gt;dp&lt;/script&gt;的优化，可以将一个二维的状态转化为一维，从而达到优化时间复杂度的效果。&lt;/p&gt;
&lt;p&gt;具体地，带权二分一般适用于这样一类问题：有&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;个物品，要求从里面选恰好&lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt;个（可能有若干限制），使得价值总和最优。但是，并不是所有这一类问题都可以使用&lt;script type=&quot;math/tex&quot;&gt;wqs&lt;/script&gt;二分。&lt;/p&gt;
&lt;p&gt;那么，具体什么情况可以使用带权二分呢？带权二分又是运用了什么思想呢？&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://cmwqf.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="dp" scheme="http://cmwqf.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>浅谈上下界网络流</title>
    <link href="http://cmwqf.github.io/2020/05/27/%E6%B5%85%E8%B0%88%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <id>http://cmwqf.github.io/2020/05/27/%E6%B5%85%E8%B0%88%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%BD%91%E7%BB%9C%E6%B5%81/</id>
    <published>2020-05-27T00:59:06.000Z</published>
    <updated>2024-03-06T06:29:00.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="上下界网络流"><a href="#上下界网络流" class="headerlink" title="上下界网络流"></a>上下界网络流</h1><p>在一类网络流问题中，我们对每条边的流量，不仅有上界限制，还有下界限制，即第<script type="math/tex">i</script>条边流量要在<script type="math/tex">[l_i,r_i]</script>中，由此引申出来的一些问题（可行流，最大流），我们可以用上下界网络流来解决。</p><p>实际上，一个可行的网络流满足以下条件：</p><ol><li><p>每条边的流量在流量限制内。</p></li><li><p>对于<script type="math/tex">\forall u\neq s,t</script>，都有<script type="math/tex">\sum w(v,u)=\sum w(u,v)</script>，即每个点的流入流量等于流出流量，称为流量守恒，这个思想是我们讨论的核心。</p></li></ol><p>接下来，我们来逐步探索上下界网络流的几种形式。</p><span id="more"></span><h1 id="无源汇上下界可行流"><a href="#无源汇上下界可行流" class="headerlink" title="无源汇上下界可行流"></a>无源汇上下界可行流</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>一个网络，我们要求出一个流，使得第<script type="math/tex">i</script>条边的流量必须在<script type="math/tex">[l_i,r_i]</script>中，且对于每个点，都有总流入量等于总流出量（注意这个流没有源汇，因此循环往复，无始无终）。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>这个算法是整个上下界网络流的基础，所以需要理解掌握。</p><p>我们的思想是调整：我们忽视掉第二个流量守恒的条件，只满足第一个条件，构成一组初始流。然后，我们在残量网络上进行调整，构造一组附加流，使得初始流加上附加流满足第二个条件，即流量守恒，最后每条边的流量为其在初始流中流量与在附加流中流量之和。</p><p>首先我们钦定每条边的流量是<script type="math/tex">l_i</script>，然后，我们构建出残量网络，在残量网络上每条边的限制为<script type="math/tex">r_i-l_i</script>，因为初始流不一定满足流量守恒，因此附加流也不一定满足流量守恒。具体地，如果在初始流中点<script type="math/tex">u</script>的<strong>流入流量</strong>比<strong>流出流量</strong>多<script type="math/tex">w</script>，那么为了最终流量守恒，在附加流中其<strong>流出流量</strong>要比<strong>流入流量</strong>多<script type="math/tex">w</script>，反之亦然。</p><p>但是一般求解网络流的方法都是要求流量守恒，怎么办呢？</p><p>我们新建两个虚拟节点<script type="math/tex">ss</script>，<script type="math/tex">tt</script>，分别用作补给和分流。具体地，如果在<strong>附加流</strong>中要求<script type="math/tex">u</script>的<strong>流入流量</strong>比<strong>流出流量</strong>多<script type="math/tex">w</script>，那么多的流就要分担，因此我们连一条<script type="math/tex">(u,tt,w)</script>的边。如果<script type="math/tex">u</script>的<strong>流入流量</strong>比<strong>流出流量</strong>少<script type="math/tex">w</script>，那么少的流需要补充，因此我们连一条<script type="math/tex">(ss,u,w)</script>的边。最后，我们跑一边最大流即可。</p><p>在实际的实现中，我们只需记录<script type="math/tex">w[u]</script>为所有流入<script type="math/tex">u</script>的边的下界减所有流出<script type="math/tex">u</script>边的下界。如果<script type="math/tex">w[u]>0</script>，则说明<strong>初始流</strong>中流入流量多于流出流量，那么在<strong>附加流</strong>中必须流入流量少于流出流量，因此建一条<script type="math/tex">(ss,u,w[u])</script>的边；如果<script type="math/tex">w[u]<0</script>，则建一条<script type="math/tex">(u,tt,-w[u])</script>的边。</p><p>跑完最大流之后，如果最大流等于我们所需要的流，即<script type="math/tex">ss</script>连出去的边的流量之和（等于连向<script type="math/tex">tt</script>的边的流量之和），那么就存在可行流，此时附加流中每条边的流量就是每条边反向边的<script type="math/tex">val</script>值。</p><h1 id="有源汇上下界可行流"><a href="#有源汇上下界可行流" class="headerlink" title="有源汇上下界可行流"></a>有源汇上下界可行流</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p>有一个有源汇的网络，第<script type="math/tex">i</script>条边流量要求在<script type="math/tex">[l_i,r_i]</script>之间，问是否存在可行流（对于<script type="math/tex">\forall u\neq s,t</script>，都满足流量守恒）。</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><p>这个模型和前者区别仅在于它有一个源点<script type="math/tex">s</script>和一个汇点<script type="math/tex">t</script>，而这两个点是不满足流量守恒的。</p><p>那么，我们想办法让这两个点也满足流量守恒，这样就可以转化为无源汇的问题了。</p><p>为了使<script type="math/tex">s</script>和<script type="math/tex">t</script>满足流量守恒，我们需有边流入<script type="math/tex">s</script>，且有边流出<script type="math/tex">t</script>。注意到<script type="math/tex">s</script>流出的流量等于流入<script type="math/tex">t</script>的流量，因此我们只需连一条从<script type="math/tex">t</script>到<script type="math/tex">s</script>，下界为<script type="math/tex">0</script>上界为<script type="math/tex">+\infty</script>的边即可。最后我们只需拆掉加入的<script type="math/tex">(t,s)</script>边，剩下的就是一个可行的有源汇网络流了。</p><p>最后网络流的流量是多少呢？应该是<script type="math/tex">s</script>连出去的边（不包括连向<script type="math/tex">tt</script>的边）上的流量加上它们的下界之和。但是我们有一个更简单的做法，注意到<script type="math/tex">s</script>会向<script type="math/tex">tt</script>连一条限制为<script type="math/tex">w</script>的边，而<script type="math/tex">w</script>正是<script type="math/tex">s</script>连出去的边的下界之和，而如果可行，这条边最后一定是满流，所以我们只需要统计<script type="math/tex">s</script>连出去的所有边的流量和即可，那么根据流量守恒，它等于连向<script type="math/tex">s</script>所有边的流量之和。而连向<script type="math/tex">s</script>的边只有<script type="math/tex">(t,s)</script>一条，因此答案就是<script type="math/tex">(t,s)</script>这条边上的流量，也就是其反向边最后的<script type="math/tex">val</script>。</p><h1 id="有源汇上下界最大流"><a href="#有源汇上下界最大流" class="headerlink" title="有源汇上下界最大流"></a>有源汇上下界最大流</h1><h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h2><p>有一个有源汇的网络，在第<script type="math/tex">i</script>条边流量要求在<script type="math/tex">[l_i,r_i]</script>之间，且流量守恒的前提下，要求流量最大。</p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><p>首先我们先用上面的方法跑出一个可行流。但是可行流不一定是最大流。</p><p>然后，我们只需在去掉<script type="math/tex">(t,s)</script>这条边的残量网络上跑一遍从<script type="math/tex">s</script>到<script type="math/tex">t</script>的最大流再加上原来可行流即可（注意<script type="math/tex">s,t</script>和<script type="math/tex">ss,tt</script>的区别）。</p><p>为什么这样就对了呢？</p><p>这样做的结果肯定是最大，下面我们来考虑这个结果的可行性。</p><p>首先这样一定是满足第一个条件的，即每条边都在<script type="math/tex">[l_i,r_i]</script>中间，因为我们已经把<script type="math/tex">l_i</script>的流量拿出来了，所以这张图不管怎么跑都不会突破流量下界。</p><p>考虑第二个条件，我们考虑求解最大流的过程，可以发现每次找增广路的时候，任意一个点（除了<script type="math/tex">s,t</script>）流入流量与流出流量的差永远不会改变（当然在普通求最大流的时候这个差就是<script type="math/tex">0</script>）。那么，我们在除去<script type="math/tex">ss,tt</script>及相邻的边的网络上跑完最大流之后，每个点流入流量和流出流量的差与之前相同，因此再加上<script type="math/tex">ss</script>和<script type="math/tex">tt</script>相关的流量，仍然是守恒的。</p><p>为什么差不变呢？对于一个<script type="math/tex">u\neq s,t</script>，记这个点当前的流入流量减流出流量为<script type="math/tex">w[u]</script>，每次增广到这个点，我们从一条边进来并从一条边出去。进来的时候，有两种可能：退回一个原本出去的流或者新增一个进来的流，不管怎么样，设流量为<script type="math/tex">v</script>，都会使<script type="math/tex">w[u]</script>增加<script type="math/tex">v</script>。而出去的时候，也有两种可能：退回一个原本进来的流或者新增一个出去的流，同理，不管怎么样，都会使<script type="math/tex">w[u]</script>减少<script type="math/tex">v</script>，因此，<script type="math/tex">w[u]</script>始终不变。</p><p>具体实现的时候，跑完可行流后不需要去除<script type="math/tex">ss,tt</script>，也不用去除相关的边，<script type="math/tex">t</script>到<script type="math/tex">s</script>的边也不用去除，直接跑<script type="math/tex">s->t</script>的最大流就是答案。因为<script type="math/tex">ss</script>的出边和<script type="math/tex">tt</script>的入边已经满流，所以不会被增广，<script type="math/tex">t</script>到<script type="math/tex">s</script>的反向边会把<script type="math/tex">t</script>到<script type="math/tex">s</script>上原有的流量（即原来可行流流量）加上，所以就是最后的答案。</p><h1 id="有源汇上下界最小流"><a href="#有源汇上下界最小流" class="headerlink" title="有源汇上下界最小流"></a>有源汇上下界最小流</h1><h2 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h2><p>有一个有源汇的网络，在第<script type="math/tex">i</script>条边流量要求在<script type="math/tex">[l_i,r_i]</script>之间，且流量守恒的前提下，要求流量最小。</p><h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h2><p>同样地，我们先跑出一个可行流，但是可行流也不一定是最小流，所以我们要对它进行调整。</p><p>我们如果找一条从<script type="math/tex">s</script>到<script type="math/tex">t</script>的路径，去掉这条路径上的流量后仍然满足流量下限，那么我们就找到了一个更小的流。但是，并没有算法能够算出“去掉尽量多的流且仍满足条件”。</p><p>怎么办呢？考虑网络中的反向边，反向边流量增加相当于正向边退流，因此，我们的目标实际上是想让反向边的流量最大。那么，我们在除去所有附加边的残量网络上跑一遍<script type="math/tex">t->s</script>的最大流，并用可行流量减掉它即可。</p><p>为什么这是对的呢？考虑任何一条<script type="math/tex">t->s</script>的路径，它唯一对应了一条<script type="math/tex">s->t</script>的路径（路径上所有边的反向边构成的），我们选择了这条<script type="math/tex">t->s</script>的路径的流量，就相当于撤销了一条<script type="math/tex">s->t</script>的路径流量，而我们的目的是撤销一些<script type="math/tex">s->t</script>的路径使得撤销的流量最大，那么相当于选择一些<script type="math/tex">t->s</script>的路径使得选择的流量最大，即<script type="math/tex">t->s</script>的最大流。</p><p>注意这个算法在求完可行流后要把附加边（即有关<script type="math/tex">ss,tt</script>的边和<script type="math/tex">t->s</script>的边）都删掉再跑<script type="math/tex">t->s</script>的最大流。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;上下界网络流&quot;&gt;&lt;a href=&quot;#上下界网络流&quot; class=&quot;headerlink&quot; title=&quot;上下界网络流&quot;&gt;&lt;/a&gt;上下界网络流&lt;/h1&gt;&lt;p&gt;在一类网络流问题中，我们对每条边的流量，不仅有上界限制，还有下界限制，即第&lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;条边流量要在&lt;script type=&quot;math/tex&quot;&gt;[l_i,r_i]&lt;/script&gt;中，由此引申出来的一些问题（可行流，最大流），我们可以用上下界网络流来解决。&lt;/p&gt;
&lt;p&gt;实际上，一个可行的网络流满足以下条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;每条边的流量在流量限制内。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于&lt;script type=&quot;math/tex&quot;&gt;\forall u\neq s,t&lt;/script&gt;，都有&lt;script type=&quot;math/tex&quot;&gt;\sum w(v,u)=\sum w(u,v)&lt;/script&gt;，即每个点的流入流量等于流出流量，称为流量守恒，这个思想是我们讨论的核心。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来，我们来逐步探索上下界网络流的几种形式。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://cmwqf.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="网络流" scheme="http://cmwqf.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>浅谈李超线段树</title>
    <link href="http://cmwqf.github.io/2020/05/18/%E6%B5%85%E8%B0%88%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://cmwqf.github.io/2020/05/18/%E6%B5%85%E8%B0%88%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91/</id>
    <published>2020-05-18T02:02:20.000Z</published>
    <updated>2024-03-06T06:29:00.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="李超线段树"><a href="#李超线段树" class="headerlink" title="李超线段树"></a>李超线段树</h1><p>有的时候，我们会遇到这样一类问题。</p><p>有<script type="math/tex">n</script>个操作，每次操作有两种：</p><ol><li><p>插入一条线段<script type="math/tex">y=kx+b\quad(l\le x\le r)</script>。</p></li><li><p>查询<script type="math/tex">x=x_0</script>时最大的<script type="math/tex">y</script>是多少。</p></li></ol><p>这个时候，我们就需要用到李超线段树。</p><span id="more"></span><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>对于一类问题，有很多个候选答案，暴力方法是每次一个个<script type="math/tex">check</script>更新答案，但是这样复杂度太高。一个重要的优化思想就是减少候选答案的数量，把不可能成为最优解的候选项尽量剔除，使得复杂度达到可以接受的结果。李超线段树根本上用的就是这个思想。</p><p>考虑一个区间，如果某个线段在这个区间内被另外一个线段完全覆盖，那么这个线段在这个区间内就是无效的，因为它随时可以被另一线段来代替。</p><p>我们考虑对于<script type="math/tex">x</script>轴开一棵线段树，每个节点<script type="math/tex">[l,r]</script>记录所有完全包含<script type="math/tex">[l,r]</script>的线段中，<script type="math/tex">x=mid</script>时<script type="math/tex">y</script>最大的线段编号。</p><p>显然我们不可能每次加入一个线段就更新到底，那么我们采用标记持久化的方法来更新。</p><p>每次加入一条线段到这个节点（此时线段完全覆盖了<script type="math/tex">[l,r]</script>），步骤为：</p><ol><li><p>我们先看这个节点是否已经记录线段，如果否，则记录当前线段并返回。</p></li><li><p>看加入的线段如果覆盖当前节点的线段，更新当前节点线段并返回。</p></li><li><p>如果当前节点的线段覆盖加入线段，直接返回。</p></li><li><p>否则，我们看两个线段哪个是<script type="math/tex">mid</script>上的较大值，设为<script type="math/tex">l1</script>，另一个设为<script type="math/tex">l2</script>，那么我们将当前节点线段设为<script type="math/tex">l1</script>并递归<script type="math/tex">l2</script>。</p></li></ol><p>为什么最后一步只需递归一边呢？很显然，因为是一次函数，此时<script type="math/tex">l1</script>已经在一边完全覆盖了<script type="math/tex">l2</script>，所以<script type="math/tex">l2</script>在那一边没有存在的意义，所以只需递归更新另外一边。</p><p>复杂度分析很简单，每次更新会到定位到<script type="math/tex">\log n</script>个区间，然后最多会进行<script type="math/tex">\log n</script>次递归修改，因此修改复杂度为<script type="math/tex">O(n\log^2n)</script>。</p><p>每次查询的时候，我们只需从线段树根节点到<script type="math/tex">x_0</script>的叶子节点路径上遇到的所有节点记录的线段的<script type="math/tex">y</script>取<script type="math/tex">max</script>即可。</p><p>这样为什么是正确的呢？</p><p>因为最终的答案一定在从根节点到叶子节点的<script type="math/tex">\log n</script>个线段中产生。考虑插入的过程，如果一个线段没有被完全覆盖的话会继续递归更新下面的节点，而如果从根节点到叶子节点都没有出现这个线段，那么它一定因为被完全覆盖而丢弃了，所以不可能成为答案。</p><p>查询的复杂度自然是<script type="math/tex">O(n\log n)</script>。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>插入的时候，比较是否覆盖只要把区间<script type="math/tex">[l,r]</script>中<script type="math/tex">l,r</script>的坐标分别带入两个函数来比较即可。</p><p>判断中点坐标哪个更大时，实际上我们并不需要把中点坐标带入两个函数进行比较，我们只需要求出两个函数的交点横坐标，看它在中点的左侧<script type="math/tex">or</script>右侧即可。</p><p>另外，我们要写两个函数来插入，第一个函数是为了在线段树上定位区间，第二个则为了进行真正的插入操作（也可以写成一个，但是写成两个更清晰一点）。</p><p>注意如果题目要求离散化，我们应该比较的是交点<script type="math/tex">x</script>与<script type="math/tex">t[\frac{l+r}{2}]</script>，而不是<script type="math/tex">\frac{t[l]+t[r]}{2}</script>。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">double</span> k, b;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">&#125;tree[maxN * <span class="number">4</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> id, <span class="keyword">double</span> k, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[node] = (Segment)&#123;id, k, b, <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> id, <span class="keyword">double</span> k, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tree[node].flag) &#123; <span class="built_in">update</span>(node, id, k, b); <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> l1 = l * tree[node].k + tree[node].b, r1 = r * tree[node].k + tree[node].b;</span><br><span class="line">    <span class="keyword">double</span> l2 = l * k + b, r2 = r * k + b;</span><br><span class="line">    <span class="keyword">if</span>(l1 &gt;= l2 &amp;&amp; r1 &gt;= r2) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(l2 &gt;= l1 &amp;&amp; r2 &gt;= r1) &#123; <span class="built_in">update</span>(node, id, k, b); <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">double</span> x = (tree[node].b - b) / (k - tree[node].k);</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 &gt; l2) <span class="built_in">change</span>(ls, l, mid, tree[node].id, tree[node].k, tree[node].b), <span class="built_in">update</span>(node, id, k, b);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">change</span>(ls, l, mid, id, k, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(r1 &gt; r2) <span class="built_in">change</span>(rs, mid + <span class="number">1</span>, r, tree[node].id, tree[node].k, tree[node].b), <span class="built_in">update</span>(node, id, k, b);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">change</span>(rs, mid + <span class="number">1</span>, r, id, k, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> id, <span class="keyword">double</span> k, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= l &amp;&amp; r &lt;= y) &#123; <span class="built_in">change</span>(node, l, r, id, k, b); <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(ls, l, mid, x, y, id, k, b);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid) <span class="built_in">modify</span>(rs, mid + <span class="number">1</span>, r, x, y, id, k, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> tree[node].k * x + tree[node].b;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">double</span> ans = tree[node].k * x + tree[node].b;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) ans = <span class="built_in">max</span>(ans, <span class="built_in">query</span>(ls, l, mid, x));</span><br><span class="line">    <span class="keyword">else</span> ans = <span class="built_in">max</span>(ans, <span class="built_in">query</span>(rs, mid + <span class="number">1</span>, r, x));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;李超线段树&quot;&gt;&lt;a href=&quot;#李超线段树&quot; class=&quot;headerlink&quot; title=&quot;李超线段树&quot;&gt;&lt;/a&gt;李超线段树&lt;/h1&gt;&lt;p&gt;有的时候，我们会遇到这样一类问题。&lt;/p&gt;
&lt;p&gt;有&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;个操作，每次操作有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;插入一条线段&lt;script type=&quot;math/tex&quot;&gt;y=kx+b\quad(l\le x\le r)&lt;/script&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查询&lt;script type=&quot;math/tex&quot;&gt;x=x_0&lt;/script&gt;时最大的&lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt;是多少。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个时候，我们就需要用到李超线段树。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://cmwqf.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="李超线段树" scheme="http://cmwqf.github.io/tags/%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>浅谈斯特林反演</title>
    <link href="http://cmwqf.github.io/2020/05/06/%E6%B5%85%E8%B0%88%E6%96%AF%E7%89%B9%E6%9E%97%E5%8F%8D%E6%BC%94/"/>
    <id>http://cmwqf.github.io/2020/05/06/%E6%B5%85%E8%B0%88%E6%96%AF%E7%89%B9%E6%9E%97%E5%8F%8D%E6%BC%94/</id>
    <published>2020-05-06T03:31:17.000Z</published>
    <updated>2024-03-06T06:29:00.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="斯特林反演"><a href="#斯特林反演" class="headerlink" title="斯特林反演"></a>斯特林反演</h1><p>定义第一类斯特林数符号为<script type="math/tex">{n\brack i}</script>，第二类斯特林数为<script type="math/tex">{n\brace i}</script>。</p><p>当我们遇到一类计数问题时，往往可以用到斯特林反演。</p><p>即如果我们有</p><script type="math/tex; mode=display">f[n]=\sum_{i=0}^n{n \brace i}g[i]</script><p>那么我们可以通过斯特林反演，根据<script type="math/tex">f</script>还原出<script type="math/tex">g</script>。</p><p>下面，我们就来认识一下斯特林反演。</p><span id="more"></span><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>我们首先定义<script type="math/tex">x</script>的上升幂<script type="math/tex">x^{\overline{n}}=x(x+1)...(x+n-1)</script>，下降幂<script type="math/tex">x^{\underline{n}}=x(x-1)...(x-n+1)</script>。</p><p>那么根据第二类斯特林数的性质（组合意义），我们有</p><script type="math/tex; mode=display">x^n=\sum_{i=0}^n{n\brace i}x^{\underline{i}}\tag{1}</script><p>另外，关于第一类斯特林数，我们有</p><script type="math/tex; mode=display">x^{\overline{n}}=\sum_{i=0}^n{n\brack i}x^i\tag{2}</script><p>这是为什么呢？我们考虑<script type="math/tex">dp</script>出<script type="math/tex">x^{\overline{n}}</script>的<script type="math/tex">x^i</script>项系数。</p><p>设<script type="math/tex">f(n,i)</script>表示<script type="math/tex">x^{\overline{n}}</script>中<script type="math/tex">x^i</script>项系数，那么我们考虑从<script type="math/tex">x^{\overline{n-1}}</script>转移，乘<script type="math/tex">(x+n-1)</script>，那么我们有</p><script type="math/tex; mode=display">f(n,i)=f(n-1,i-1)+(n-1)*f(n-1,i)</script><p>这个转移式恰好和第一类斯特林数的转移式是一模一样的。</p><p>那么，我们就可以用<script type="math/tex">x^i</script>把<script type="math/tex">x^{\overline{n}}</script>和<script type="math/tex">x^{\underline{n}}</script>联系起来了。</p><p>另外，实际上两者在定义上还有一种联系：</p><script type="math/tex; mode=display">(-x)^{\underline{n}}=(-1)^nx^{\overline{n}}\tag{3}</script><p>对称地，还有</p><script type="math/tex; mode=display">(-x)^{\overline{n}}=(-1)^nx^{\underline{n}}\tag{4}</script><p>这个根据定义展开就能得证。</p><p>有了这几个式子，我们就能进行斯特林反演了。</p><p>我们将<script type="math/tex">(1)</script>用<script type="math/tex">-x</script>代换<script type="math/tex">x</script>，那么</p><script type="math/tex; mode=display">(-x)^n=\sum_{i=0}^n{n\brace i}(-x)^{\underline{i}}\\(-1)^nx^n=\sum_{i=0}^n{n\brace i}(-1)^ix^{\overline{i}}\\x^n=\sum_{i=0}^n{n\brace i}(-1)^{n-i}\sum_{j=0}^i{i\brack j}x^j\\x^n=\sum_{j=0}^nx^j\sum_{i=j}^n(-1)^{n-i}{n\brace i}{i\brack j}</script><p>通过比较系数，我们有</p><script type="math/tex; mode=display">\sum_{i=m}^n(-1)^{n-i}{n\brace i}{i\brack j}=[n=m]\tag{A}</script><p>我们在<script type="math/tex">(2)</script>中用<script type="math/tex">-x</script>代换<script type="math/tex">x</script>，那么</p><script type="math/tex; mode=display">(-x)^{\overline{n}}=\sum_{i=0}^n{n\brack i}(-1)^ix^i\\(-x)^{\overline{n}}=\sum_{i=0}^n{n\brack i}(-1)^i\sum_{j=0}^i{i \brace j}x^{\underline{j}}\\(-1)^nx^{\underline{n}}=\sum_{j=0}^nx^{\underline{j}}\sum_{i=j}^n(-1)^i{n\brack i}{i\brace j}\\x^{\underline{n}}=\sum_{j=0}^nx^{\underline{j}}\sum_{i=j}^n(-1)^{n-i}{n\brack i}{i\brace j}</script><p>同样地，比较系数，我们有</p><script type="math/tex; mode=display">\sum_{i=m}^n(-1)^{n-i}{n\brack i}{i\brace j}=[n=m]\tag B</script><p>综上所述，我们有两个非常对称的式子</p><script type="math/tex; mode=display">\sum_{i=m}^n(-1)^{n-i}{n\brace i}{i\brack m}=[n=m]\\\sum_{i=m}^n(-1)^{n-i}{n\brack i}{i\brace m}=[n=m]</script><h1 id="第一个形式"><a href="#第一个形式" class="headerlink" title="第一个形式"></a>第一个形式</h1><p>有了上面两个式子，我们就可以推导出斯特林反演的公式了。</p><p>如果我们有</p><script type="math/tex; mode=display">f[n]=\sum_{i=0}^n{n\brace i}g[i]</script><p>那么</p><script type="math/tex; mode=display">g[n]=\sum_{i=0}^ng[i][i=n]\\=\sum_{i=0}^ng[i]\sum_{j=i}^n(-1)^{n-j}{n\brack j}{j\brace i}\\=\sum_{j=0}^n(-1)^{n-j}{n\brack j}\sum_{i=0}^j{j\brace i}g[i]\\=\sum_{i=0}^n(-1)^{n-i}{n\brack i}f[i]</script><p>即</p><script type="math/tex; mode=display">g[n]=\sum_{i=0}^n(-1)^{n-i}{n\brack i}f[i]\tag{1}</script><p>同样地，如果我们有</p><script type="math/tex; mode=display">f[n]=\sum_{i=0}^n{n\brack i}g[i]</script><p>那么同理也有</p><script type="math/tex; mode=display">g[n]=\sum_{i=0}^n(-1)^{n-i}{n\brace i}f[i]\tag{2}</script><p>只不过下面这个几乎不怎么用罢了。</p><p>注意到我们的推导中并没有用到<script type="math/tex">i</script>从<script type="math/tex">0</script>开始的条件，所以<script type="math/tex">i</script>从<script type="math/tex">m</script>（<script type="math/tex">m\le n</script>）开始都可以使用此式。</p><h1 id="第二个形式"><a href="#第二个形式" class="headerlink" title="第二个形式"></a>第二个形式</h1><p>实际上，有的时候，我们还会遇到</p><script type="math/tex; mode=display">f[m]=\sum_{i=m}^n{i\brace m}g[i]</script><p>那么此时，我们有</p><script type="math/tex; mode=display">g[m]=\sum_{i=m}^n(-1)^{i-m}{i\brack m}f[i]</script><p>证明过程考虑把后面的式子带入前面的式子</p><script type="math/tex; mode=display">f[m]=\sum_{i=m}^n{i\brace m}\sum_{j=i}^n(-1)^{j-i}{j\brack i}f[j]\\=\sum_{j=m}^nf[j]\sum_{i=m}^j(-1)^{j-i}{i\brace m}{j\brack i}\\=\sum_{j=m}^nf[j][j=m]\\=f[m]</script><p>故等式成立。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>在<script type="math/tex">dp</script>连通图相关问题时，往往设<script type="math/tex">f(i,j)</script>为考虑了前<script type="math/tex">i</script>个点，分成<script type="math/tex">j</script>组，<strong>不同组之间不连边，同组之间边随便选</strong>的方案数。那么对于最后的<script type="math/tex">f(n,i)</script>，设将<script type="math/tex">n</script>个点连边后分成<script type="math/tex">j</script>个联通块的答案是<script type="math/tex">g(j)</script>，那么显然每个<script type="math/tex">g(j)</script>在答案中被算了<script type="math/tex">j\brace i</script>次（将<script type="math/tex">j</script>个联通块分为<script type="math/tex">i</script>组）。即<script type="math/tex">f[i]=\sum_{j=i}^n{j\brace i}g[j]</script>。</p><p>那么，我们直接用斯特林反演来求出<script type="math/tex">g</script>了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>综上，斯特林反演和二项式反演形式上有很大的相似性，只是系数不同而已。</p><p>实际上，这类反演都基于反演原理：</p><p>若有<script type="math/tex">f,g,u,v</script>满足以下关系</p><script type="math/tex; mode=display">f[n]=\sum_{i=0}^nu[n][i]*g[i]</script><p>那么</p><script type="math/tex; mode=display">g[n]=\sum_{i=0}^nv[n][i]*f[i]</script><p>这个式子成立当且仅当</p><script type="math/tex; mode=display">\sum_{i=m}^nu[n][i]*v[i][m]=[n=m]</script><p>直接带入即证。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;斯特林反演&quot;&gt;&lt;a href=&quot;#斯特林反演&quot; class=&quot;headerlink&quot; title=&quot;斯特林反演&quot;&gt;&lt;/a&gt;斯特林反演&lt;/h1&gt;&lt;p&gt;定义第一类斯特林数符号为&lt;script type=&quot;math/tex&quot;&gt;{n\brack i}&lt;/script&gt;，第二类斯特林数为&lt;script type=&quot;math/tex&quot;&gt;{n\brace i}&lt;/script&gt;。&lt;/p&gt;
&lt;p&gt;当我们遇到一类计数问题时，往往可以用到斯特林反演。&lt;/p&gt;
&lt;p&gt;即如果我们有&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
f[n]=\sum_{i=0}^n{n \brace i}g[i]&lt;/script&gt;&lt;p&gt;那么我们可以通过斯特林反演，根据&lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt;还原出&lt;script type=&quot;math/tex&quot;&gt;g&lt;/script&gt;。&lt;/p&gt;
&lt;p&gt;下面，我们就来认识一下斯特林反演。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://cmwqf.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="组合数学" scheme="http://cmwqf.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="容斥原理" scheme="http://cmwqf.github.io/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>浅谈卢卡斯定理及扩展</title>
    <link href="http://cmwqf.github.io/2020/04/26/%E6%B5%85%E8%B0%88%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86%E5%8F%8A%E6%89%A9%E5%B1%95/"/>
    <id>http://cmwqf.github.io/2020/04/26/%E6%B5%85%E8%B0%88%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86%E5%8F%8A%E6%89%A9%E5%B1%95/</id>
    <published>2020-04-26T12:40:47.000Z</published>
    <updated>2024-03-06T06:29:00.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="卢卡斯定理"><a href="#卢卡斯定理" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h1><p>卢卡斯定理是用来快速计算组合数的。在一些题目中，我们要求<script type="math/tex">\binom{n}{m}\bmod P</script>，但是<script type="math/tex">n,m</script>很大，<script type="math/tex">P</script>却很小（<script type="math/tex">P\le 10^5</script>），那么卢卡斯定理就是用来加速这个过程的。</p><p>普通的卢卡斯定理要求<script type="math/tex">P</script>为质数，而扩展卢卡斯中<script type="math/tex">P</script>可以是合数。</p><p>卢卡斯定理十分简洁：</p><script type="math/tex; mode=display">\binom{n}{m}\bmod P=\binom{\lfloor\frac{n}{P}\rfloor}{\lfloor\frac{m}{P}\rfloor}*\binom{n\bmod P}{m\bmod P}\bmod P</script><span id="more"></span><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span> * fac[n] * inv[m] % P * inv[n - m] % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Lucas</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n || !m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span> * <span class="built_in">lucas</span>(n / P, m / P) * <span class="built_in">C</span>(n % P, m % P) % P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="扩展卢卡斯"><a href="#扩展卢卡斯" class="headerlink" title="扩展卢卡斯"></a>扩展卢卡斯</h1><p>实际上，扩展卢卡斯与卢卡斯定理似乎并无太大关联，只需掌握中国剩余定理与<script type="math/tex">exgcd</script>即可学习扩展卢卡斯定理。</p><p>如果<script type="math/tex">P</script>是合数，考虑设<script type="math/tex">P=p_1^{a_1}p_2^{a_2}...</script>，那么如果我们对于每个<script type="math/tex">i</script>，求出<script type="math/tex">\binom{n}{m}\equiv a_i\pmod{p_i^{a_i}}</script>，就可以用中国剩余定理来进行合并。</p><p>那么，问题就转变为了如何求<script type="math/tex">\binom{n}{m}\bmod p^x</script>。</p><p>考虑<script type="math/tex">\binom{n}{m}=\frac{n!}{m!(n-m)!}</script>，我们只需求出<script type="math/tex">n!\bmod p^x</script>即可。</p><p>我们把所有<script type="math/tex">p</script>的倍数全部提取出来，那么就有</p><script type="math/tex; mode=display">n!=1*2*3...*n\\=1*2*...*(p-1)*(p+1)*...*(2p-1)*(2p+1)...*(p*2p*3p*...)\\=1*2*...*(p-1)*(p+1)...*p^t*t!</script><p>其中<script type="math/tex">t= \lfloor\frac{n}{p}\rfloor</script>，那么我们发现实际上我们成功转化为了一个类似卢卡斯定理的子问题。</p><p>因为求逆元的时候要求数与模数互质，所以我们可以把<script type="math/tex">\binom{n}{m}</script>中<script type="math/tex">p</script>的次数预处理出来，先乘上去，那么每次递归子问题的时候就不需要管分出来的<script type="math/tex">p</script>的次数了。</p><p>后面部分交给递归，现在我们观察前面的部分模<script type="math/tex">p^x</script>是循环的（当然还会有一些余项），那么我们可以计算出前面<script type="math/tex">p^x</script>以内的结果然后<script type="math/tex">\lfloor\frac{n}{p}\rfloor</script>次方一下，然后再暴力计算一下剩下的余项即可。</p><p>那么，对于每个<script type="math/tex">p^x</script>，时间复杂度为<script type="math/tex">O(p^xlog_pn)</script>。</p><p>所以整个算法的时间复杂度为<script type="math/tex">O(\sum p_i^{a_i}log_pn)</script>，所以当<script type="math/tex">\forall i,p_i\le 10^5</script>时可以使用扩展卢卡斯定理。</p><p>注意求逆元的时候，因为模数不是质数，所以应该用<script type="math/tex">exgcd</script>求逆元而不能用费马小定理。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line">LL n, m, P;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">mpow</span><span class="params">(LL a, LL x, LL p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>) ans = ans * a % p;</span><br><span class="line">        a = a * a % p;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(LL a, LL b, LL &amp;x, LL &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) &#123; x = <span class="number">1</span>; y = <span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">    LL tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp - a / b * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">inverse</span><span class="params">(LL a, LL p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">exgcd</span>(a, p, x, y);</span><br><span class="line">    <span class="keyword">return</span> (x % p + p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">getFac</span><span class="params">(LL n, LL x, LL p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    LL s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= p; i++)</span><br><span class="line">        <span class="keyword">if</span>(i % x) s = s * i % p;</span><br><span class="line">    s = <span class="built_in">mpow</span>(s, n / p, p);</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i &lt;= n % p; i++)</span><br><span class="line">        <span class="keyword">if</span>(i % x) s = s * i % p;</span><br><span class="line">    <span class="keyword">return</span> s * <span class="built_in">getFac</span>(n / x, x, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">C</span><span class="params">(LL n, LL m, LL x, LL p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL t = n; t; t /= x) s += t / x;</span><br><span class="line">    <span class="keyword">for</span>(LL t = m; t; t /= x) s -= t / x;</span><br><span class="line">    <span class="keyword">for</span>(LL t = n - m; t; t /= x) s -= t / x;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mpow</span>(x, s, p) * <span class="built_in">getFac</span>(n, x, p) % p * <span class="built_in">inverse</span>(<span class="built_in">getFac</span>(m, x, p), p) % p * <span class="built_in">inverse</span>(<span class="built_in">getFac</span>(n - m, x, p), p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">ExLucas</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>, T = P;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">2</span>; i * i &lt;= T; i++)</span><br><span class="line">        <span class="keyword">if</span>(T % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            LL p = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(T % i == <span class="number">0</span>) p *= i, T /= i;</span><br><span class="line">            ans = (ans + (P / p) * <span class="built_in">inverse</span>(P / p, p) % P * <span class="built_in">C</span>(n, m, i, p) % P) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(T &gt; <span class="number">1</span>) ans = (ans + (P / T) * <span class="built_in">inverse</span>(P / T, T) % P * <span class="built_in">C</span>(n, m, T, T) % P) % P;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>, &amp;n, &amp;m, &amp;P);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">ExLucas</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;卢卡斯定理&quot;&gt;&lt;a href=&quot;#卢卡斯定理&quot; class=&quot;headerlink&quot; title=&quot;卢卡斯定理&quot;&gt;&lt;/a&gt;卢卡斯定理&lt;/h1&gt;&lt;p&gt;卢卡斯定理是用来快速计算组合数的。在一些题目中，我们要求&lt;script type=&quot;math/tex&quot;&gt;\binom{n}{m}\bmod P&lt;/script&gt;，但是&lt;script type=&quot;math/tex&quot;&gt;n,m&lt;/script&gt;很大，&lt;script type=&quot;math/tex&quot;&gt;P&lt;/script&gt;却很小（&lt;script type=&quot;math/tex&quot;&gt;P\le 10^5&lt;/script&gt;），那么卢卡斯定理就是用来加速这个过程的。&lt;/p&gt;
&lt;p&gt;普通的卢卡斯定理要求&lt;script type=&quot;math/tex&quot;&gt;P&lt;/script&gt;为质数，而扩展卢卡斯中&lt;script type=&quot;math/tex&quot;&gt;P&lt;/script&gt;可以是合数。&lt;/p&gt;
&lt;p&gt;卢卡斯定理十分简洁：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\binom{n}{m}\bmod P=\binom{\lfloor\frac{n}{P}\rfloor}{\lfloor\frac{m}{P}\rfloor}*\binom{n\bmod P}{m\bmod P}\bmod P&lt;/script&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://cmwqf.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数论" scheme="http://cmwqf.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>浅谈竞赛图</title>
    <link href="http://cmwqf.github.io/2020/04/22/%E6%B5%85%E8%B0%88%E7%AB%9E%E8%B5%9B%E5%9B%BE/"/>
    <id>http://cmwqf.github.io/2020/04/22/%E6%B5%85%E8%B0%88%E7%AB%9E%E8%B5%9B%E5%9B%BE/</id>
    <published>2020-04-22T09:36:37.000Z</published>
    <updated>2024-03-06T06:29:00.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="竞赛图"><a href="#竞赛图" class="headerlink" title="竞赛图"></a>竞赛图</h1><p>定义：<script type="math/tex">n</script>个点的有向图，若满足<strong>任意两点都有且仅有一条有向边</strong>，就称此有向图为竞赛图。</p><p>为什么竞赛图要专门分析呢？因为竞赛图有很多非常有趣的性质。</p><span id="more"></span><h1 id="性质一"><a href="#性质一" class="headerlink" title="性质一"></a>性质一</h1><p>将竞赛图缩点之后，缩成的所有强连通分量按照出度从小到大排成的序列，一定满足第<script type="math/tex">i</script>个强连通分量与所有<script type="math/tex">j>i</script>的强连通分量<script type="math/tex">j</script>都有一条<script type="math/tex">i->j</script>的边。</p><p>证明：考虑归纳，我们加进来一个新的强连通分量，如果当前所有强连通分量都连向它，那么将它放在序列尾；如果它连向所有强连通分量，那么将它放在序列头；否则，所有它连向的强连通分量一定在连向它的强连通分量的后面（否则就有环，矛盾），那么将它放在对应的分界点处即可。</p><h1 id="性质二"><a href="#性质二" class="headerlink" title="性质二"></a>性质二</h1><p>竞赛图的所有强连通分量都存在一条哈密顿回路。</p><p>证明：考虑归纳，仍然考虑当前强连通分量构成的序列（即性质一所述的那个序列），目前所有强连通分量都满足存在一条哈密顿回路。现在我们加入一个点，如果它自己构成一个单独的强连通分量，那么将它直接加入序列（类似性质一）；否则，我们找到最左边的它连向的那个强连通分量<script type="math/tex">x</script>，再找到最右边的连向它的强连通分量<script type="math/tex">y</script>，那么所有<script type="math/tex">x,y</script>之间的及当前这个点构成了一个新的强连通分量，那么显然这个新强连通分量也存在一条哈密顿回路（考虑从当前点走到最左边强连通分量某个点开始每次先把其内部的点走一遍再走到下一个强连通分量的某个点，一直走到最右边强连通分量，然后走到当前点本身）。</p><h1 id="性质三"><a href="#性质三" class="headerlink" title="性质三"></a>性质三</h1><p>竞赛图存在一条<strong>哈密顿路径</strong>。</p><p>证明：因为每个强连通分量都有一条哈密顿回路，直接沿哈密顿回路走完每个强连通分量的所有点然后再走向下个强连通分量即可。</p><h1 id="性质四"><a href="#性质四" class="headerlink" title="性质四"></a>性质四</h1><p>竞赛图里，任意大小为<script type="math/tex">n>1</script>的强连通分量中，大小为<script type="math/tex">[3,n]</script>的环均存在。</p><p>证明：首先，<script type="math/tex">n=3</script>成立，那么<script type="math/tex">n\ge 4</script>时，我们只需证明存在大小为<script type="math/tex">n-1</script>的环（即存在大小为<script type="math/tex">n-1</script>的强强连通分量）即可。</p><p>考虑我们从强连通分量中提出一个点，如果剩下的只有一个强连通分量，那么大小为<script type="math/tex">n-1</script>的环已经出现。</p><p>否则，剩下的强连通分量一定构成一个性质一所述的序列，根据性质三，这个序列存在一条哈密顿路径，我们按照原来构造的路径上某个联通分量的最后一个点不走，直接跳到下一个联通分量，这样一条新的路径加上我们提出来的这个点，就构成了一个大小为<script type="math/tex">n-1</script>的环。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;竞赛图&quot;&gt;&lt;a href=&quot;#竞赛图&quot; class=&quot;headerlink&quot; title=&quot;竞赛图&quot;&gt;&lt;/a&gt;竞赛图&lt;/h1&gt;&lt;p&gt;定义：&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;个点的有向图，若满足&lt;strong&gt;任意两点都有且仅有一条有向边&lt;/strong&gt;，就称此有向图为竞赛图。&lt;/p&gt;
&lt;p&gt;为什么竞赛图要专门分析呢？因为竞赛图有很多非常有趣的性质。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://cmwqf.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="图论" scheme="http://cmwqf.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>浅谈询问分块</title>
    <link href="http://cmwqf.github.io/2020/04/20/%E6%B5%85%E8%B0%88%E8%AF%A2%E9%97%AE%E5%88%86%E5%9D%97/"/>
    <id>http://cmwqf.github.io/2020/04/20/%E6%B5%85%E8%B0%88%E8%AF%A2%E9%97%AE%E5%88%86%E5%9D%97/</id>
    <published>2020-04-20T03:48:25.000Z</published>
    <updated>2024-03-06T06:29:00.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="询问分块"><a href="#询问分块" class="headerlink" title="询问分块"></a>询问分块</h1><p>什么是询问分块？</p><p>对于一些题目，它的操作我们无法用高级数据结构在<script type="math/tex">log_2n</script>时间复杂度内解决，那么，我们可以考虑，<strong>对询问分块，定期重构</strong>，使复杂度降为<script type="math/tex">\sqrt{n}</script>级别。</p><p>注意，这个询问分块的适用范围还是比较广泛的，因为它只需要答案重构复杂度为<script type="math/tex">O(n)</script>，且对于一个修改，我们能很快，如在<script type="math/tex">O(1)</script>或<script type="math/tex">O(log_2n)</script>的时间内，计算出它对某个询问的贡献，那么我们就可以用这种对询问分块的方法。</p><p>实际上，对询问分块可以看成一种强大的暴力。</p><span id="more"></span><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>我们考虑两种暴力：</p><p>第一种，对于一个修改，我们用它暴力更新所有答案（例如单点加，区间查询，我们每加一个数，就修改所有前缀和）；第二种，对于一个询问，我们暴力枚举前面所有的修改，计算其对当前询问的影响。</p><p>这两种暴力，时间复杂度都是<script type="math/tex">O(1)-O(n)</script>的，只不过第一种是询问<script type="math/tex">O(1)</script>，修改<script type="math/tex">O(n)</script>，第二种为询问<script type="math/tex">O(n)</script>，修改<script type="math/tex">O(1)</script>。那么，我们能不能把这两种暴力结合起来呢？</p><p>实际上，对操作分块，定期重构，就是这两种暴力的结合。</p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p>我们将所有的操作（查询和修改）分块，然后对于一个块的修改，我们暴力更新这个块内的所有询问（或者，对于一个块的询问，我们暴力遍历这个块的所有修改，计算贡献）。当这一个块结束的时候，我们用这个块内所有修改，重构所有的答案。</p><p>这就是整个流程，是不是非常简单？</p><p>时间复杂度呢？我们考虑设<script type="math/tex">B</script>个元素为一个块。</p><p>那么，对于第一种操作，每个修改会更新<script type="math/tex">B</script>个询问（或者每个询问会访问<script type="math/tex">B</script>个修改），这一部分时间复杂度为<script type="math/tex">O(nB)</script>；对于第二种操作，每次重构答案是<script type="math/tex">O(n)</script>，所以第二种操作复杂度为<script type="math/tex">O(n\frac{n}{B})</script>。</p><p>那么总复杂度为<script type="math/tex">O(nB+n\frac{n}{B})</script>，由均值不等式得当<script type="math/tex">B=\sqrt{n}</script>时时间复杂度为<script type="math/tex">O(n\sqrt{n})</script>。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>对于许多一般性问题，可以直接应用此思想。</p><p>对于有些树上问题，每次修改对询问的影响涉及所有点的更新，我们可以对整棵树在这个块内涉及的修改点建成一棵虚树，每次修改在虚树上面跑，也可以保证复杂度。</p><p>如果读者实在想不出有什么问题要建虚树，请看这道经典<strong>虚树加操作分块</strong>的题：</p><p><a href="https://codeforces.com/contest/966/problem/E">CF966E May Holidays</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;询问分块&quot;&gt;&lt;a href=&quot;#询问分块&quot; class=&quot;headerlink&quot; title=&quot;询问分块&quot;&gt;&lt;/a&gt;询问分块&lt;/h1&gt;&lt;p&gt;什么是询问分块？&lt;/p&gt;
&lt;p&gt;对于一些题目，它的操作我们无法用高级数据结构在&lt;script type=&quot;math/tex&quot;&gt;log_2n&lt;/script&gt;时间复杂度内解决，那么，我们可以考虑，&lt;strong&gt;对询问分块，定期重构&lt;/strong&gt;，使复杂度降为&lt;script type=&quot;math/tex&quot;&gt;\sqrt{n}&lt;/script&gt;级别。&lt;/p&gt;
&lt;p&gt;注意，这个询问分块的适用范围还是比较广泛的，因为它只需要答案重构复杂度为&lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt;，且对于一个修改，我们能很快，如在&lt;script type=&quot;math/tex&quot;&gt;O(1)&lt;/script&gt;或&lt;script type=&quot;math/tex&quot;&gt;O(log_2n)&lt;/script&gt;的时间内，计算出它对某个询问的贡献，那么我们就可以用这种对询问分块的方法。&lt;/p&gt;
&lt;p&gt;实际上，对询问分块可以看成一种强大的暴力。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://cmwqf.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="分块" scheme="http://cmwqf.github.io/tags/%E5%88%86%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>浅谈虚树</title>
    <link href="http://cmwqf.github.io/2020/04/17/%E6%B5%85%E8%B0%88%E8%99%9A%E6%A0%91/"/>
    <id>http://cmwqf.github.io/2020/04/17/%E6%B5%85%E8%B0%88%E8%99%9A%E6%A0%91/</id>
    <published>2020-04-17T09:46:45.000Z</published>
    <updated>2024-03-06T06:29:00.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚树"><a href="#虚树" class="headerlink" title="虚树"></a>虚树</h1><p>有的时候，题目给你一棵树，然后有<script type="math/tex">q</script>组询问，每组询问为与树上有关的<script type="math/tex">k</script>个点的相关问题，而这个问题如果只有一个询问的话，可以用树形<script type="math/tex">dp</script>轻松解决，那么我们可以考虑每次只在这<script type="math/tex">k</script>个点及相关的点构成的树上进行<script type="math/tex">dp</script>，时间复杂度为<script type="math/tex">O(\sum klog_2 k)</script>。</p><span id="more"></span><h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><p>虚树是由哪些点组成的呢？</p><p>我们姑且称每次询问的<script type="math/tex">k</script>个点为关键节点，虚树由这<script type="math/tex">k</script>个点和任意两点的<script type="math/tex">LCA</script>构成。</p><p>这个规模看起来很大，但实际上，把这<script type="math/tex">k</script>个点按照<script type="math/tex">dfs</script>序排好序，那么在序列中相邻两点的<script type="math/tex">LCA</script>构成的点集就是任意两点的<script type="math/tex">LCA</script>的点集，这个可以画图来证明。</p><p>一般来说，虚树还要把根节点看为关键节点，有利于做题，只不过统计答案时不统计它就是了。</p><p>可以看出，如果边可以压缩，那么在这棵树上进行<script type="math/tex">dp</script>和在原树上<script type="math/tex">dp</script>是等价的，但此时点的规模就要小很多了，一共只有<script type="math/tex">2k</script>个点。</p><h1 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h1><p>那么，我们如何构造虚树呢？</p><p>首先，我们把这<script type="math/tex">k</script>个点按照<script type="math/tex">dfs</script>序排好序，然后我们用一个单调栈来维护树上的一条链。</p><p>我们考虑加入一个点<script type="math/tex">u</script>，我们求出它与栈顶元素的<script type="math/tex">LCA</script>，记为<script type="math/tex">l</script>，如果<script type="math/tex">l=stk[top]</script>，那么说明这个点也在当前栈表示的这条链上，加入栈即可。</p><p>否则，说明这个点开辟了一个新的链，因为我们的栈中始终维护的是当前节点与根节点构成的链，所以我们要把原来的栈顶元素一个个弹出，并连边<script type="math/tex">(stk[top-1],stk[top])</script>，直到<script type="math/tex">stk[top]</script>是<script type="math/tex">l</script>的祖先为止。</p><p>此时我们看<script type="math/tex">stk[top]</script>是否等于<script type="math/tex">l</script>，如果是，直接加入当前节点即可，否则，我们还要把<script type="math/tex">l</script>给加进去。</p><p>别忘了，如果我们要加<script type="math/tex">l</script>进去，记得把<script type="math/tex">l</script>和上一个弹出栈的点连边。</p><p>最后再把<script type="math/tex">u</script>加进去即可。</p><p><script type="math/tex">LCA</script>可以<script type="math/tex">O(nlog_2n)-O(1)</script>求，主要是排序复杂度为<script type="math/tex">O(klog_2k)</script>，故总复杂度为<script type="math/tex">O(\sum klog_2 k)</script>。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> dfn[a] &lt; dfn[b]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + k + <span class="number">1</span>, comp);</span><br><span class="line">    </span><br><span class="line">    stk[ top = <span class="number">1</span> ] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = a[i];</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">LCA</span>(x, stk[top]);</span><br><span class="line">        <span class="keyword">if</span>(l != stk[top])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(dfn[l] &lt; dfn[ stk[top - <span class="number">1</span>] ])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">add</span>(stk[top - <span class="number">1</span>], stk[top]);</span><br><span class="line">                top --;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dfn[l] &gt; dfn[ stk[top - <span class="number">1</span>] ]) <span class="built_in">add</span>(l, stk[top]), stk[top] = l;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">add</span>(l, stk[top]), top --;</span><br><span class="line">        &#125;</span><br><span class="line">        stk[++ top] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(top &gt; <span class="number">1</span>) <span class="built_in">add</span>(stk[top - <span class="number">1</span>], stk[top]), top --;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;虚树&quot;&gt;&lt;a href=&quot;#虚树&quot; class=&quot;headerlink&quot; title=&quot;虚树&quot;&gt;&lt;/a&gt;虚树&lt;/h1&gt;&lt;p&gt;有的时候，题目给你一棵树，然后有&lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt;组询问，每组询问为与树上有关的&lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;个点的相关问题，而这个问题如果只有一个询问的话，可以用树形&lt;script type=&quot;math/tex&quot;&gt;dp&lt;/script&gt;轻松解决，那么我们可以考虑每次只在这&lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;个点及相关的点构成的树上进行&lt;script type=&quot;math/tex&quot;&gt;dp&lt;/script&gt;，时间复杂度为&lt;script type=&quot;math/tex&quot;&gt;O(\sum klog_2 k)&lt;/script&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://cmwqf.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="dp" scheme="http://cmwqf.github.io/tags/dp/"/>
    
    <category term="虚树" scheme="http://cmwqf.github.io/tags/%E8%99%9A%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[LOJ3284]Exercise</title>
    <link href="http://cmwqf.github.io/2020/04/10/LOJ3284-Exercise/"/>
    <id>http://cmwqf.github.io/2020/04/10/LOJ3284-Exercise/</id>
    <published>2020-04-10T04:02:34.000Z</published>
    <updated>2024-03-06T06:29:00.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定<script type="math/tex">n,m</script>，设一个<script type="math/tex">1</script>到<script type="math/tex">n</script>的置换<script type="math/tex">P</script>，定义<script type="math/tex">f(P)</script>是满足<script type="math/tex">P^x=I</script>的最小的<script type="math/tex">x</script>（<script type="math/tex">I</script>是单位置换），求<script type="math/tex">\prod_P f(P)\mod m</script>。</p><p>其中<script type="math/tex">n\le 7500,1e8\le m\le 1e9+7</script>，且<script type="math/tex">m</script>为质数。</p><p><strong>本题来源于USACO 2020 US Open Platinum T2。</strong></p><span id="more"></span><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>注意到<script type="math/tex">f(P)</script>实际上就是<script type="math/tex">P</script>所有循环长度的最小公倍数。</p><p>直接求最小公倍数似乎无从下手，但题目要求的是乘积，所以我们可以枚举质数，然后计算每一个质数对答案的贡献。</p><p>对于一个<script type="math/tex">p</script>，定义<script type="math/tex">ord_p(x)</script>为<script type="math/tex">x</script>质因子分解后<script type="math/tex">p</script>的指数，那么我们要计算的是</p><script type="math/tex; mode=display">\sum_Smax_{a\in S} ord_p(a)</script><p>对于<script type="math/tex">S</script>，我们要满足</p><script type="math/tex; mode=display">\sum_{a\in S}a=n</script><p>根据套路，我们把换成</p><script type="math/tex; mode=display">\sum_{k\ge 1}k*\sum_S[max_{a\in S}ord_p(a)=k]</script><p>这个时候，我们肯定是要对这个进行<script type="math/tex">dp</script>的，我们每次要枚举加入的数。</p><p>我们发现这个<script type="math/tex">max</script>对复杂度非常不友好，要<script type="math/tex">O(n)</script>地进行枚举，而如果改成<script type="math/tex">min</script>的话，我们枚举量就可以缩减为<script type="math/tex">\frac{n}{p^k}</script>，大大减少了复杂度。怎么把<script type="math/tex">max</script>改成<script type="math/tex">min</script>呢？<script type="math/tex">min-max</script>容斥！</p><p>想不到吧，<script type="math/tex">min-max</script>容斥不仅能用在期望上，有时还能优化复杂度！</p><p>那么我们就变为</p><script type="math/tex; mode=display">\sum_{k\ge 1}k*\sum_S\sum_{T\subset S}(-1)^{|T|-1}[min_{a\in T}ord_p(a)=k]\\=\sum_{k\ge 1}k*\sum_T(-1)^{|T|-1}[min_{a\in T}ord_p(a)=k]*coef(T)</script><p>这个<script type="math/tex">coef(T)</script>就是<script type="math/tex">T</script>对答案的贡献系数，我们后面再说。</p><p>我们发现这个<script type="math/tex">k</script>非常地不好弄，那么我们还有一个常用办法，把式子转变成：</p><script type="math/tex; mode=display">\sum_{k\ge 1}\sum_T(-1)^{|T|-1}[ord_p(a)\ge k,\forall a\in T]*coef(T)</script><p>这个时候，一个<script type="math/tex">T</script>满足<script type="math/tex">min(ord_p(a))=k</script>，它对答案依然会产生<script type="math/tex">k</script>的贡献。这是非常常用的方法。这也是我们为什么把<script type="math/tex">max</script>转为<script type="math/tex">min</script>的重要原因！</p><p>我们现在来看<script type="math/tex">coef(T)</script>，实际上，它的含义为剩下的随便变成若干环排列。我们记<script type="math/tex">sum(T)</script>为<script type="math/tex">T</script>中所有元素的和，那么首先我们要从<script type="math/tex">n</script>个中选出<script type="math/tex">sum(T)</script>个，先乘以<script type="math/tex">\binom{n}{sum(T)}</script>，现在来看剩下<script type="math/tex">n-sum(T)</script>个数构成若干环排列的方案数。</p><p>我们设<script type="math/tex">g(m)</script>表示<script type="math/tex">m</script>个数分成若干环排列的方案数，那么我们每次考虑加入一个数，和第一类斯特林数推导类似的思想，我们考虑它放在哪：一种情况，它自立门户，单独成为一个环排列，另外一种情况，它放在前面某个数的一侧。那么递推式就有了：</p><script type="math/tex; mode=display">g(m)=(m-1)*g(m-1)+g(m-1)*1=m*g(m-1)</script><p>根据<script type="math/tex">g(1)=1</script>，我们发现<script type="math/tex">g(m)=m!</script>，这也告诉我们第一类斯特林数第<script type="math/tex">i</script>行数的和为<script type="math/tex">i!</script>。</p><p>那么我们就有</p><script type="math/tex; mode=display">coef(T)=\binom{n}{sum(T)}*(n-sum(T))!</script><p>我们发现这个<script type="math/tex">coef(T)</script>只与<script type="math/tex">sum(T)</script>有关，那么我们就可以枚举<script type="math/tex">k</script>进行<script type="math/tex">dp</script>了。</p><p>下面设<script type="math/tex">s=p^k</script>，我们相当于钦定每个环排列大小都是<script type="math/tex">s</script>的倍数来计算方案。</p><p>我们设<script type="math/tex">f[i]</script>表示<script type="math/tex">sum(T)=is</script>时的容斥系数。现在我们考虑加入一个环排列，首先容斥系数显然取反。然后为了避免算重，根据计数技巧，我们枚举与<script type="math/tex">1</script>在一起的那个环排列，一个大小为<script type="math/tex">m</script>的集合的环排列个数显然是<script type="math/tex">(m-1)!</script>，那么转移方程就出来了。</p><script type="math/tex; mode=display">f[i]=-\sum_{j=1}^i \binom{i*s-1}{j*s-1}*(j*s-1)!*f[i-j]</script><p>考虑时间复杂度，我们相当于是对于所有的质数<script type="math/tex">p</script>对于时间的贡献为</p><script type="math/tex; mode=display">\sum_{p^k\le n}(\lfloor\frac{n}{p^k}\rfloor)^2\le n^2*\sum_k \frac{1}{p^{2k}}=O(\frac{n^2}{p^2})</script><p>那么总复杂度为</p><script type="math/tex; mode=display">n^2*\sum_p\frac{1}{p^2}\le n^2</script><p>所以复杂度为<script type="math/tex">O(n^2)</script>。</p><p>另外注意，我们在<script type="math/tex">dp</script>指数，所以<script type="math/tex">dp</script>值，组合数，阶乘的模数都是<script type="math/tex">\phi(mod)=mod-1</script>，而我们做快速幂的时候模数是<script type="math/tex">mod</script>，不要混淆。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">7505</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, mod, ans;</span><br><span class="line"><span class="keyword">int</span> f[maxN + <span class="number">1</span>], C[maxN + <span class="number">1</span>][maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> fac[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> flag[maxN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ADD</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y &gt;= mod ? x + y - mod : x + y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">SUB</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x - y &lt; <span class="number">0</span> ? x - y + mod : x - y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>) ans = <span class="number">1ll</span> * ans * a % (mod + <span class="number">1</span>);</span><br><span class="line">        a = <span class="number">1ll</span> * a * a % (mod + <span class="number">1</span>);</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = n / k, res = <span class="number">0</span>;</span><br><span class="line">    f[<span class="number">0</span>] = mod - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            f[i] = <span class="built_in">SUB</span>(f[i], <span class="number">1ll</span> * C[i * k - <span class="number">1</span>][j * k - <span class="number">1</span>] * fac[j * k - <span class="number">1</span>] % mod * f[i - j] % mod); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        res = <span class="built_in">ADD</span>(res, <span class="number">1ll</span> * C[n][i * k] * fac[n - i * k] % mod * f[i] % mod);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;mod);</span><br><span class="line">    mod --;</span><br><span class="line"></span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) C[i][j] = <span class="built_in">ADD</span>(C[i - <span class="number">1</span>][j], C[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!flag[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + i; j &lt;= n; j += i) flag[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= n; j *= i)</span><br><span class="line">                ans = <span class="number">1ll</span> * ans * <span class="built_in">mpow</span>(i, <span class="built_in">calc</span>(j)) % (mod + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>首先，对于一些特定的题目，会有<script type="math/tex">min</script>比<script type="math/tex">max</script>更适合解题或<script type="math/tex">max</script>比<script type="math/tex">min</script>更适合解题的情况，这个时候也可以考虑<script type="math/tex">min-max</script>容斥。</p><p>其次，对于一些情况（比如本题），我们可以用<script type="math/tex">=</script>转<script type="math/tex">\ge</script>的容斥，既放宽松了条件，又去掉了一个系数，十分巧妙。</p><p>另外，我们在<script type="math/tex">dp</script>有关集合的时候，为了防止算重，我们会枚举与某个特定的数在一起的那个元素（比如本题枚举与<script type="math/tex">1</script>在一起的环排列），这个技巧也要牢记。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;给定&lt;script type=&quot;math/tex&quot;&gt;n,m&lt;/script&gt;，设一个&lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt;到&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;的置换&lt;script type=&quot;math/tex&quot;&gt;P&lt;/script&gt;，定义&lt;script type=&quot;math/tex&quot;&gt;f(P)&lt;/script&gt;是满足&lt;script type=&quot;math/tex&quot;&gt;P^x=I&lt;/script&gt;的最小的&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;（&lt;script type=&quot;math/tex&quot;&gt;I&lt;/script&gt;是单位置换），求&lt;script type=&quot;math/tex&quot;&gt;\prod_P f(P)\mod m&lt;/script&gt;。&lt;/p&gt;
&lt;p&gt;其中&lt;script type=&quot;math/tex&quot;&gt;n\le 7500,1e8\le m\le 1e9+7&lt;/script&gt;，且&lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt;为质数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本题来源于USACO 2020 US Open Platinum T2。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="LOJ" scheme="http://cmwqf.github.io/categories/LOJ/"/>
    
    
    <category term="dp" scheme="http://cmwqf.github.io/tags/dp/"/>
    
    <category term="组合数学" scheme="http://cmwqf.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="容斥原理" scheme="http://cmwqf.github.io/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    
    <category term="数论" scheme="http://cmwqf.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>AGC011F Train Service Planning</title>
    <link href="http://cmwqf.github.io/2020/04/03/AGC011F-Train-Service-Planning/"/>
    <id>http://cmwqf.github.io/2020/04/03/AGC011F-Train-Service-Planning/</id>
    <published>2020-04-03T02:19:49.000Z</published>
    <updated>2024-03-06T06:29:00.634Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有一个<script type="math/tex">n+1</script>个车站的铁路，分别为<script type="math/tex">0,1,...,n</script>号，显然铁路被分为<script type="math/tex">n</script>段，设<script type="math/tex">a_i</script>为火车从第<script type="math/tex">i-1</script>个车站到第<script type="math/tex">i</script>个车站所需时间（也是第<script type="math/tex">i</script>个车站到第<script type="math/tex">i-1</script>个车站的所需时间），每段铁路还有一个参数<script type="math/tex">b_i=1/2</script>表示这段路是单向道还是双向道，如果是单向道，同一时间不能被两辆不同方向的火车经过，如果是双向道就没有限制。</p><p>现在有两种车，一种从<script type="math/tex">0</script>开到<script type="math/tex">n</script>，另外一种从<script type="math/tex">n</script>开到<script type="math/tex">0</script>，且每隔<script type="math/tex">k</script>单位时间就会发一辆车（两种都发），我们的任务是调整两种车在每个站台的停留时间，使得不存在某个时刻两种车在同一个单向道上相遇，求满足这个条件的情况下，<script type="math/tex">0->n</script>的时间与<script type="math/tex">n->0</script>的时间之和的最小值。若无法完成，则输出<script type="math/tex">-1</script>。</p><p>其中<script type="math/tex">n\le 1e5,k,a_i\le 1e9,b_i\le 2</script>。</p><span id="more"></span><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>非常巧妙的一道题。</p><p>首先，我们注意到因为每隔<script type="math/tex">k</script>发一次车，所以整个问题我们可以看成在<script type="math/tex">mod\quad k</script>意义下进行的。</p><p>然后，我们发现整个问题可以转化为区间问题，即有一些长度固定的区间，然后我们的限制是在模意义下，一些区间不能相交。</p><p>具体地，我们设<script type="math/tex">p_i</script>为第一种车在第<script type="math/tex">i</script>个车站的停留时间（<script type="math/tex">0\le i \le n</script>），设<script type="math/tex">q_i</script>为第二种车在第<script type="math/tex">i</script>个车站的停留时间，然后设<script type="math/tex">P_i</script>表示<script type="math/tex">p_0,...p_i</script>的和，<script type="math/tex">Q_i</script>同理，<script type="math/tex">A_i</script>即<script type="math/tex">a</script>的前缀和。</p><p>我们发现第一种车的区间是<script type="math/tex">p</script>和<script type="math/tex">a</script>的前缀和的形式，第二种车的每个区间却是<script type="math/tex">q</script>和<script type="math/tex">a</script>的后缀和的形式，非常不好处理。</p><p>但是我们发现一个好处是整个问题是在取模的意义下进行的。</p><p>在时间轴上取模，就相当于拿一个长度为<script type="math/tex">k</script>的窗口在时间轴上滑动，不管窗口在什么位置，截到的时间及其上面发生的事件都是等价的。</p><p>我们设窗口截到的最右边是整个事件结束，那么<script type="math/tex">q_0</script>的意义相当于第二种车到达<script type="math/tex">0</script>号站后再等待<script type="math/tex">q_0</script>时间才得以结束。</p><p>为了与第一种车的区间形式相似，我们考虑对第二种车进行时光倒流，把第二种车也看成从<script type="math/tex">0->n</script>，然后看成它在<script type="math/tex">0</script>号车站等待了<script type="math/tex">-q_0</script>单位时间，然后到达<script type="math/tex">1</script>号车站的时间为<script type="math/tex">-q_0-a_1</script>，以此类推。</p><p>通过这样的操作，我们将第一种车和第二种车的区间形式都统一为前缀和的形式。</p><p>更具体地，第一种车在第<script type="math/tex">i-1</script>到第<script type="math/tex">i</script>个车站的时间区间和第二种车从第<script type="math/tex">i</script>个车站到第<script type="math/tex">i - 1</script>个的时间区间分别为为</p><script type="math/tex; mode=display">(P_{i-1}+A_{i-1},P_{i-1}+A_i)\\(-Q_{i-1}-A_i,-Q_{i-1}-A_{i-1})</script><p>这样看起来形式非常统一，我们后面也会很好处理。</p><p>现在，我们就是要求在取模意义下，这两个区间不相交。因为区间相交比较好算（好理解），我们先转化为区间相交，再取补集。</p><p>区间相交，即其中一个区间的端点在另一个区间内。</p><p>我们列出以下不等式</p><script type="math/tex; mode=display">-Q_{i-1}-A_i<P_{i-1}+A_{i-1}<-Q_{i-1}-A_{i-1}\\-Q_{i-1}-A_i<P_{i-1}+A_i<-Q_{i-1}-A_{i-1}</script><p>两个不等式是或的关系，即只要一个成立即可。</p><p>这两个不等式肯定是在模的意义下成立，但是在模的意义下理解不等式又比较困难，我们这么来思考模意义下不等式的含义。</p><p>实际上，在模意义下，<script type="math/tex">a<b<c</script>的意义为在<script type="math/tex">(a,c)</script>中存在一个数，与<script type="math/tex">b</script>同余。这样理解起来就要好多了！</p><p>那么显然<script type="math/tex">a<b<c</script>等价于<script type="math/tex">a+d<b+d<c+d</script>（考虑上面所说的意义即可），即这个不等式可以按照解普通不等式的方法来解。</p><p>那么解得</p><script type="math/tex; mode=display">-2A_i<P_{i-1}+Q_{i-1}<-2A_{i-1}</script><p>那么其补集就是在模意义下，</p><script type="math/tex; mode=display">P_{i-1}+Q_{i-1}\in [-2A_{i-1},-2A_i]</script><p>这样一来，因为<script type="math/tex">A</script>是已知的，所以我们就能确定<script type="math/tex">P_i+Q_i</script>的范围。</p><p>因为我们最终要求最小化的是</p><script type="math/tex; mode=display">P_{n-1}+Q_{n-1}-p_0-q_0</script><p>所以问题就转化成十分可做的形式了！</p><p>这样，问题转化为：</p><p>有一个数列<script type="math/tex">t</script>，满足<script type="math/tex">t[i]\ge t[i-1]</script>，然后对于某些特定的<script type="math/tex">i</script>（<script type="math/tex">b_i=1</script>），要满足<script type="math/tex">t[i]\quad mod\quad k\in [L[i],R[i]]</script>。求<script type="math/tex">t_n-t_1</script>的最小值。</p><p>我们考虑用<script type="math/tex">dp</script>来解决，设<script type="math/tex">f[i][j]</script>表示处理了前<script type="math/tex">i</script>个，当前<script type="math/tex">t[i]\quad mod\quad k=j</script>时最小的<script type="math/tex">t[i]</script>。（对于<script type="math/tex">-t_1</script>的限制可以直接把<script type="math/tex">f[1]</script>中满足条件的变成<script type="math/tex">0</script>，别的变成<script type="math/tex">inf</script>），那么转移的时候，首先如果本来就在<script type="math/tex">[L[i],R[i]]</script>中的自然不会改变，其他的因为只能往一个方向走，必然是走到<script type="math/tex">L[i]</script>处，那么用不在区间中的步数最小值来更新<script type="math/tex">L[i]</script>的值，并把不在区间中的全部赋值为<script type="math/tex">inf</script>即可。</p><p>这样复杂度显然飞了，我们发现几个显然的性质：</p><p>因为每次必然会走到<script type="math/tex">L[i]</script>处或者不动，所以<script type="math/tex">j</script>的取值只有<script type="math/tex">2n</script>种。</p><p>然后我们发现这个东西显然可以用一棵线段树方便地维护，所以直接线段树优化一下即可，记得线段树种记得是当前最小的步数减去当前位置的值，用来更新后面的答案。</p><p>最后输出线段树中最小值加上<script type="math/tex">2A[n]</script>即可。</p><p>时间复杂度<script type="math/tex">O(nlog_2n)</script>，记得特判如果<script type="math/tex">b[i]==1</script>且<script type="math/tex">2a[i]>k</script>，输出<script type="math/tex">-1</script>，这个根据前面区间的分析很容易得到。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> LL inf = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LL mn;</span><br><span class="line">    <span class="keyword">bool</span> lazy;</span><br><span class="line">&#125;tree[maxN * <span class="number">4</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K, cnt;</span><br><span class="line"><span class="keyword">int</span> a[maxN + <span class="number">1</span>], b[maxN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> L[maxN + <span class="number">1</span>], R[maxN + <span class="number">1</span>], tmp[maxN + <span class="number">1</span>];</span><br><span class="line">LL sum[maxN + <span class="number">1</span>], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>( !<span class="built_in">isdigit</span>( ch ) ) &#123; <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">isdigit</span>( ch ) ) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> num * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[node].mn = <span class="built_in">min</span>(tree[node &lt;&lt; <span class="number">1</span>].mn, tree[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[node &lt;&lt; <span class="number">1</span>].mn = tree[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mn = inf;</span><br><span class="line">    tree[node &lt;&lt; <span class="number">1</span>].lazy = tree[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lazy = <span class="literal">true</span>;</span><br><span class="line">    tree[node].lazy = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[node].lazy = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123; tree[node].mn = -tmp[l]; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(node &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; y) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= l &amp;&amp; r &lt;= y)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[node].mn = inf;</span><br><span class="line">        tree[node].lazy = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree[node].lazy) <span class="built_in">pushdown</span>(node);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(node &lt;&lt; <span class="number">1</span>, l, mid, x, y);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid) <span class="built_in">modify</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y);</span><br><span class="line">    <span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, LL num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123; tree[node].mn = <span class="built_in">min</span>(tree[node].mn, num); <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree[node].lazy) <span class="built_in">pushdown</span>(node);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">change</span>(node &lt;&lt; <span class="number">1</span>, l, mid, x, num);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">change</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x, num);</span><br><span class="line">    <span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; y) <span class="keyword">return</span> inf;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= l &amp;&amp; r &lt;= y) <span class="keyword">return</span> tree[node].mn;</span><br><span class="line">    <span class="keyword">if</span>(tree[node].lazy) <span class="built_in">pushdown</span>(node);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; LL ans = inf;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) ans = <span class="built_in">min</span>(ans, <span class="built_in">query</span>(node &lt;&lt; <span class="number">1</span>, l, mid, x, y));</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid) ans = <span class="built_in">min</span>(ans, <span class="built_in">query</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123; ans = <span class="built_in">min</span>(ans, tree[node].mn + tmp[l]); <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree[node].lazy) <span class="built_in">pushdown</span>(node);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">get</span>(node &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">get</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), K = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = <span class="built_in">read</span>(), b[i] = <span class="built_in">read</span>();</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">        <span class="keyword">if</span>(b[i] == <span class="number">1</span>) L[i] = (K - <span class="number">2ll</span> * sum[i - <span class="number">1</span>] % K) % K, R[i] = (K - <span class="number">2ll</span> * sum[i] % K) % K;</span><br><span class="line">        <span class="keyword">else</span> L[i] = <span class="number">0</span>, R[i] = K - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(b[i] == <span class="number">1</span> &amp;&amp; <span class="number">2ll</span> * a[i] &gt; K)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp[++ cnt] = L[i]; tmp[++ cnt] = R[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(tmp + <span class="number">1</span>, tmp + cnt + <span class="number">1</span>);</span><br><span class="line">    cnt = <span class="built_in">unique</span>(tmp + <span class="number">1</span>, tmp + cnt + <span class="number">1</span>) - tmp - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, cnt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">lower_bound</span>(tmp + <span class="number">1</span>, tmp + cnt + <span class="number">1</span>, L[i]) - tmp, r = <span class="built_in">lower_bound</span>(tmp + <span class="number">1</span>, tmp + cnt + <span class="number">1</span>, R[i]) - tmp;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            LL t = <span class="built_in">min</span>(<span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, cnt, <span class="number">1</span>, l - <span class="number">1</span>) + tmp[l], <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, cnt, r + <span class="number">1</span>, cnt) + K + tmp[l]);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, cnt, <span class="number">1</span>, l - <span class="number">1</span>); <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, cnt, r + <span class="number">1</span>, cnt);</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>, <span class="number">1</span>, cnt, l, t - tmp[l]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            LL t = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, cnt, r + <span class="number">1</span>, l - <span class="number">1</span>) + tmp[l];</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, cnt, r + <span class="number">1</span>, l - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>, <span class="number">1</span>, cnt, l, t - tmp[l]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans = inf;</span><br><span class="line">    <span class="built_in">get</span>(<span class="number">1</span>, <span class="number">1</span>, cnt);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans + <span class="number">2ll</span> * sum[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><script type="math/tex">Atcoder</script>这种题，一般都要问题转化。</p><p>遇到一些列式子的情况，我们要想办法把式子转化为类似的形式，有利于后面化简（例如本题考虑时光倒流），这是本题最巧妙的思想！</p><p>然后对于取模意义下的区间一般都转化成判断相交并转化为不等式问题，一定要多加理解取模意义下的不等式的含义。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;有一个&lt;script type=&quot;math/tex&quot;&gt;n+1&lt;/script&gt;个车站的铁路，分别为&lt;script type=&quot;math/tex&quot;&gt;0,1,...,n&lt;/script&gt;号，显然铁路被分为&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;段，设&lt;script type=&quot;math/tex&quot;&gt;a_i&lt;/script&gt;为火车从第&lt;script type=&quot;math/tex&quot;&gt;i-1&lt;/script&gt;个车站到第&lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;个车站所需时间（也是第&lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;个车站到第&lt;script type=&quot;math/tex&quot;&gt;i-1&lt;/script&gt;个车站的所需时间），每段铁路还有一个参数&lt;script type=&quot;math/tex&quot;&gt;b_i=1/2&lt;/script&gt;表示这段路是单向道还是双向道，如果是单向道，同一时间不能被两辆不同方向的火车经过，如果是双向道就没有限制。&lt;/p&gt;
&lt;p&gt;现在有两种车，一种从&lt;script type=&quot;math/tex&quot;&gt;0&lt;/script&gt;开到&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;，另外一种从&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;开到&lt;script type=&quot;math/tex&quot;&gt;0&lt;/script&gt;，且每隔&lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;单位时间就会发一辆车（两种都发），我们的任务是调整两种车在每个站台的停留时间，使得不存在某个时刻两种车在同一个单向道上相遇，求满足这个条件的情况下，&lt;script type=&quot;math/tex&quot;&gt;0-&gt;n&lt;/script&gt;的时间与&lt;script type=&quot;math/tex&quot;&gt;n-&gt;0&lt;/script&gt;的时间之和的最小值。若无法完成，则输出&lt;script type=&quot;math/tex&quot;&gt;-1&lt;/script&gt;。&lt;/p&gt;
&lt;p&gt;其中&lt;script type=&quot;math/tex&quot;&gt;n\le 1e5,k,a_i\le 1e9,b_i\le 2&lt;/script&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Atcoder" scheme="http://cmwqf.github.io/categories/Atcoder/"/>
    
    
    <category term="dp" scheme="http://cmwqf.github.io/tags/dp/"/>
    
    <category term="贪心" scheme="http://cmwqf.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
</feed>
