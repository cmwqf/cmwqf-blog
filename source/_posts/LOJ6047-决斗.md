---
title: '[LOJ6047]决斗'
date: 2020-03-01 19:13:05
tags: [贪心]
categories: [LOJ]
---

# Description

有$$n$$个位置排成一个环，每个位置有一个值$$a_i$$，还有$$n$$人，每一个人有一个位置标号$$t_i$$（不同的人$$t_i$$可能相同），还有一个值$$b_i$$。

现在人们按照一定顺序进入场地，当编号为$$k$$的人进入时，会找到$$t_k$$的位置，如果这个位置已经有人，那么他会从这个位置顺时针找到第一个空位并坐下。

设$$ans$$为最后位置上坐着的人的值大于这个位置的值的位置个数。

问通过不同的顺序安排方式，最大的$$ans$$时多少？

<!--more-->

# Solution

首先，我们考虑最终的最优方案是什么样子。

我们设位置标号为$$i$$的人组成的集合为$$s_i$$。

那么必然有一个位置，它的上面坐的人属于$$s_i$$，且没有属于它之前的位置的人坐到这个位置之后。

显然我们选择的第一个位置就符合条件。

那么，我们有一个贪心策略，由于后面的数不会影响到当前决策，我们就用$$set$$维护出当前可用的人的值，然后每到一个位置，把属于当前位置的人的值先加入$$set$$，然后选择大于等于当前位置的值的最小的数，作为坐在这里的人，然后把它删去，如果没有找到，那么就删去$$set$$中最小的一个。

这个贪心的正确性是显然的。

但是，我们并不知道我们选择的第一个位置是什么，所以要枚举，再加上贪心，时间复杂度$$O(n^2log_2n)$$，显然无法通过。

那么，我们能不能不用枚举第一个位置是什么，而直接找呢？

实际上，存在一个位置，不管按照什么顺序排列，都不会有属于它之前的位置的人坐到这个位置之后。这个位置要满足什么条件呢？

我们记$$x_i=|s_i|-1$$，那么，这个位置要满足整个环以这个位置为开头，所有的$$x_i$$的前缀和都$$>=0$$。

这是啥？

我们考虑这个$$x_i$$的前缀和是什么含义？记其为$$sum_i$$，它表示处理完前$$i$$个位置之后还剩下来的可供填的人数。如果在任何时候都有$$sum_i>=0$$，说明所有位置不会出现人不够填的情况，就不会有后面的位置的人填到前面来。

是不是对于所有的顺序，这个位置记为$$k$$都不会被跨越呢？

是的，我们用反证法，如果存在某个位置开头填后，使得$$k$$被跨越了，那么说明$$sum_{k-1}>0$$，而所有的数的$$x_i$$之和显然等于$$0$$，那么$$k$$到末尾的位置的$$x$$之和$$<0$$，与$$k$$这个位置的定义矛盾。

所以，对于所有的顺序，这个$$k$$都不会被跨越，也就是说，我们只要找到这个$$k$$，就可以放心地把它当作开头来进行贪心。

但是，我们一定能找到这样一个$$k$$吗，怎样找这样的$$k$$呢？

其实，这两个问题可以放在一起解决。

我们考虑随便以一个位置开头，那么$$sum_i$$的值一定构成了一段折线，中间有可能会突破到$$x$$轴以下。那么，我们找到这段折线值最小的点（若有多个，任选一个），最小值记为$$mn$$，这个点为$$k$$。

我们让这个点$$k$$之后的那个点$$k+1$$成为第一个，这个点把当成原点（也是最后一个点），那么，我们相当于把$$k$$之后的函数图像从向上平移了$$|mn|$$个单位，这个时候这一段不存在$$x$$轴以下的点，这个时候我们再把前面那一段给接到这个函数末尾，那么这个函数此时不会有任何一段再$$x$$轴以下（否则就和$$mn$$是之前那段函数的最小值矛盾）。

那么，我们不仅证明了这样的点一定存在，还知道了找到$$k$$的方法。

我们从任何一个点开始（比如从$$1$$），求$$x_i$$的前缀和$$sum_i$$，取$$sum$$最小的点$$k$$，然后以$$k+1$$作为开始点进行贪心即可。

# Code

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxN = 5e5 + 10;

int n;
int a[maxN + 1], b[maxN + 1];
int sum[maxN + 1];

set<int> s;

vector<int> num[maxN + 1];

inline int read()
{
	int num = 0, f = 1;
	char ch = getchar();
	while( !isdigit( ch ) ) { if(ch == '-') f = -1; ch = getchar(); }
	while( isdigit( ch ) ) num = (num << 3) + (num << 1) + (ch ^ 48), ch = getchar();
	return num * f;
}

int main()
{
	n = read();
	for(int i = 1; i <= n; i++) num[ read() ].push_back(i);
	for(int i = 1; i <= n; i++) a[i] = read();
	for(int i = 1; i <= n; i++) b[i] = read();

	int now = 0;
	for(int i = 1; i <= n; i++)
	{
		sum[i] = sum[i - 1] + num[i].size() - 1;
		if(sum[i] < sum[now]) now = i;
	}

	int ans = 0;
	now ++;
	for(int i = 1; i <= n; i++, now++)
	{
		if(now > n) now = 1;
		for(int j = 0; j < num[now].size(); j++)
			s.insert(b[ num[now][j] ]);
		set<int>::iterator it = s.lower_bound(a[now]);
		if(it != s.end()) ans ++, s.erase(it ++);
		else it = s.begin(), s.erase(it ++);
	}

	printf("%d", ans);
	return 0;
}
```

# 总结

我们经常遇到一个环$$x_i$$，其总和为$$0$$，然后我们要以某个位置开头，使得每个前缀和都$$>=0$$，那么我们可以使用以上的分析方法，必然存在这样的一个点满足条件，而且通过函数图像解题，调整，都是贪心的常用技巧，一定要熟练掌握。