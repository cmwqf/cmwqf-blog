---
title: AGC030F Permutation and Minimum
date: 2021-03-01 15:16:05
tags: [dp]
categories: [Atcoder]
---

# Description

对于$$2n$$个数的排列$$p$$，定义其生成数列$$g_i=\min(p_{2i-1},p_{2i})\quad\forall 1\le i\le n$$。现在有一个$$2n$$个数的排列，其中有一些位置还不确定，问在所有合法的填法中，能生成的不同的$$g$$的个数，答案对$$1e9+7$$取模。

两个$$g$$不同当且仅当存在$$1\le i\le n$$，使得$$g1_i\neq g2_i$$。

其中$$1\le n\le 300$$。

<!--more-->

# Solution

## Tip1

这类问题可以形式化地表述为：我们有一个$$f$$，根据一些操作变成$$g$$，我们要数$$g$$的个数。

这种问题的麻烦处在于，如果只数$$f$$，会把$$g$$算重，如果只数$$g$$，有些$$g$$是不合法的，会算多。

那么，我们就是要在$$g$$和$$f$$中建立一个桥梁，即一个构造方法（很多时候是贪心），使得每个合法的$$g_0$$通过构造能得到唯一一个合法的$$f_0$$，且这个$$f_0$$通过原来的操作变成的序列为$$g_0$$。

我们考虑对$$g$$序列进行$$dp$$，同时$$dp$$状态维护当前$$g$$经过构造形成的$$f$$的必要参数。最后，只要$$f$$的参数表明构造出了合法的$$f$$，那么$$g$$也是合法的。也就是说，最后把所有表示$$f$$合法的$$dp$$值加起来即可。

------

现在考虑本题。

显然，本题中的$$f$$就是$$n$$个二元组组成的序列，$$g$$就是题目所述的生成序列。

可以发现，本题的$$n$$个二元组可以分为$$3$$种类型，分别为$$(0,-1),(-1,-1),(0,0)$$，其中$$0$$表示给定的数，$$-1$$表示可以随便填的数。可以发现，$$(0,0)$$对答案没用，因此可以忽略它。

那么，我们把所有形如$$(0,-1)$$的分为一类，设为$$A$$，所有$$(-1,-1)$$的分为一类，设为$$B$$。

我们考虑通过一个合法的$$g$$构造出唯一的相应的$$f$$。

注意到因为我们统计的是$$g$$的个数，因此每个二元组内部交换顺序，$$g$$不变，那么我们不妨假设$$f$$中所有二元组$$(a_i,b_i)$$都满足$$a_i<b_i$$。

考虑从小到大枚举数。

如果这个数是已经给定的，那么直接放到它对应的二元组去，如果那个二元组还没有数，就填在左边，否则填在右边（为了满足$$a_i<b_i$$）。

如果这个数不是给定的，那么有两种情况：第一种，它出现在$$g$$中，即它是某个二元组的最小值，那么我们把它填在其在$$g$$出现位置的那个二元组的左边。否则，如果它不出现在$$g$$中，那么说明它是某个二元组的最小值，那么考虑当前所有**已经填了左边数且右边数不是给定的二元组**，实际上它可以放在这些二元组中的任何一个，但是由于我们要求构造出唯一的一个$$f$$，不难想到将它填在其中左边数字最小的那个二元组中。

如此构造出相应的$$f$$。

可以发现，一个合法的$$g$$唯一对应一个操作序列，而一个操作序列也唯一对应一个合法的$$g$$（因为构造出来的$$f$$唯一对应一个$$g$$）。

那么我们现在考虑如何$$dp$$。

考虑如果我们想要完成这个操作序列需要知道什么？

首先如果这个数已经给定，那么它填的位置已经确定，所以不需要知道信息。

如果这个数没有被给定，那么它需要知道什么信息呢？如果它出现在$$g$$中，那么我们需要知道有多少个二元组一个数都没填，然后选一个填下去。否则，如果它不出现在$$g$$中，那么我们需要知道有多少个二元组已经填了左边数且右边数不是给定的。因此，我们一共需要这两个状态。

根据这个进行$$dp$$，问题似乎解决了？？

但是，我们很快发现这个做法有些问题。在这个算法中，可能出现我们填已经**给定的数**的时候，如果我们决定填左边，而实际上左边已经被填过了。又或者如果我们准备填右边，而实际上这个二元组左边还没有被填。这个时候，$$g$$已经不合法了，但还是被我们统计到了答案里。

如果还是考虑**给定的数**能否填，似乎只有记录所有$$A$$中二元组的状态？这是无法接受的。

既然无法考虑**给定的数**能否填，不如在填**没给定的数**的时候决定它应该和哪个进行配对，然后再考虑**给定的数**的时候在一个固定的集合里选择。

具体地，我们在状态中记录一维表示当前有多少个**没给定的数**决定以后和**给定的数**配对。那么每次填**给定的数**的时候，如果它想放在后面（不出现在$$g$$中）的话，就在这些数中选一个进行配对即可。

## Tip2

这是一个很常用的思想，即当我们按照一定顺序进行$$dp$$，选出来一些元素要放在某些位置，但是如果在选出来这个元素的同时决定它放在哪个位置会影响后面的选择，那么不如先把它放入一个候选集合中，等到需要它的时候再拿出来即可。

------

那么，我们设$$f[i][j][k]$$表示考虑了所有$$\le i$$的数，有$$j$$个数决定和**给定的数**配对，有$$k$$个数决定和**没给定的数**配对的方案数。

但是，这样还有一个问题，如果我们当前考虑的数是**没给定的**，而我们想填在$$B$$组的左边，那么我们还要记录当前有多少个还没被填的$$B$$组，来进行选择。

这样，时间复杂度又不对了。注意到实际上$$B$$组中的二元组是可以交换的，那么我们不妨假设所有$$B$$组二元组满足$$a_1<a_2<\dots<a_k$$（其中$$k$$是$$B$$组的大小），最后乘以$$k!$$即可。

因此，当我们把**没给定的数**填到$$B$$组的左边时无需考虑具体填到哪个二元组，因为它会自动填在当前所有已经填了左边数的$$B$$组二元组的后面那个二元组中。

接下来，转移过程就很简单了。设当前考虑$$f[i][j][k]$$能往哪些地方转移。

如果它是**给定的**：

第一种情况，想让它在$$g$$中出现，那么它后面一定配对一个**没给定的数**，那么$$f[i+1][j][k+1]+=f[i][j][k]$$。

第二种情况，它不在$$g$$中出现，那么在候选集合中选一个，$$f[i+1][j-1][k]+=f[i][j][k]\times j$$。

如果它是**没给定的**：

第一种情况，想让它在$$g$$中出现，那么它后面既可以配对**给定的**，也可以配对**没给定的**，因此$$f[i+1][j+1][k]+=f[i][j][k],f[i+1][j][k+1]+=f[i][j][k]$$。

第二种情况，不在$$g$$中出现，那么和配对集合中数字最小的那个配对，即$$f[i+1][j][k-1]+=f[i][j][k]$$。

最后的答案是$$f[2n][0][0]\times k!$$。

为什么这两个状态都是$$0$$就一定符合条件呢？这个状态中丝毫没有用到$$A$$组和$$B$$组的集合大小，会不会最后构造出来的$$f$$两个集合大小和原来不相等呢？

不会，因为在去除了两边都给定的二元组的情况下，只需要知道有多少个数字给定，多少个数字没给定，就能推出$$A$$和$$B$$的大小。而这两个状态都是$$0$$，说明这$$2n$$个数已经合法地填满了所有的二元组，自然满足条件。

时间复杂度$$O(n^3)$$。

# Code

```c++
#include <bits/stdc++.h>
using namespace std;

#define pii pair<int, int>

const int maxN = 305, mod = 1e9 + 7;

int n, s;
int flag[maxN * 2 + 1];
int f[2][maxN + 1][maxN + 1];

inline void update(int &x, int y) { x = x + y >= mod ? x + y - mod : x + y; }

int main()
{
	scanf("%d", &n);
	for(int i = 1; i <= n; i++)
	{
		int x, y;
		scanf("%d %d", &x, &y);
		if(x > 0 && y > 0) { flag[x] = flag[y] = 2; continue; }
		if(x > 0) flag[x] = 1;
		if(y > 0) flag[y] = 1;
		if(x < 0 && y < 0) s ++;
	}

	int now = 0;
	f[now][0][0] = 1;
	for(int i = 1; i <= 2 * n; i++)
	{
		now ^= 1;
		memset(f[now], 0, sizeof(f[now]));
		if(flag[i] == 2)
		{
			for(int j = 0; j <= n; j++)
				for(int k = 0; k <= n; k++)
					f[now][j][k] = f[now ^ 1][j][k];
			continue;
		}
		for(int j = 0; j <= n; j++)
			for(int k = 0; k <= n; k++)
			{
				if(!f[now ^ 1][j][k]) continue;
				int res = f[now ^ 1][j][k];
				if(!flag[i])
				{
					update(f[now][j + 1][k], res);
					update(f[now][j][k + 1], res);
					if(j) update(f[now][j - 1][k], res);
				}
				else
				{
					update(f[now][j + 1][k], res);
					if(k) update(f[now][j][k - 1], 1ll * res * k % mod);
				}
			}
	}

	int ans = f[now][0][0];
	for(int i = 1; i <= s; i++) ans = 1ll * ans * i % mod;

	printf("%d\n", ans);
	return 0;
}
```

# 总结

以后我们遇到这类计数”由某个操作生成的序列“的问题，首先考虑判定问题：一个序列能否被生成？

如果这个问题可以在这个序列上从头到尾遍历的同时用贪心解决，且贪心过程所用到的信息（称为贪心参数）是$$O(1)$$的，那么我们就可以从头到尾以这些信息作为状态进行$$dp$$。

我们的思想实际上是对$$g$$进行$$dp$$，但是有的$$g$$是不合法的，因此我们在状态中加入可以判定是否合法的贪心参数，最后对所有合法的答案累加。