---
title: 多项式除法详解
date: 2019-02-19 09:52:08
tags: [多项式]
categories: [学习笔记]
---

# 多项式除法能干什么？

我们有一个多项式$$A(x)$$，还有一个多项式$$B(x)$$，我们定义$$deg(A)$$为A的最高项次数，现在，我们要把多项式$$A$$化成：
$$
A(x)=B(x)*D(x)+R(x)
$$
的形式，其中，$$deg(A)>deg(B),deg(R)<deg(B)$$，而多项式除法，就是来求出这个$$D,R$$的。

<!--more-->

# 原理

我们设
$$
A^R(x)=x^n*A(\frac{1}{x}),即将A(x)系数反转过来
$$
我们设A的次数为n，B的次数为m，则D的次数不超过n-m

然后，我们将之前那个式子转化一下:
$$
A(\frac{1}{x})=B(\frac{1}{x})*D(\frac{1}{x})+R(\frac{1}{x})\\
x^n*A(\frac{1}{x})=x^m*B(\frac{1}{x})*x^{n-m}D(\frac{1}{x})+x^{n-m+1}*x^{m-1}*R(\frac{1}{x})\\
A^R(x)=B^R(x)*D^R(x)+x^{n-m+1}*R^R(x)
$$
由于$$D(x)$$的次数不会超过$$n-m$$，而$$x^{n-m+1}*R^R(x)$$的所有项次数都高于$$n-m$$,因此，我们把式子在模$$x^{n-m+1}$$的意义下运算就可以消除$$R(x)$$的干扰，直接上多项式求逆即可。

# Code

还是有些要注意的，比如说传入函数的时候要传入这个多项式的大小+1，有助于计算。

```c++
#include<cstdio>
#include<iostream>
#include<algorithm> 
#define int long long
using namespace std;
const int maxN=5e5 + 100,g=3,gi=332748118,mod=998244353;
int r[maxN+1],A[maxN+1],B[maxN+1],D[maxN+1];
int tmp[maxN+1];
int AR[maxN+1],BR[maxN+1];
int n,m;
inline int read()
{
	int num=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)) {if(ch=='-') f=-1; ch=getchar();}
	while(isdigit(ch)) num=(num<<3)+(num<<1)+(ch^48),ch=getchar();
	return num*f;
}
inline int pow(int a,int x)
{
	int ans=1;
	while(x)
	{
		if(x&1) ans=ans*a%mod;
		a=a*a%mod;
		x>>=1;
	}
	return ans;
}
inline void NTT(int *a,int type,int lim)
{
	for(int i=0;i<lim;i++)
	   if(i<r[i]) swap(a[i],a[r[i]]);
	for(int mid=1;mid<lim;mid<<=1)
	{
		int wn=pow(type==1 ? g : gi,(mod-1)/(mid<<1));
		for(int i=0;i<lim;i+=(mid<<1))
		{
			int w=1;
			for(int j=0;j<mid;j++,w=w*wn%mod)
			{
				int x=a[i+j],y=w*a[i+mid+j]%mod;
				a[i+j]=(x+y)%mod,a[i+mid+j]=(x-y+mod)%mod;
			}
		}
	}
}
inline void calc(int *a,int *b,int lim)
{
	NTT(a,1,lim); NTT(b,1,lim);
	for(int i=0;i<lim;i++) b[i]=(2-a[i]*b[i]%mod+mod)%mod*b[i]%mod;
	NTT(b,-1,lim);
	int inv=pow(lim,mod-2);
	for(int i=0;i<lim;i++) b[i]=b[i]*inv%mod;
}
inline void solve(int deg,int *a,int *b)
{
	if(deg==1) {b[0]=pow(a[0],mod-2); return;}
	solve((deg+1)>>1,a,b);
	int lim=1,cnt=0;
	while(lim<(deg<<1)) lim<<=1,cnt++;
	for(int i=0;i<lim;i++) r[i]=(r[i>>1]>>1) | ((i&1) << cnt-1);
	copy(a,a+deg,tmp);
	fill(tmp+deg,tmp+lim,0);
	calc(tmp,b,lim);
	fill(b+deg,b+lim,0);
}
inline void mul(int *a,int *b,int n,int m)
{
	int lim=1,cnt=0;
	while(lim<=(n+m)) lim<<=1,cnt++;
	for(int i=0;i<lim;i++) r[i]=(r[i>>1]>>1) | ((i&1) << cnt-1);
	NTT(a,1,lim); NTT(b,1,lim);
	for(int i=0;i<lim;i++) a[i]=a[i]*b[i]%mod;
	NTT(a,-1,lim);
	int inv=pow(lim,mod-2);
	for(int i=0;i<lim;i++) a[i]=a[i]*inv%mod;
}
#undef int
int main()
#define int long long
{
	n=read(),m=read();
	for(int i=0;i<=n;i++) A[i]=AR[n-i]=read();
	for(int i=0;i<=m;i++) B[i]=BR[m-i]=read();
	solve(n-m+1,BR,D);//求逆 
	
	mul(D,AR,n+1,n-m+1);
	reverse(D,D+n-m+1); fill(D+n-m+1,D+2*n-m+1,0);
	for(int i=0;i<=n-m;i++) printf("%lld ",D[i]);
	printf("\n");//求D 
	
	mul(D,B,n-m+1,m+1);
	for(int i=0;i<m;i++) printf("%lld ",((A[i]-D[i])%mod+mod)%mod);//求R
	return 0;
}
```

