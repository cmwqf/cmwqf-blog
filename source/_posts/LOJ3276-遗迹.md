---
title: '[LOJ3276]遗迹'
date: 2020-03-25 13:43:01
tags: [dp, 组合数学]
categories: [LOJ]
---

# Description

有$$2n$$个数，每个数在$$[1,n]$$之间，且$$[1,n]$$中每个数出现恰好两次。

进行$$n$$次操作，每次操作，对于每个$$[1,n]$$的数，如果数列中存在这个数，找出这个数出现在最右边的位置$$x_0$$，然后将除了$$x_0$$以外所有出现这个数的位置上的数减一。

那么，最后会剩下$$n$$个非零的数。现在给出最后这$$n$$个数的位置（只给位置，不知道数），问有多少种初始序列，使得经过$$n$$次操作后非$$0$$的数的位置是给定的这$$n$$个位置。

其中$$n\le 600$$

**本题来源于JOISC2020 D2T3**。

<!--more-->

# Solution

非常巧妙的一道题。

首先考虑如果给你一个长度$$2n$$的序列，怎样判断最后留下来的是否是给定的$$n$$个位置。

我们可以通过以下代码进行检查

```c++
for(int i = 2 * n; i >= 1; i--)
{
    bool flag = false;
    for(int j = a[i]; j >= 1; j--)
        if(!vis[j])
        {
            vis[j] = flag = true;
            break;
        }
}
```

如果$$flag$$为$$true$$，那么这个位置就会被保留。

这个东西的正确性比较明显，就是每次检查这个位置上的数到一的所有数，如果它右边已经有这个数被选择，那么它一定会减小，否则，说明它右边都没有出现这个数，它最后就是这个数。

我们考虑这段代码的另外一个意义：

有$$2n$$个人，还有$$n$$个座位，每个人依次来选座位，每个人有一个权值$$a_i$$，那么它会从第$$a_i$$个位置开始，如果这个位置为空，那么它就选择这个位置，否则就一直往前走，直到遇到一个空位，并选择它。如果一直找不到，这个人就出局。

那么，我们就来统计每个人初始选择序列$$a_i$$满足最后留下来的人为给定的$$n$$个人的序列个数。

**注意，以下的位置指的是座位位置，整个问题完全转化为坐座位问题，与原问题没有关系，不要混淆。**

**为了计算方便，我们把相同的两个数看成不同的，以便计算，在最后的时候除以$$(2!)^n$$即可。**

其实这个选座位的模型比较经典，我们考虑$$dp$$，这个$$dp$$的状态一点都不自然，记住就好：

设$$f[i][j]$$表示选了前$$i$$个人，目前座位前$$j$$个位置被选了，且第$$j+1$$个位置没选，其他位置情况不知道的方案数。

注意，这里我们并不考虑其他人的选择情况，只计算前$$j$$个位置上的人和出局的人的选择情况（出局的人一定选的是前$$j$$个中的一个，否则必定有位置选择）。

然后对于其他人选择情况，我们在他所在的那一段被拼接到整个前缀的时候再统计贡献（这个思想非常巧妙，现在读者也许不太明白，看后面就知道了）。

因为每个人是否留下题目已经给定了，现在我们考虑转移。

假设前$$i$$个人中，有$$s_0$$个出局的，$$s_1$$个留下来的。

那么我们现在考虑转移到$$i+1$$。

如果第$$i+1$$个人最后没有留下，那么说明这个人出局了，前面说了，这个人出局说明他的权值一定在前$$j$$个中，否则一定有位置坐。那么考虑他的选择方案，前$$j$$个位置有$$2j$$种权值选择（因为每个出现两次），去掉已经坐下来的$$j$$个人，再去掉出局的$$s_0$$个人（之前出局的人一定在前$$j$$个中），还剩$$2j-j-s_0=j-s_0$$个，那么此时转移方程就是
$$
f[i+1][j]+=f[i][j]*(j-s_0)
$$
再看另外一种情况，第$$i+1$$个人留下来了，那么他又有两种情况：

第一个，他最后没有出现在第$$j+1$$个位置上，根据我们状态的原则，不出现在当前前缀上的人的选择不予考虑（等到后面再考虑），因此
$$
f[i+1][j]+=f[i][j]
$$
第二个，他最后出现在第$$j+1$$个位置上，那么，他会增加$$j$$的值，换句话说，他会将当前的前缀$$j$$和某个段拼接起来。那么，我们枚举他后面那个段的长度$$k$$，那么他的贡献就是
$$
f[i+1][j+k+1]+=f[i][j]*\binom{s_1-j}{k}*(k+2)*g[k]
$$
这是什么意思？首先$$\binom{s_1-j}{k}$$指的是后面那个长度为$$k$$的段的人具体是什么的选择方案数，而当前第$$i+1$$个人的选择，有$$2k-k+2=k+2$$种选择（可以就是$$j+1$$，有两种选择，还可以是后面的段中的某个，有$$2k-k$$种选择）。那么，$$g[k]$$是什么？$$g[k]$$指的是后面这一段中，这$$k$$个人在$$2k$$个数中安排为其中$$k$$个数，使得按人的顺序放最后没有人出局的方案数。

这个看起来没有什么直接的算法（听$$qty$$大佬说是$$C_{k+1}n!$$，不会不会）。

我们考虑用$$dp$$来计算这个问题。

这个问题可以转化为有$$n$$个人，在$$2n$$个数（每个$$[1,n]$$的数出现$$2$$次）中选$$n$$个数，使得最后没有人出局的方案数。

一般这种有两个维度的问题（人，数），我们都从另外一个角度进行$$dp$$（正着角度是人选数，另外一个就是数选人）。

一开始的想法是从小到大考虑数选人，但是后面选的数的位置会影响到前面选的数的位置，所以更容易的想法是从大到小地考虑数选人，因为我们假设已经考虑了前$$i$$大的数，那么选择的座位一定是一个后缀（因为要求没有人出局），更容易思考。

我们考虑目前选的人的相对顺序，然后考虑当前数选的人往前面选的人里插，这是常见思路。

设$$g[i][j]$$表示处理完前$$i$$大的数，选了$$j$$个数的方案数。

那么当前这个数，有三种选择：

第一种，一个都不选，直接过，即$$g[i+1][j]+=g[i][j]$$。

第二种，我们选其中一个，插入到原来人的序列中，因为我们是从大往小考虑的，所以不管插在哪个位置，只要选的是$$\le n$$个人，一定是合法的（即不会有人没位置）。因为有$$j$$个人，所以有$$j+1$$种插空方法，所以
$$
g[i+1][j+1]+=g[i][j]*(j+1)*2
$$
因为这个数有两个，所以任选一个乘以$$2$$。

第三种，我们两个都选，那么一样不管插在哪个位置，只要选$$\le n$$个人都合法，第一个有$$j+1$$个空可插，第二个有$$j+2$$个空可插，所以
$$
g[i+1][j+2]+=g[i][j]*(j+1)*(j+2)
$$
那么我们需要的就是$$g[k][k]$$了！

这样一来，整道题就做完了，不要忘记最后还要除以$$2^n$$。

# Code

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxN = 1205, mod = 1e9 + 7, I = 5e8 + 4;

int n;
int f[maxN + 1][maxN + 1], g[maxN + 1][maxN + 1];
int C[maxN + 1][maxN + 1];
bool flag[maxN + 1];

inline int ADD(int x, int y) { return x + y >= mod ? x + y - mod : x + y; }

inline void pre()
{
	for(int i = 0; i <= n; i++)
	{
		C[i][0] = 1;
		for(int j = 1; j <= i; j++)
			C[i][j] = ADD(C[i - 1][j], C[i - 1][j - 1]);
	}

	g[0][0] = 1;
	for(int i = 0; i < n; i++)
		for(int j = i; j <= n; j++)
		{
			g[i + 1][j] = ADD(g[i + 1][j], g[i][j]);
			if(j + 1 <= n) g[i + 1][j + 1] = ADD(g[i + 1][j + 1], 2ll * (j + 1) * g[i][j] % mod);
			if(j + 2 <= n) g[i + 1][j + 2] = ADD(g[i + 1][j + 2], 1ll * (j + 1) * (j + 2) * g[i][j] % mod);	
		}
}

int main()
{
	scanf("%d", &n);
	for(int i = 1; i <= n; i++)
	{
		int x;
		scanf("%d", &x);
		flag[2 * n - x + 1] = true;
	}

	pre();

	int s0 = 0, s1 = 0;
	f[0][0] = 1;
	for(int i = 0; i < 2 * n; i++)
		if(!flag[i + 1])
		{
			for(int j = s0; j <= s1; j++)
				f[i + 1][j] = ADD(f[i + 1][j], 1ll * f[i][j] * (j - s0) % mod);
			s0 ++;
		}
		else
		{
			for(int j = s0; j <= s1; j++)
			{
				f[i + 1][j] = ADD(f[i + 1][j], f[i][j]);
				for(int k = 0; k <= s1 - j; k++)
					f[i + 1][j + k + 1] = ADD(f[i + 1][j + k + 1], 1ll * f[i][j] * C[s1 - j][k] % mod * g[k][k] % mod * (k + 2) % mod);
			}
			s1 ++;
		}

	int ans = f[2 * n][n];
	for(int i = 1; i <= n; i++) ans = 1ll * ans * I % mod;

	printf("%d", ans);
	return 0;
}

```

# 总结

以后遇到这种计数题，可以先考虑怎样判定一个最终状态（或初始状态）是否满足条件，可以简化许多问题。

遇到有相同数的时候，有时将它们看成不同的，最后再除以$$k!$$，会使问题简化，一定要想到这一点。

遇到这种选座位模型的题目，要想想那个奇怪的状态定义$$f[i][j]$$表示处理了前$$i$$个人，选座位的前缀是$$j$$，这样的好处是如果某个人出局，那么他选的一定是前$$j$$个里面的一个。主要难点在于考虑每次考虑合并前缀和某一段。

我们遇到有两个维度相关的问题，一般不从题目给的角度来考虑，而从另外的一个角度考虑，有时问题就迎刃而解。

一定熟练掌握考虑选择东西的相对顺序，后面选的往前面插的思路，有时能解决许多问题。

有一些限制的时候，我们将限制从小往大这样考虑问题，这样的话前面选的数一定符合后面的限制，选择的时候可以直接排除，无需顾虑太多。