---
title: 浅谈最小表示法
date: 2021-04-08 11:12:27
tags: [字符串]
categories: [学习笔记]
---

# Description

给定一个字符串$$s$$，求它的一个循环表示（即每次只能把字符串的开头字符删掉并插入到结尾），使得其是该字符串所有循环表示中字典序最小的一个。

<!--more-->

# Solution

首先，设原字符串的长度为$$n$$，然后我们将字符串倍长。

考虑我们有两个指针$$i,j$$表示候选位置，现在我们想比较这两个位置谁更优秀。

那么暴力就是我们枚举长度$$k$$，如果存在$$s[i+k]>s[j+k]$$就让$$i++$$，如果$$s[i+k]<s[j+k]$$就让$$j++$$，并且让$$k=0$$。如果相等就继续往后枚举，即$$k++$$。

特别地，如果某次移动后发现$$i==j$$，那么我们让$$j++$$。

如果$$i$$和$$j$$开头的字符串相等，即$$k$$一直枚举到了$$n$$，这说明该字符串可以看成由一个长度为$$len=|j-i|$$的字符串（假设为$$t$$）复制若干次形成（最后一块可能不是整块），换句话说，我们可以看成有一个无限的由$$t$$不断复制得到的字符串，那么原字符串就是在这个无限字符串中截取一个长度为$$n$$的字符串得来的。

那么，这说明了什么呢？这说明该字符串本质不同的循环同构串只有$$len$$种。根据我们的算法，我们发现$$i<j$$，那么说明本质不同的循环同构串只有以$$i,i+1,\dots,j-1$$为开头的$$len$$个。而既然已经枚举到了$$j$$，那么说明以$$i$$开头的字符串是$$i,i+1,\dots,j-1$$这$$len$$个字符串中最小的一个，因此它就是答案。

这样，最后的答案就是$$i$$。

然后我们发现这个暴力是可以优化的，因为如果$$s[i+k]>s[j+k]$$，那么$$i+1\sim i+k$$都不可能作为答案，因为对于$$1\le p\le k$$，考虑$$i+p$$开头的字符串，总有$$j+p$$开头的字符串比它优，因此我们可以直接让$$i+=k+1$$即可。

但是这样我们就不能保证$$i<j$$，因此最后的答案是$$\min(i,j)$$。

时间复杂度为$$O(n)$$。

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxN = 1e6 + 10;

int n;
int s[maxN + 1];

inline int read()
{
	int num = 0, f = 1;
	char ch = getchar();
	while( !isdigit( ch ) ) { if(ch == '-') f = -1; ch = getchar(); }
	while( isdigit( ch ) ) num = (num << 3) + (num << 1) + (ch ^ 48), ch = getchar();
	return num * f;
}

int main()
{
	n = read();
	for(int i = 1; i <= n; i++)	s[i] = s[i + n] = read();

	int i = 1, j = 2, k = 0;
	while(i <= n && j <= n && k < n)
	{
		if(s[i + k] == s[j + k]) k ++;
		else
		{
			if(s[i + k] > s[j + k]) i += k + 1;
			else j += k + 1;
			if(i == j) j ++;
			k = 0;
		}
	}

	int x = min(i, j);
	for(int i = x; i <= x + n - 1; i++) printf("%d ", s[i]);
	puts("");
	return 0;
}
```

