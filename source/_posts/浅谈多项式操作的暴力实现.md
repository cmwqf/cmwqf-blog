---
title: 浅谈多项式操作的暴力实现
date: 2020-07-27 10:59:35
tags: [生成函数, 多项式]
categories: [学习笔记]
---

# 多项式操作的暴力实现

对于有些题目，数据范围很小或者模数不是$$998244353$$，这个时候用$$NTT$$就不适用了，比如对于$$n\le 1000$$做多项式$$\exp$$，那么显然不如暴力$$O(n^2)$$常数小。另外，在考场上如果能用暴力写多项式操作尽量用暴力，因为码量小，好调试。

因此，我们不仅要掌握如何用$$NTT$$求多项式，还要了解暴力求解多项式的各种方法。

注意，暴力求解的复杂度都是$$O(n^2)$$。

<!--more-->

# 多项式乘法

这个不用多说，根据定义直接类似背包实现即可。

```c++
for(int i = 0; i < n; i++)
    for(int j = 0; j < m; j++)
        ans[i + j] += f[i] * g[j];
```



# 多项式除法

如果多项式能整除且我们要求除后的商，那么我们将背包操作倒过来实现即可。

如果我们要求除后的余数（比如线性递推），可以用类似数学的方法，每次提取因式消去最高项即可。

```c++
for(int i = n; i >= m; i--)
    if(g[i])
    {
        int t = 1ll * g[i] * mpow(f[m], mod - 2) % mod; 
        for(int j = m; j >= 0; j--)
            g[i - j] -= 1ll * f[j] * t % mod;
    }
```

# 多项式求逆

我们已知$$F(x)$$，我们现在要求一个$$G(x)$$，使得$$F(x)G(x)\equiv1\pmod{x^m}$$。

那么根据定义，我们有
$$
[x^n]F(x)G(x)=\sum_{i=0}^nf_ig_{n-i}=[n=0]
$$
那么
$$
g_nf_0=[n=0]-\sum_{i=1}^{n}f_ig_{n-i}
$$
直接递推即可。

# 多项式ln

我们已知$$F(x)$$，要求$$G(x)\equiv\ln F(x)\pmod{x^m}$$。

首先，我们两边求导
$$
G'(x)\equiv\frac{F'(x)}{F(x)}\pmod{x^m}\\
G'(x)F(x)\equiv F'(x)\pmod{x^m}
$$
那么
$$
[x^{n-1}]G'(x)F(x)=\sum_{i=0}^{n-1}f_ig_{n-i}(n-i)=f_nn
$$
即
$$
f_0g_nn=f_nn-\sum_{i=1}^{n-1}f_ig_{n-i}(n-i)
$$
根据定义，边界条件为$$g_0=0$$，递推即可。

# 多项式exp

我们已知$$F(x)$$，要求$$G(x)\equiv \exp F(x) \pmod{x^m}$$。实际上，我们要求
$$
G(x)\equiv \sum_{i\ge 0}\frac{F^i}{i!}\pmod{x^m}
$$
首先我们两边求导，有
$$
G'(x)\equiv G(x)F'(x)\pmod{x^m}
$$
那么
$$
[x^{n-1}]G'(x)=g_nn=\sum_{i=0}^{n-1}f_{i+1}(i+1)g_{n-1-i}
$$
即
$$
g_nn=\sum_{i=1}^{n}f_iig_{n-i}
$$
根据定义，$$g_0=1$$，依然直接递推即可。