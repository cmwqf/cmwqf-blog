---
title: 浅谈AC自动机
date: 2020-03-28 09:58:41
tags: [AC自动机, 字符串]
categories: [学习笔记]
---

# AC自动机

所谓$$AC$$自动机，实际上就是在$$Trie$$树上建立$$KMP$$，在多串匹配时有重要的作用。

<!--more-->

# Fail指针

$$AC$$自动机最重要的，就是这个$$fail$$指针了。这个$$fail$$指针类似于$$KMP$$的$$nxt$$数组，只不过因为会有多个串，所以$$fail$$指针指的位置可能不是当前这个串的前缀，而是别的某个字符串的前缀。

一个节点的$$fail$$指针的定义，即整个$$Trie$$树上所有节点代表的字符串中（都是给定的那些串的前缀），**是当前节点接受的字符串后缀，且是所有符合这个条件的节点中长度最长的那个串的节点。**

类比一下$$nxt$$数组，含义就非常清晰了。

在做匹配的时候，如果这个点没有$$ch[c]$$这个孩子，那么就不断地跳$$fail$$指针，直到有一个$$ch[c]$$的节点停下。类似于$$KMP$$时跳$$nxt$$的过程，非常清晰。

但实际上，在$$Trie$$树上如果暴力跳$$fail$$，时间复杂度是不对的，然而我们在构建$$AC$$自动机时有一种非常巧妙的方法，既能完美地构建出自动机，又能巧妙地解决时间问题。

我们想到，既然每次如果找不到$$ch[c]$$就要暴力往上跳找到第一个有$$ch[c]$$的节点，那么我们何不直接将当前节点的$$ch[c]$$直接指向按照$$fail$$往上跳时第一个由$$ch[c]$$的节点的$$ch[c]$$呢（如果没有这样的$$ch[c]$$就直接指向根节点）？这样一来，每次就不用暴力往上跳了。而此时，这个东西显然不是一棵树，而是一张有向图。

但是，怎么构建这张图呢？这就是$$AC$$自动机的妙处。

# 构建AC自动机

一个显然的性质时，在$$Trie$$树上，所有节点的$$fail$$指针指的节点的深度一定比当前节点要小。

那么，我们考虑用$$bfs$$来构建$$AC$$自动机。

初始情况自然是

```c++
for(int i = 0; i < 26; i++)
    if(st[root].ch[i]) st[ st[root].ch[i] ].fail = root, q.push(st[root].ch[i]);
```

然后我们开始$$bfs$$，考虑如果我们当前出队的节点是$$x$$，那么所有深度小于$$x$$的节点一定全部处理完了，所谓处理完了，就是已经求出了$$fail$$指针，且$$ch[c]$$已经指向了往上跳$$fail$$时遇到的第一个$$ch[c]$$。

那么，我们考虑扩展到所有的$$ch[x][c]$$，$$ch[x][c]$$存在的话，那么就计算它的$$fail$$，显然$$fail[ch[x][c]]=ch[fail[x]][c]$$，然后将$$ch[x][c]$$压入队中。否则，如果不存在的话，那么直接将其设为$$ch[x][c]=ch[fail[x]][c]$$。因为此时$$fail[x]$$的深度一定小于$$x$$，所以$$fail[x]$$的所有信息都已经计算完了，所以这样做一定是对的。

那么构建$$AC$$自动机的代码就很简单了：

```c++
inline void get_fail()
{
    queue<int> q;
    for(int i = 0; i < 26; i++)
        if(st[root].ch[i]) st[ st[root].ch[i] ].fail = root, q.push(st[root].ch[i]);
    while(!q.empty())
    {
        int x = q.front(); q.pop();
        for(int i = 0; i < 26; i++)
            if(st[x].ch[i]) st[ st[x].ch[i] ].fail = st[ st[x].fail ].ch[i], q.push(st[x].ch[i]);
        	else st[x].ch[i] = st[ st[x].fail ].ch[i];
    }
}
```

# AC自动机用法

## 例一

多模式串匹配自然不用多说了，直接每次在$$Trie$$图上跑即可。

## 例二

如果统计每个模式串在文本串出现的次数，怎么做呢？

考虑我们构建出来的$$fail$$指针和所有节点，显然构成了一棵树（每个节点都由且仅有唯一一个$$fail$$指针），我们把这棵树给建出来，观察性质。

**我们发现每个节点代表的字符串都是其所有子树代表字符串的后缀，也可以说，一个节点所有祖先代表的字符串都是这个节点代表字符串的后缀。**

那么，我们用文本串在$$Trie$$图上跑的时候，如果经过了某个节点，实际上的贡献应该是这个节点所有祖先的权值之和（我们让每个$$Trie$$树上的字符串在它成为文本串的某个前缀的后缀时产生贡献，请读者仔细理解）。那么利用树上差分，我们将经过的所有节点计数器加一，最后遍历整棵树统计一下答案即可。

这个$$fail$$树的性质非常重要，可以说是精髓所在，请读者仔细理解其中含义。

实际上，对于$$KMP$$我们也可以建立这样一棵类似的树（每个点的$$nxt$$都存在且唯一），也有类似的性质。

另外，在统计贡献的时候，统计所有当前节点后缀的节点的贡献，能做到不重不漏。



