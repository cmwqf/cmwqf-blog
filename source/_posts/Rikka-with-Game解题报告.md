---
title: Rikka with Game解题报告
date: 2021-01-19 15:04:15
tags: [线性代数,博弈论]
---

# Description

有$$n$$个人玩游戏，有些人是朋友关系（用邻接矩阵给出）。

游戏开始时，先选一个人成为龙，剩下的人为勇士。

每轮游戏过程如下：每个勇士选择是否攻击龙，如果这个勇士和龙有朋友关系那么一定不会攻击。如果所有勇士都不攻击，游戏结束，龙胜利。否则龙被淘汰，且编号最小的选择攻击的勇士成为新的龙，游戏进入下一轮。

游戏结束后，被淘汰的玩家获得$$1$$分，活着的勇士获得$$10$$分，活着的龙获得$$100$$分。

假设每个玩家足够聪明，都想最大化自己分数。现在，对于每个玩家，你要回答：如果第一轮选的龙是他，他是否能获得$$100$$分。

其中$$n\le 500$$。
<!--more-->

# Solution

首先注意到游戏最多只会进行两轮。

因为每个玩家都足够聪明，所以每个玩家都能预测出整个游戏的过程。那么，第一轮中，一个勇士选择攻击龙当且仅当在下一轮中他能成为龙且在下一轮中获胜。

如果他选择攻击龙之后在下一轮中成为龙并且失败了，那么他只能获得$$1$$分，如果他什么都不干，能获得$$10$$分，因此只有当他确定下一轮他成为龙且必胜时，他才会选择攻击龙。

遇到这种博弈论问题，我们可以设计出$$dp$$。设$$f(s,i)$$表示勇士的集合为$$s$$，且当前龙是$$i$$，这一轮中龙能否获胜。

转移考虑枚举$$s$$中的每个元素$$j$$，如果$$i,j$$不是朋友关系，那么考虑$$f(s-\{j\},j)$$，如果它是$$true$$，即如果下一轮$$j$$成为龙能获胜，那么他就会选择攻击，$$i$$就会失败。

设朋友关系的图的补图为$$G$$，那么转移为
$$
f(s,i)=\prod_{j\in S,(i,j)\in G}[f(s-\{j\},j)=false]
$$
即这一轮中$$i$$能获胜当且仅当所有能攻击的勇士选择攻击之后都无法获胜。

考虑观察转移形式，可以发现这个转移式类似一个经典的博弈模型：

有一张图$$G$$，$$Alice$$和$$Bob$$轮流移动棋子。一开始棋子在某个节点$$u$$，每一步可以把棋子移向任意一个与$$u$$相邻的且没有经过的点$$v$$，不能移动者算输，$$Alice$$先手。对于每个$$1\le u\le n$$，求出一开始棋子在$$u$$时$$Alice$$能否获胜。

这个问题的转移为设$$f(s,i)$$表示目前没有到过的节点集合为$$s$$，当前在节点$$i$$，先手能否获胜。

那么有
$$
f(s,i)=!(\prod_{j\in S,(i,j)\in G}[f(s-\{j\},j)=true])
$$
其中$$!$$表示取反。可以发现，这个转移和我们原问题的转移方程差异仅在胜负的定义相反，即原问题的胜，在新问题中是负；原问题中的负，在新问题中是正。

那么，我们可以把原问题完全转化到这个新的问题上来。

这个经典问题的结论是：起点在$$u$$时先手能获胜当且仅当$$u$$出现在所有$$G$$的最大匹配中。换句话说，不存在某个$$G$$的最大匹配$$M$$，使得$$u\notin M$$。

为什么呢？

我们先证明，如果存在某个$$G$$的最大匹配$$M$$，使得$$u\notin M$$，那么先手必败。

考虑从$$u$$先随便走一条边到一个点$$v$$，那么一定有$$v\in M$$，否则$$(u,v)$$能构成一组新的匹配，原匹配不是最大匹配。那么后手只要沿着$$v$$的匹配边走即可。即$$Alice$$每次都会走一条非匹配边，$$Bob$$每次都会走一条匹配边。这样走下去，$$Bob$$必胜。因为假设某一次$$Alice$$走完一条非匹配边后，$$Bob$$没法走一条匹配边。那么回顾走过的路，是一条开头和结尾都是非匹配边的交错轨，那么如果我们把这条路上的边全部取反（即非匹配边变为匹配边，匹配边变为非匹配边），那么会获得一个更大的匹配，与最大匹配矛盾。

接下来我们要证明如果$$u$$出现在$$G$$的所有最大匹配中，先手必胜。

随便选择某个最大匹配$$M$$。$$Alice$$走的策略即每次走匹配边，$$Bob$$每次只能走非匹配边。如果存在某一步$$Bob$$走完后$$Alice$$走不了了，那么回顾走过的这条路径，一定是开头为匹配边，结尾为非匹配边的交错轨，那么我们把这条路径上的边取反，会得到一个新的最大匹配，且起点不被包含在这个最大匹配中，与假设矛盾。

那么，我们现在的问题就是对于每个点，我们要判断它是否出现在所有的最大匹配中。

先考虑如何求出一般图的最大匹配。可以考虑带花树，但是那个比较复杂。

考虑定义$$tutte$$矩阵$$T$$。对于$$\forall (i,j)\in G$$，$$A_{i,j}=val_{i,j}$$，$$A_{j,i}=-val_{i,j}$$。其中$$val_{i,j}$$是对这条边设的一个随机权值。而对于$$\forall (i,j)\notin G$$，$$A_{i,j}=0$$。

结论是：矩阵$$T$$的秩的$$\frac{1}{2}$$就是$$G$$的最大匹配数（可以证明，$$T$$的秩一定是偶数）。

具体证明和理论可以参考$$2017$$国家集训队论文：《基于线性代数的一般图匹配》（杨家齐）。此处略去。

这样，我们可以通过高斯消元在$$O(n^3)$$的时间复杂度内算出最大匹配数。

回到判定点是否在最大匹配中的问题。

一个想法是考虑删掉这个点，看剩下的图的最大匹配是否和原图最大匹配相等。如果相等，那么这个点就不会出现在所有最大匹配中。但这样时间复杂度是$$O(n^4)$$，无法接受。

假设我们考虑的点为$$s$$。

考虑新加一个点$$ns$$，并将这个点向$$s$$连一条边，那么我们只需要判断新图的最大匹配是否增加即可。因为如果存在一个最大匹配，使得$$s$$不在最大匹配中，那么$$s$$和$$ns$$能构成一组新的匹配，换句话说，会使最大匹配增加$$1$$。否则，如果对于所有的最大匹配$$s$$都在其中，因为$$ns$$只与$$s$$连边，因此最大匹配不会变化。

现在的问题就是每次考虑在原矩阵右边和下边新增一行一列，问新的矩阵的秩是否增加。每次暴力做显然无法接受，但是我们可以考虑优化。

首先考虑高斯消元是行变换，因此我们可以把新增的那一列看成原矩阵的增广矩阵，即把原矩阵扩充为$$n$$行$$2n$$列的矩阵，其中第$$n+i$$列表示的是当我们考虑第$$i$$个点为起点时向右边新增的一列，那么我们可以在对原矩阵进行高斯消元的同时对右边增广的列也做同样的变换，就可以在$$O(n^3)$$的时间复杂度内算出高斯消元后右边的列。

现在对于每个点$$s$$，先考虑如果除了以$$1,2,\dots,n$$为主元的行向量外存在某个行向量的第$$n+1$$位非零，那么就多了以$$n+1$$为主元的行向量，使得秩增加$$1$$，可以直接返回。

接下来考虑加入的一行。高斯消元是支持加入一个行向量的，具体可以考虑线性基的构造过程，我们让$$i$$从$$1$$到$$n+1$$来扫，如果加入的行向量第$$i$$个元素非零，考虑矩阵中，如果存在以这个位置为主元的向量，那么我们用这个向量去消加入的行向量，再继续往下做。否则，我们就使矩阵的秩增加了$$1$$，即可返回。

这样时间复杂度为$$O(n^3)$$，可以通过本题。

# Code

```c++
#include <bits/stdc++.h>
using namespace std;

mt19937 rnd( time(NULL) );

const int maxN = 510, mod = 1e9 + 7;

int n, ct;
int a[maxN + 1][maxN * 2 + 1], id[maxN + 1];
int b[maxN + 1][maxN + 1], v[maxN + 1], val[maxN + 1];
char s[maxN + 1][maxN + 1];

inline void update(int &x, int y) { x = x + y >= mod ? x + y - mod : x + y; }

inline int mpow(int a, int x)
{
	int ans = 1;
	while(x)
	{
		if(x & 1) ans = 1ll * ans * a % mod;
		a = 1ll * a * a % mod;
		x >>= 1;
	}
	return ans;
}

inline void Gauss()
{
	for(int i = 1; i <= n; i++)
	{
		int p = 0;
		for(int	j = ct + 1; j <= n; j++)
			if(a[j][i]) { p = j; break; }
		if(!p) continue;
		id[i] = ++ ct;
		if(p != ct) swap(a[p], a[ct]);
		int INV = mpow(a[ct][i], mod - 2);
		for(int j = ct + 1; j <= n; j++)
		{
			int t = 1ll * INV * a[j][i] % mod;
			for(int k = i; k <= 2 * n; k++)
				update(a[j][k], mod - 1ll * a[ct][k] * t % mod);
		}
	}
}

inline bool check()
{
	for(int i = ct + 1; i <= n; i++)
		if(b[i][n + 1]) return true;
	for(int i = 1; i <= n + 1; i++)
	{
		if(!v[i]) continue;
		if(!id[i]) return true;
		int t = 1ll * v[i] * mpow(b[ id[i] ][i], mod - 2) % mod;
		for(int j = i; j <= n + 1; j++)
			update(v[j], mod - 1ll * b[ id[i] ][j] * t % mod);
	}
	return false;
}

int main()
{
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) scanf("%s", s[i] + 1);

	for(int i = 1; i <= n; i++)
		for(int j = i + 1; j <= n; j++)
			if(s[i][j] == '0')
			{
				int x = rnd() % (mod - 1) + 1;
				a[i][j] = x; a[j][i] = mod - x;
			}
	for(int i = 1; i <= n; i++)
		a[i][n + i] = val[i] = rnd() % (mod - 1) + 1;

	Gauss();

	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= n; j++)
			b[i][j] = a[i][j];
	
	for(int s = 1; s <= n; s++)
	{
		for(int i = 1; i <= n; i++)
			b[i][n + 1] = a[i][n + s];
		for(int i = 1; i <= n + 1; i++)
			if(i == s) v[i] = mod - val[s];
			else v[i] = 0;
		putchar(check() ? '1' : '0');	
	}
	puts("");
	return 0;
}
```

