---
title: 浅谈快速傅里叶变换FFT
date: 2020-03-08 17:22:12
tags: [生成函数, 多项式]
categories: [学习笔记]
---

# 快速傅里叶变换(FFT)

在$$OI$$中，快速傅里叶变换一般是用来解决多项式乘法（卷积）问题的，什么是卷积？

设有两个函数$$F(x),G(x)$$，那么
$$
H[n]=(F*G)[n]=\sum_{i=0}^n F[i]*G[n-i]
$$
一般来说，暴力计算这个$$H$$是$$O(n^2)$$的，快速傅里叶变换可以将这个过程复杂度降低为$$O(n\log_2n)$$。

本文将通过单位根反演来详细介绍快速傅里叶变换的原理，并讲解$$FFT$$的两个组成部分$$DFT,IDFT$$的推导。

<!--more-->

# 多项式点值表示法

我们一般见到的多项式是系数表示法，即
$$
F(x)=a_0+a_1x+a_2x^2+...
$$
我们知道，一个$$n$$次多项式可以由$$n+1$$个不同点唯一确定，那么我们将这$$n+1$$个点$$(x_i,F(x_i))$$看成这个多项式的点值表示法。

而对于点值表示法进行多项式乘法却异常地简单，只需将两个多项式点值表示法中横坐标相同的点的纵坐标相乘即可，复杂度线性。

但是，一般题目中给我们的都是系数表示法，暴力转化成点值表示法依然是$$O(n^2)$$的。实际上，快速傅里叶变换就是加速将多项式**系数表示法**转化为**点值表示法**的过程，将其的复杂度降为$$O(nlog_2n)$$。

# 复数相关

因为多项式点值表示法并不唯一，我们假设多项式次数为$$n-1$$，那么带入任意的$$n$$个$$x$$都可以得到一组点，那么，我们考虑将$$n$$个单位根$$w_n^0,w_n^1...w_n^{n-1}$$带入，得到不同的点值。

那么，单位根是什么？我们从头讲起。

## 复数

单位根是定义在复数意义上的，复数是形如$$a+bi(a,b\in R,i=\sqrt{-1})$$的形式的数，对应复平面上的$$(a,b)$$的向量。

模长：复数的模长定义为$$\sqrt{a^2+b^2}$$，即该复数在复平面上对应向量到原点的距离。

## 复数基本运算

复数加减：$$(a+bi)+(c+di)=(a+c)+(b+d)i$$。

复数乘法：$$(a+bi)(c+di)=(ac-bd)+(ad+bc)i$$（可以暴力展开，将$$i^2$$看成$$-1$$即可）。

复数相乘，在复平面上的意义为**模长相乘，辅角相加**。

## 共轭复数

我们称$$a+bi$$和$$a-bi$$为共轭复数，在复平面上，可以看成关于$$x$$轴对称的两个向量。

## 单位根

单位根，就是满足$$z^n=1$$的复数（可以看作将复平面上单位圆平均分为$$n$$个部分的单位复数），记为$$w_n$$。

所谓$$n$$次单位根，就是将单位圆平分为$$n$$个部分的$$n$$个向量对应的复数。依次记为$$w_n^0,w_n^1,w_n^2...w_n^{n-1}$$。

我们记$$w_n$$的辅角为$$\theta=\frac{2\pi}{n}$$，那么每次$$w_n^k->w_n^{k+1}$$在图像上的意义就是$$w_n^k$$逆时针旋转$$\theta$$得到的向量。

考虑单位根的时候，一般放在复平面中考虑，更容易理解。

## 单位根性质

性质$$1$$：$$w_{2n}^{2k}=w_n^k$$，这个根据复平面上的平分单位圆的概念很直观，不作解释。

性质$$2$$：$$w_n^{k+\frac{n}{2}}=-w_n^k$$，相当于将$$w_n^k$$逆时针转$$\pi$$得到$$w_n^{k+\frac{n}{2}}$$，自然横纵坐标都取反。

实际上，$$FFT$$就是根据这两个简单的性质进行的。

# 离散傅里叶变换(DFT)

我们现在要把$$w_n^0,w_n^1,...w_n^{n-1}$$带入多项式，计算其点值。

我们令$$m=\frac{n}{2}$$，因为$$n$$是$$2$$的整数次幂，所以$$m$$也一定是整数。

我们设
$$
A(w_n^k)=\sum_{i=0}^{n-1}a[i](w_n^k)^i
$$
注意，这里的$$a[i]$$和原来多项式中的$$a[i]$$不同，只是由上一层递归下来得到的$$n$$个数，后面我们会知道是什么。

那么，对于$$k<\frac{n}{2}$$，即$$k<m$$，我们有
$$
A(w_n^k)=\sum_{i=0}^{n-1}a[i](w_n^{k})^i\\
=\sum_{i=0}^{m-1}a[2i](w_n^k)^{2i}+\sum_{i=0}^{m-1}a[2i+1](w_n^k)^{2i+1}\\
=\sum_{i=0}^{m-1}a[2i]w_n^{2ki}+\sum_{i=0}^{m-1}a[2i+1]w_n^{2ki+k}\\
=\sum_{i=0}^{m-1}a[2i]w_{2m}^{2ki}+w_n^k\sum_{i=0}^{m-1}a[2i+1]w_{2m}^{2ki}
$$
根据上面所说的性质一，$$w_{2n}^{2i}=w_n^i$$可知
$$
A(w_n^k)=\sum_{i=0}^{m-1}a[2i]w_m^{ki}+w_n^k\sum_{i=0}^{m-1}a[2i+1]w_m^{ki}
$$
又由性质三，我们可以知道：
$$
A(w_n^{k+\frac{n}{2}})=(-1)^{\frac{n}{2}}\sum_{i=0}^{m-1}a[2i]w_m^{ki}+(-1)^{\frac{n}{2}}w_n^{k+\frac{n}{2}}\sum_{i=0}^{m-1}a[2i+1]w_m^{ki}\\
=\sum_{i=0}^{m-1}a[2i]w_m^{ki}-w_n^k\sum_{i=0}^{m-1}a[2i+1]w_m^{ki}
$$
我们递归到下一层的时候分别**分治偶数项和奇数项**计算对应的点值，设为$$A_0,A_1$$，那么显然有
$$
A(w_n^k)=A_0(w_\frac{n}{2}^k)+w_n^kA_1(w_{\frac{n}{2}}^k)\\
A(w_n^{k+\frac{n}{2}})=A_0(w_\frac{n}{2}^k)-w_n^kA_1(w_{\frac{n}{2}}^k)
$$
那么，实际上我们每次递归到的一层的$$a$$是上一层$$a$$的奇数项或偶数项。

这样，时间复杂度是$$O(n\log_2n)$$。

由于递归效率不高，所以一般采用迭代的方式来实现这个过程，即注意到多项式的$$i$$次项到分治边界时的下标为$$r[i]$$，$$r[i]$$是$$i$$二进制翻转后的数，所以我们每次从下往上迭代即可。

# FFT的原理

知道了这些前置知识，我们就可以来学习$$FFT$$的原理了。

我们可以用单位根反演来理解$$FFT$$的原理。

我们要明确，$$FFT$$本质上求的是**循环卷积**，也就是说，我们实际上求的是
$$
C_r=\sum_{(i+j)\bmod n=r}A_i*B_j
$$
而在平时的应用中，如果我们只是单纯地要求卷积，只需让$$n$$变为一个比较大的数，从而使$$(i+j)\bmod n=(i+j)$$，从而形成卷积的效果。但是要明确，$$FFT$$实际上是用来求循环卷积的。

而$$FFT$$的推导，也是基于循环卷积的性质。我们可以把式子写为
$$
C_r=\sum_{i,j}[(i+j)\bmod n=r]A_i*B_j
$$
中间这个取模的形式让我们想到**单位根反演**，如果读者不是很了解，可以先阅读[单位根反演](https://cmwqf.github.io/2020/01/08/%E6%B5%85%E8%B0%88%E5%8E%9F%E6%A0%B9%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/)。

上面的式子可以变换为
$$
C_r=\sum_{i,j}[(i+j-r)\bmod n=0]A_i*B_j
$$
那么根据单位根反演，有
$$
C_r=\sum_{i,j}A_i*B_j*\frac{1}{n}\sum_{k=0}^{n-1}w_n^{(i+j-r)k}
$$
这样，我们就完美地去掉了$$(i+j)\bmod n=r$$的限制。

进一步地，
$$
C_r=\frac{1}{n}\sum_{k=0}^{n-1}(w_n^{-r})^k*\sum_{i}A_i(w_n^k)^i*\sum_{j}B_j(w_n^k)^j
$$
现在，我们发现之前求的点值派上了用场，记
$$
DFT(A)_k=\sum_{i}A_i(w_n^k)^i\\
DFT(B)_k=\sum_iB_i(w_n^k)^i
$$
那么应用我们之前的方法，我们可以在$$O(n\log_2n)$$的时间复杂度内求出$$DFT(A)$$和$$DFT(B)$$。

我们记
$$
T_k=DFT(A)_k*DFT(B)_k
$$
那么问题便转化为求
$$
C_r=\frac{1}{n}\sum_{k=0}^{n-1}(w_n^{-r})^kT_k
$$
前面的$$\frac{1}{n}$$可以忽略，最后再乘上去，对于剩下的部分，容易发现，这个式子和求点值的式子几乎一模一样，只是原本里面单位根的上标变成负的了。

注意到$$w_n^{-r}=w_n^{n-r}$$，因此我们可以把$$T$$直接进行$$DFT$$，然后对于$$1$$到$$n-1$$的点值直接$$reverse$$一下，最后乘上$$\frac{1}{n}$$即可得到$$C$$。

其实这个过程，就是$$IDFT$$。

综上，我们可以在$$O(n\log_2n)$$的时间复杂度内解决多项式乘法。

# Code

```c++
inline void FFT(Complex *a, int type, int lim)
{
	for(int i = 0; i < lim; i++)
		if(i < r[i]) swap(a[i], a[ r[i] ]);
	for(int mid = 1; mid < lim; mid <<= 1)
		for(int i = 0; i < lim; i += (mid << 1))
			for(int j = 0; j < mid; j++)
			{
				Complex x = a[i + j], y = a[i + mid + j] * wn[mid + j];
				a[i + j] = x + y; a[i + mid + j] = x - y;
			}
	if(type == -1)
	{
		for(int i = 0; i < lim; i++) a[i] /= lim;
		reverse(a + 1, a + lim);
	}
}
```

