---
title: 浅谈后缀数组
date: 2019-02-11 19:29:39
tags: [字符串,后缀数组]
categories: [学习笔记]
---

# 后缀数组的基础

## 后缀定义

对于一个字符串为$$s$$，我们记$$suf[i]$$为$$[i,n]$$这一段字符串，称为后缀。

<!--more-->

## 后缀数组是什么

就我个人的理解来看，后缀数组其实就两个方面，一个记为$$sa$$，一个记为$$rk$$，它们代表什么意思呢？
$$
rk[i]:指s中第i项的后缀在所有后缀中的字典序排名\\
sa[i]:与rk[i]相对应的，指s所有后缀中第i名后缀所在的位置
$$
当然，这两个数组都是为height数组服务的，但height数组是什么，我们后面再说。

这个算法想法离奇，主要就是为了求解$$sa[i],rk[i]$$服务的。

其实，$$sa[i],rk[i]$$只要求解一个就可以了，由定义可知：
$$
sa[rk[i]]=i,rk[sa[i]]=i
$$

## 求解后缀数组

那么，怎么求这个东西呢？

首先，这个算法是基于“**基数排序**”之上的，那么基数排序是什么呢？

### 基数排序

后缀数组之中的基数排序指的是对于一个二元组(p,q)进行多关键字排序，而基数排序可以对两个进行分别处理，从而使时间复杂度降到$$O(n)$$

### 倍增法实现

怎么用倍增法实现？

首先，我们考虑我们已经知道了每个后缀前w个字符的sa和rk，我们考虑怎样向前w*2个字符转移：

我们考虑基数排序，假设我们现在考虑到第i位为起点的长度为2*w后缀

我们以**前w个字符的排名（就是当前的rk[i])**为第一关键字，而**后w个字符的排名（就是当前的rk[i+w])**为第二关键字，进行基数排序。

我们来认识这几个数组：
$$
tp[i]:指第二关键字排名为i的后缀位置\\
bin[i]:指排名第i的后缀出现的个数
$$
我们来更新这个以i为开头长度为2*w的后缀的tp[i]：

因为当i+w>n时，这些i是没有第二关键字的（i+w已经超出了），所以要把先塞进tp数组里。

剩下的，都是i+w<=n的情况了，这个时候，我们不用i来更新，我们设j为排名，则这个排名第j的长为w的后缀可以作为以$$sa[j]-w$$开头的长为2*w的后缀的第二关键字，所以，我们就直接更新就好了：

```c++
p=0;
for(int i=n-w+1;i<=n;i++) tp[++p]=i;
for(int i=1;i<=n;i++) if(sa[i]>w) tp[++p]=sa[i]-w;
```

此时，tp中便是有序的第二关键字了，下面，就要用基数排序，来进行最终的排序。。。

### 排序过程

还记得之前的那个bin数组吗，其中，bin[i]记录的是排名为i的后缀有多少个。

先把代码上一下，有助于理解：

```c++
inline void Qsort()
{
    for(int i=0;i<=m;i++) bin[i]=0;
    for(int i=1;i<=n;i++) bin[rk[i]]++;
    for(int i=1;i<=m;i++) bin[i]+=bin[i-1];
    for(int i=n;i>=1;i--) sa[bin[rk[tp[i]]]--]=tp[i];
}
```

首先，我们用bin[i]统计个数，然后，我们做一次前缀和，这样，我们就可以算出排名为i的后缀的真正的排名（因为会有重复的）。

最后，i从n->1，tp[i]指的是第二关键字排名第i的位置（这样保证了第二关键字的有序），再取一个rk，算出这个位置第一关键字的排名，最后再取一个bin，求出其真正的排名，并将它赋值为tp[i]，bin要--，以便计算下一个。

### 更新rk

一样的，先上代码以便理解：

```cpp
memcpy(tp,rk,sizeof(rk));
rk[sa[1]]=p=1;
for(int i=2;i<=n;i++)
   	rk[sa[i]]=(tp[sa[i-1]]==tp[sa[i]]&&tp[sa[i-1]+w]==tp[sa[i]+w]) ? p : ++p;
```

首先，第一名是没有什么可比较的，设为1。

因为现在tp已经没有用了，而rk又要用于更新，不能直接用，就要用一个临时数组存起来，所以就用tp代替旧的rk。

p就是一个计数器，也可以更新m的值（后面再说）。那一大坨东西是什么？

它指的是，如果目前以sa[i]为开头的长度为$$2*w$$的后缀等于以sa[i-1]为开头的长度为$$2*w$$的后缀，那么p就不用再加了，可以减少循环数量。

至此，基本上就结束了，还有一些小细节，体现在代码中：

题目：[后缀排序](https://www.luogu.org/problemnew/show/P3809)

```c++
#include<cstdio>
#include<cstring>
using namespace std;
const int maxN=1e6 + 1000;
int tp[maxN+1],rk[maxN+1],sa[maxN+1];
int bin[maxN+1];
int n,m,p;
char s[maxN+1];
inline void Qsort()
{
    for(int i=0;i<=m;i++) bin[i]=0;
    for(int i=1;i<=n;i++) bin[rk[i]]++;
    for(int i=1;i<=m;i++) bin[i]+=bin[i-1];
    for(int i=n;i>=1;i--) sa[bin[rk[tp[i]]]--]=tp[i];
}
inline void work()
{
    m='Z';//字符从'0'~'Z'，映射成ASCLL码表
    for(int i=1;i<=n;i++) tp[i]=i,rk[i]=s[i]-'0'+1;
    Qsort();
    for(int w = 1; p < n; m = p,w <<= 1)//不断更新m的值，另外，如果排名数==n，就不用再找了
    {
        p=0;
        for(int i=n-w+1;i<=n;i++) tp[++p]=i;
        for(int i=1;i<=n;i++) if(sa[i]>w) tp[++p]=sa[i]-w;
        Qsort();
        memcpy(tp, rk, sizeof(rk));
        rk[ sa[1] ] = p = 1;
        for(int i = 2; i <= n; i++)
           rk[ sa[i] ] = (tp[ sa[i - 1] ] == tp[ sa[i] ] && tp[ sa[i - 1] + w ] == tp[ sa[i] + w ]) ? p : ++p;
    }
    for(int i=1;i<=n;i++) printf("%d ",sa[i]);
}
int main()
{
    scanf("%s",s+1);
    n=strlen(s+1);
    work();
    return 0;
}
```

# 后缀数组的进阶

## height数组

大家一定会想，就计算这两个数组，有什么用处呢?

其实，就是为了$$height和h$$数组做铺垫的。

我们定义：$$i$$号后缀为以第$$i$$个字符开头的后缀。

我们设$$lcp(x,y)$$为以第$$x$$号后缀和第$$y$$号后缀的最长公共前缀，那么
$$
height[i]=lcp(sa[i],sa[i-1])，即排名为i的后缀和其排名前一位的后缀的最长公共前缀\\
h[i]=height[rk[i]]，即第i号后缀与它排名的前一名的后缀的公共前缀
$$
这个一定要搞清楚。

我们有一个很重要的性质：
$$
h[i]>=h[i-1]-1
$$
证明（~~口胡~~）：

如果$$h[i-1]>1$$，假设第$$i-1$$号后缀与第$$k$$号后缀的最长公共前缀为$$h[i-1]$$，且不止是第一个字符相同，则第$$k+1$$号后缀与第$$i$$号后缀有$$h[i-1]-1$$的公共前缀（除去$$k,i-1$$后就是$$h[i-1]-1$$），而第$$k+1$$号后缀会排在第$$i$$号后缀前面。为什么呢？因为此时，第$$i-1$$号后缀和第$$k$$号后缀第一个字符必然相同，那么，第$$i$$号后缀和第$$k-1$$号后缀仅仅是去掉了一个相同的字符，所以$$k-1$$号后缀必然在$$i$$号后缀前面，否则就与之前矛盾了。

如果$$h[i-1]<=1$$，那么$$h[i-1]-1<=0$$，即$$h[i]>=0$$，这显然正确。

有了这个结论，求解$$h$$数组也就很简单了：

```c++
inline void solve()
{
    int k = 0;
    for(int i = 1; i <= n; i++)
    {
        if(k) k --;
        int j = sa[rk[i] - 1];
        while(s[i + k] == s[j + k]) k ++;
        h[i] = height[rk[i]] = k;
    }
}
```

## height数组的重要应用

1.[本质不同的子串数量](https://cmwqf.github.io/2019/03/11/%E6%9C%AC%E8%B4%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E4%B8%B2%E6%95%B0%E9%87%8F/#more)







