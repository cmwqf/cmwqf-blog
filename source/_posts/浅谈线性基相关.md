---
title: 浅谈线性基相关
date: 2020-02-18 20:53:21
tags: [线性代数]
categories: [学习笔记]
---

# 线性基

我们称一组数$$\{a_1,a_2,...,a_n\}$$互相异或而形成的所有数的集合称为这组数的异或空间$$S$$，那么，线性基就是$$S$$中最小的一个子集$$T$$，使得$$T$$中元素互相异或形成的所有数的集合也是$$S$$。

若集合中所有的$$a_i \in [1, 2^m-1]$$，我们构造出$$m$$个线性基
$$
p_0,p_2,...,p_{m-1}
$$
对于任意$$i$$满足$$p_i$$在二进制下的最高位为$$i$$。

线性基的好处，在于它能用$$log_2(maxv)$$的时间和空间内完成原来集合**子集异或有关的问题**。

<!--more-->

# 线性相关与线性无关

首先，我们要了解什么是线性变换，对于向量来说，线性变换有两种
$$
1. v_1+v_2\\
2. k*v_1(k是标量)
$$
对于一个向量的集合$$\{v_1,v_2,...v_n\}$$来说，如果存在一个$$v_i$$，使得它能被这个集合中的一些向量通过线性变换得到，那么我们称这一组向量是**线性相关**的，反之，则称这一组向量为**线性无关**的。

那么，线性基与这个有什么关系呢？

我们假设我们的原集合都是在$$[1,2^m-1]$$的一些数，那么，我们可以将每个数看成一个$$m$$维向量，每一维是$$0/1$$。

线性基定义在异或中，其中的**线性变换**指的就是**异或**，那么，由于它是能表示出异或空间最小的一个子集，所以线性基中所有元素是**线性无关**的。

这，就说明了线性基的一个性质：

**线性基任意元素异或起来不等于0。**

理由很显然，假设$$a_1\oplus a_2\oplus ...\oplus a_i = 0$$，那么$$a_1=a_2\oplus a_3\oplus a_4...\oplus a_i$$，即$$a_1$$能被其他向量通过线性变换表示，这与线性基是**线性无关**这一性质矛盾。

由此，我们还能发现另外一个性质：

**异或空间中的任何一个数都能且仅能被线性基中的唯一一个非空子集表示。**

什么意思呢？

就是不存在两个不同的非空子集异或出来的数是相同的。

为什么呢？

如果存在两个不同的非空子集异或出来的数是相同的，那么这两个子集的数异或起来（也必定是线性基的一个子集）为$$0$$，与线性基的性质矛盾。

这些性质在分析问题时可能会有大用处。

# 构造原理

我们刚刚提到，可以把每个数看成一个$$m$$维向量。

我们考虑把原来的元素写成一个$$n$$行$$m$$列的矩阵，每个元素是$$0/1$$，我们要构造线性基，就是要将这个矩阵高斯消元（这里运算均为异或）消成一个上三角矩阵，那么前$$m$$行中每行的向量压缩成$$m$$个数，就是线性基。

为什么呢？

我们先证明，$$S=\{a_1,a_2,...a_n\}$$构成的异或空间与$$T=\{a_1\oplus a_2,a_2,...a_n\}$$的异或空间是等价的。

证明其实很简单，考虑原来$$S$$构成的异或空间的某一个数，如果它不需要$$a_1$$就能构造出，那么就不管他。

否则，假设它是$$a_1\oplus x$$，那么此时的$$a_1$$可以由后面$$T$$中$$(a_1\oplus a_2)\oplus a_2$$来代替，所以两者等价。

这个说明了什么？

说明我们将原集合中任意一个数$$a_i$$，用其异或集合中另外一个数$$a_j$$后的值$$a_i\oplus a_j$$代替，异或空间是不变的。

也就是说我们在高斯消元的过程中，可以随意地用某一行去异或另一行，所代表的异或空间都不变。

这也就说明了高斯消元来求线性基的正确性。

# 构造方法

事实上，由于异或的性质，我们并不需要真的求高斯消元。

我们考虑增量法构造。

**Tips: 所谓增量法，指的就是在原来的基础上新增一个元素，进行变化。例如我们熟知的后缀自动机就是增量法构造，说白了，就是支持动态插入一个元素。**

我们假设加入的这个数为$$x$$，我们从高到低地枚举每一位$$i$$，如果$$x$$这一位是$$1$$。

1. 已经有了对应线性基存在，由线性基的性质，后面的数不能存在$$2^i$$这一位，所以要$$x=x\oplus p_i$$（因为异或后构成的异或空间不变）。相当于在高斯消元中把第$$i$$位给消去。

2. 否则，这个数可以构成一个基，那么我们令$$p_i=x$$，并且立刻$$break$$掉。

这相当于在线地进行高斯消元。

# Code

```c++
inline void insert(int x)
{
    //lim 为最大的位数
    for(int i = lim; i >= 0; i--)
        if(x & (1 << i))
        {
            if(p[i]) x ^= p[i]; //如果已经存在，就要把这一位消去
            else
            {
                p[i] = x; //可以作为这一位的线性基
                break;
            }
        }
}
```

# 应用

## 例1

**给定一个集合，选出若干元素，使得异或和最大。**

从大到小地枚举每一位，如果$$ans\oplus p_i > ans$$，那么就$$ans=ans\oplus p_i$$。

为什么这样贪心是对的呢？

考虑如果$$ans\oplus p_i>ans$$意味着什么，意味着原来的$$ans$$第$$i$$位必然是$$0$$，不管后面怎么样，如果这一位异或了，那么第$$i$$位就会变成$$1$$，因为后面的线性基都不可能改变第$$i$$位，所以直接异或一定更优。

## 例2

**给定一个集合，每次给一个数$$x$$，询问这个集合构成的异或空间中是否存在$$x$$。**

其实我们这样构造形成的线性基还不足以体现一些性质，我们考虑这样变换线性基：

```c++
inline void work()
{
    for(int i = lim; i >= 0; i--)
        for(int j = 0; j < i; j++)
            if(p[i] & (1 << j)) p[i] ^= p[j];
}
```

这样，我们构成的线性基就变成了形如

```c++
1xxxx0x0xx0
000001x0xx0
00000001xx0
00000000001
```

的形式，可以发现，如果第$$i$$位存在线性基的话，那么当前仅由第$$p[i]$$来提供第$$i$$位的$$1$$。

也就是说，如果想要第$$i$$位是$$1$$，就必须异或上$$p[i]$$。

那么，如果这个$$x$$的第$$i$$位是$$1$$，那么它的构成中必然存在$$p[i]$$，假设其是$$1$$的位置位$$v_1,v_2,...v_k$$，我们只需要检查$$p[v_1]\oplus p[v_2]...\oplus p[v_k]$$（如果不存在第$$v_i$$位的线性基就把第$$v_i$$位的线性基看成$$0$$），看最后是否等于$$x$$即可，或者反过来，如果$$x$$的第$$i$$位是$$1$$，就让它异或$$p[i]$$，只需检查最后是否等于$$0$$即可（因为异或上$$p[i]$$不会改变$$x$$原本为$$1$$且存在这一位的线性基的那一位的数）。

## 例3

**给定一个集合，选出若干元素构成的所有数中，求第k大。**

我们考虑类似数位$$dp$$的方法从小往大枚举每一个存在线性基的位置，如果我们固定选当前位置的线性基$$p_i$$，假设是第$$s$$个，那么异或空间中第$$i$$位为最高位的数有$$2^{s-1}$$个，我们设置一个计数器$$cnt$$，每次让$$cnt+=2^{s-1}$$，那么我们相当于在从小往大枚举每异或空间里的数。假如第$$s$$个（第$$i$$位）使得$$cnt>k$$，那么说明我们必须要选这一个，那么我们就让$$ans=ans\oplus p_i$$，并且让$$k-=2^{s-1}$$，再从那一位返回，继续这么做（如果$$cnt>k$$就减去并且统计），最后的$$ans$$就是结果。

回顾刚才的过程，我们是在干什么？考虑每次我们加的都是$$2$$的次幂，我们相当于在枚举$$k$$在二进制下的每一位！

那么，我们就直接从小到大枚举每一个存在线性基的位置，假设是第$$s$$个，那么我们只需要判断$$k$$的第$$s-1$$位是否为$$1$$，如果是，就选择这一个线性基，让$$ans$$异或一下即可。

整个过程十分巧妙，笔者也是思考很长时间才明白其中原理，希望读者仔细把原理想清楚。代码虽短，其中的原理其实才是最重要的呢！