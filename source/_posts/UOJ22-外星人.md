---
title: '[UOJ22]外星人'
date: 2020-03-31 12:02:10
tags: [dp, 概率期望]
categories: [UOJ]
---

# Description

有$$n$$个数$$a_i$$，给定初始值$$m$$，你要决定一种排列顺序$$p_1,p_2,...,p_n$$，使得
$$
m\%a_{p_1}\%a_{p_2}...\%a_{p_n}
$$
的值最大，输出最大值，并输出有多少种排列顺序使得最后的值是这个最大值。

其中$$n\le 1000,m,a_i\le 5000$$。

<!--more-->

# Solution

很好的一道题。

首先注意到我们只需要解决第二个问题即可。

注意到，最终序列中如果一个数字前面存在比它小的数，那么这个数必然是没有用的。

我们考虑留下来哪些数（即可能有用的数），留下来的数必然是单调减的，所以我们可以从大往小进行$$dp$$。

可是如果直接这样$$dp$$还是不好算，那么我们有一个十分重要的思想：**计数转概率**。

## 计数转概率

我们通常是将概率转成计数，但是有的时候，特别是有关排列的时候，更好算的是概率，因为我们只需要把我们要的数单独拿出来考虑，别的可以随便选。

我们来看这样一题，我们给$$n$$组数，对于所有数的排列，要求每组某个数在这一组的第一个，问方案数。

那么我们考虑因为每组是独立的，而第$$i$$组的某个数在这一组第一个的概率是$$\frac{1}{s_i}$$（$$s_i$$是这个组的元素个数），那么所有条件都满足的概率就是$$\prod \frac{1}{s_i}$$，那么最后的答案就是$$(\sum s_i)!\prod\frac{1}{s_i}$$。

所以我们遇到这样一类排列问题时，而**条件互不相交或相互包含**的情况下，可以将计数转为概率计算，会简便很多。

------

那么，我们再来看这道题。

我们设$$f[i][j]$$表示处理完前$$i$$大的数以后剩下的数字是$$j$$的概率。

我们考虑转移，对于当前数$$a[i]$$，有两种可能，一种是我们把它留下来，考虑最后序列把它留下来的唯一条件是**它前面没有比它小的数**，也就是说，它是后$$n-i+1$$个数中第一个出现的，那么这个概率就是$$\frac{1}{n-i+1}$$；否则，如果我们不把它留下来，那么唯一的条件就是**它前面出现过比它小的数**，那么相应的概率也就是$$1-\frac{1}{n-i+1}$$，然后直接转移即可。

最后统计答案不用多说，用总排列数乘以概率即可。

# Code

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxN = 5005, mod = 998244353;

int n, m, a[maxN + 1];
int f[maxN + 1][maxN + 1];
int inv[maxN + 1];

inline int ADD(int x, int y) { return x + y >= mod ? x + y - mod : x + y; }

inline int SUB(int x, int y) { return x - y < 0 ? x - y + mod : x - y; }

int main()
{
	scanf("%d %d", &n, &m);
	for(int i = 1; i <= n; i++) scanf("%d", &a[i]);

	sort(a + 1, a + n + 1);
	reverse(a + 1, a + n + 1);

	inv[0] = inv[1] = 1;
	for(int i = 2; i <= n; i++) inv[i] = mod - 1ll * (mod / i) * inv[mod % i] % mod;

	f[0][m] = 1;
	for(int i = 0; i < n; i++)
		for(int j = 0; j <= m; j++)
			f[i + 1][j] = ADD(f[i + 1][j], 1ll * f[i][j] * SUB(1, inv[n - i]) % mod),
			f[i + 1][ j % a[i + 1] ] = ADD(f[i + 1][ j % a[i + 1] ], 1ll * f[i][j] * inv[n - i] % mod);
	
	int ans = 1;
	for(int i = 1; i <= n; i++) ans = 1ll * ans * i % mod;

	for(int i = m; i >= 0; i--)
		if(f[n][i])
		{
			printf("%d\n", i);
			printf("%lld\n", 1ll * ans * f[n][i] % mod);
			return 0;
		}
	return 0;
}
```

# 总结

这个计数转概率的思想非常重要，一定要牢记。

遇到排列问题，如果不好处理，一定要往概率上想一想，如果条件不相交或者包含，就要想到概率解决。

如本题，即条件互相包含的例子。

