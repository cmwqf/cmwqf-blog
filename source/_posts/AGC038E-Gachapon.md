---
title: AGC038E Gachapon
date: 2020-02-29 12:34:17
tags: [dp, 概率期望, 容斥原理]
categories: [Atcoder]
---

# Description

由一个随机数生成器，每次生成一个$$[0,n-1]$$的数，每个数出现的概率为$$\frac{a_i}{S}$$（$$S=\sum a_i$$）。

我们现在要求每个数$$i$$都满足其出现次数$$>=b_i$$的期望时间。

其中$$n\le 400,\sum a_i \le 400, \sum b_i \le 400$$。

<!--more-->

# Solution

其实，本质上就是求一个集合，其中每个元素如果存在，说明它已经出现了$$>=b_i$$次，问这个集合被填满的最晚时间的期望。

很显然，这是$$min-max$$容斥的模型，所以我们先套$$min-max$$容斥
$$
ANS=E(max(S))=\sum_{T\subset S}(-1)^{|T|-1}E(min(T))
$$
其中$$min(T)$$的意思是$$T$$这个集合中的元素开始存在某个出现$$>=b_i$$次的期望时间。

这个问题显然比一开始要求的要好一些，然而还是无法算。

下面是很重要的一步转化，

对于一个集合$$T$$，再考虑一些集合$$S(T)=\{x_i|i\in T,x_i<b_i\}$$，$$x_i$$表示$$i$$出现的次数。

实际上，根据期望的线性，$$E(min(T))$$等于这些$$S(T)$$中每个集合$$s$$走向下一个状态的期望步数乘以到达$$s$$这个状态的概率。

为什么？

我们考虑所有的$$S(T)$$中的集合$$s$$构成一张有向无环图，每个点表示一个状态$$s$$，连向每个后继状态一条边，边权是走到那个状态的期望步数。注意，每个节点只与$$T$$中的元素的$$x$$相关。

我们给所有$$\{x_i|i\in T,\exists x_i=b_i\}$$的节点连向且只连向一个终止节点$$end$$，边权为$$0$$，设初始节点$$start=\{x_i|i\in T,x_i=0\}$$。

那么实际上，$$E(min(T))$$就等于$$start$$到$$end$$的期望步数。

我们想把整个贡献拆分成边的贡献。

我们考虑在这个图上$$dp$$，$$f[s]$$表示到达$$s$$这个状态点的期望步数，设$$t$$为$$s$$的一个后继状态，那么显然有
$$
f[t]+=(f[s]+w(s,t))*P(start->s)*p(s,t)
$$
其中$$w(s,t)$$指$$s->t$$的期望步数，$$p(s,t)$$指的是从$$s->t$$的概率，$$P(start->s)$$表示$$start$$到$$s$$的概率。

我们不需要求到达每个点的期望，只需要求那个总贡献。

我们观察每条边$$(s,t)$$的贡献，发现实际上它的贡献是
$$
P(start->s)*p(s,t)*w(s,t)*P(t->end)
$$
对于任何一个节点，它最终一定能走到$$end$$，所以$$P(t->end)=1$$，那么每条边的贡献是
$$
P(start->s)*p(s,t)*w(s,t)
$$
注意到对于任何一个$$s$$，我们设
$$
w(s,nxt)=\sum_t p(s,t)*w(s,t)
$$
实际上，$$w(s,nxt)$$是我们可以算出来的，即每个状态到下一个状态（不管具体是什么，只要与$$s$$不同）的期望步数，具体怎么算，我们后面再说。

那么我们可以考虑计算**每个点连出去的边对答案的贡献和**。

那么，所有的贡献就可以写成
$$
\sum_s P(start->s)*w(s,nxt)
$$
这样，我们就证明了。实际上，这个推演方法可以推广到很多相关的题目中。

那么$$w(s,nxt)$$等于什么呢？我们设其为$$W$$，所有$$a_i$$的和为$$S$$，所有$$i\in T$$的$$a_i$$和为$$S_T$$，则
$$
W=\frac{S_T}{S}*1+(1-\frac{S_T}{S})*(W+1)\\
W=\frac{S}{S_T}
$$
我们现在的问题，就是求对于某个$$s$$，$$P(start->s)$$的值。

好，这又是这道题的另一个难点！

我们设$$X=\sum x_i$$，我们考虑这个随机数生成器生成的序列$$t_1,t_2,...$$，那么，我们考虑的是这个序列中前$$X$$个出现$$T$$中存在的数的位置构成的数列。

别的位置生成任何一个数我们都不关心，概率为$$1$$，对我们要考虑的东西没有影响。

所以我们相当于单独把这$$X$$个数拿来讨论。

我们要考虑的，是这$$X$$个数中对于每一个$$i$$，满足$$i$$出现了$$x_i$$次的概率。

因为这$$X$$个数只会出现$$T$$中有的数，所以别的数我们一概忽略，这$$X$$个数中每个数出现的概率为$$\frac{a_i}{S_T}$$。

那么总概率为
$$
\frac{X!}{\prod_{i\in T}x_i!}\prod_{i\in T}(\frac{a_i}{S_T})^{x_i}
$$
为什么呢？我们考虑后面那个式子，是我们钦定了这$$X$$个数出现的顺序并且每个$$i$$出现$$x_i$$次的概率，但是这些数是可以无序出现的，所以我们要乘以这些东西出现的顺序，就是前面那一项。

我们考虑如果枚举$$T$$的话时间复杂度是不现实的，

所以我们现在考虑把**最后的答案$$ANS$$**拆成每个状态$$s$$的贡献。

我们每一个$$s$$对于一个$$T$$的贡献是
$$
\frac{S}{S_T}*\frac{X!}{\prod_{i\in T}x_i!}\prod_{i\in T}(\frac{a_i}{S_T})^{x_i}\\
=S*X!*(\frac{1}{S_T})^{X+1}\prod_{i\in T}\frac{a_i^{x_i}}{x_i!}
$$
好，我们观察这个式子，发现实际上前面只与$$X$$和$$S_T$$有关，后面才与每个数相关，而奇妙的时候，后面每个数的贡献都是独立的，与$$T$$这个集合总体无关。

接下来也十分巧妙！

那么，我们考虑$$dp$$，设$$f[i][j]$$表示所有的$$s$$满足$$S_T=i$$，$$X=j$$的容斥系数之和是多少。

我们枚举每一位选或不选来转移，如果不选，就继承上一次的答案，如果选了，因为多加了一个元素，所以容斥系数取反，然后转移一下就好了，细节见代码。

注意，初始状态为$$f[0][0]=-1$$，因为$$min-max$$容斥的系数是$$(-1)^{|T|-1}$$。

复杂度$$O((\sum a_i)(\sum b_i)^2)$$。

# Code

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxN = 405, mod = 998244353;

int n, a[maxN + 1], b[maxN + 1], sa, sb;
int f[2][maxN + 1][maxN + 1];
int fac[maxN + 1], inv[maxN + 1];

inline int ADD(int x, int y) { return x + y >= mod ? x + y - mod : x + y; }

inline int SUB(int x, int y) { return x - y < 0 ? x - y + mod : x - y; }

inline int mpow(int a, int x)
{
	int ans = 1;
	while(x)
	{
		if(x & 1) ans = 1ll * ans * a % mod;
		a = 1ll * a * a % mod;
		x >>= 1;
	}
	return ans;
}

int main()
{
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) 
		scanf("%d %d", &a[i], &b[i]), sa += a[i], sb += b[i];

	fac[0] = 1;
	for(int i = 1; i <= sb; i++) fac[i] = 1ll * fac[i - 1] * i % mod;
	inv[sb] = mpow(fac[sb], mod - 2);
	for(int i = sb - 1; i >= 0; i--) inv[i] = 1ll * inv[i + 1] * (i + 1) % mod;

	int now = 0;
	f[now][0][0] = mod - 1;
	for(int i = 1; i <= n; i++)
	{
		now ^= 1;
		for(int s = 0; s <= sa; s++)
			for(int x = 0; x <= sb; x++)
			{
				f[now][s][x] = f[now ^ 1][s][x];
				if(s < a[i]) continue;
				for(int t = 0, w = 1; t < b[i] && t <= x; t++, w = 1ll * w * a[i] % mod)
					f[now][s][x] = SUB(f[now][s][x], 1ll * w * inv[t] % mod * f[now ^ 1][s - a[i]][x - t] % mod);			   
				}	
	}

	int ans = 0;
	for(int s = 0; s <= sa; s++)
	{
		int INV = mpow(s, mod - 2);
		for(int x = 0, t = INV; x <= sb; x++, t = 1ll * t * INV % mod)
			ans = ADD(ans, 1ll * t * fac[x] % mod * f[now][s][x] % mod);
	}

	ans = 1ll * ans * sa % mod;
	printf("%d", ans);
	return 0;
}

```

# 总结

首先，这道题蕴含了许多的概率期望技巧和套路，需要牢记一些小$$trick$$，例如把总的期望步数拆成每个状态到其后继的期望步数乘以到这个状态的概率，还有可重复的数列出现概率的计算，都是应该仔细揣摩的。

然后，有一个思想十分重要，就是我们考虑一个数列中只跟某个集合中的数有关的位置时，我们可以忽略其他数的影响，直接考虑这些位置本身的相对关系，包括这里概率的计算，和之前有些题都是一样，这样可以大大减少思维难度，相当于只考虑一个跟这个集合中有关的数列的概率一样，因为其他位置不管出现什么数都无关，所以概率时$$1$$，可以忽略。

最后，非常重要的$$dp$$，我们要观察到一个东西的贡献式子如果只与这个东西的某些性质有关（比如这一题，只与集合的$$\sum a_i$$和$$\sum x_i$$有关），其他的都是独立的话，我们就可以$$dp$$，把状态设为这些性质，然后$$dp$$出其贡献的系数，最后累加即可，也是一个非常重要的思想。